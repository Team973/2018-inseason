<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2018-inseason: C API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">2018-inseason
   </div>
   <div id="projectbrief">The Greybots&#39; 2018 Power Up code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">C API<div class="ingroups"><a class="el" href="group__imgproc.html">Image processing</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_font.html">CvFont</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_connected_comp.html">CvConnectedComp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_moments.html">CvMoments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_hu_moments.html">CvHuMoments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_chain_pt_reader.html">CvChainPtReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_convexity_defect.html">CvConvexityDefect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae842717d2116ce52fac4727bd02d4eb0"><td class="memItemLeft" align="right" valign="top"><a id="gae842717d2116ce52fac4727bd02d4eb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cvCalcBackProject</b>(image,  dst,  hist)&#160;&#160;&#160;cvCalcArrBackProject((<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a>**)image, dst, hist)</td></tr>
<tr class="separator:gae842717d2116ce52fac4727bd02d4eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633a12e74beb80ea22c690d12d9915cb"><td class="memItemLeft" align="right" valign="top"><a id="ga633a12e74beb80ea22c690d12d9915cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cvCalcBackProjectPatch</b>(image,  dst,  range,  hist,  method,  factor)&#160;&#160;&#160;cvCalcArrBackProjectPatch( (<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a>**)image, dst, range, hist, method, factor )</td></tr>
<tr class="separator:ga633a12e74beb80ea22c690d12d9915cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16fe14b01ea8dffdf2405dc5534e5f15"><td class="memItemLeft" align="right" valign="top"><a id="ga16fe14b01ea8dffdf2405dc5534e5f15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_RGB</b>(r,  g,  b)&#160;&#160;&#160;cvScalar( (b), (g), (r), 0 )</td></tr>
<tr class="separator:ga16fe14b01ea8dffdf2405dc5534e5f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bbcfe5cf6dfb89747c48d124da67c64"><td class="memItemLeft" align="right" valign="top"><a id="ga0bbcfe5cf6dfb89747c48d124da67c64"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FILLED</b>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:ga0bbcfe5cf6dfb89747c48d124da67c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a38de93cb76391d98a1545d587a8ff"><td class="memItemLeft" align="right" valign="top"><a id="ga32a38de93cb76391d98a1545d587a8ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_AA</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ga32a38de93cb76391d98a1545d587a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga419a1fc5285d1742e4808d63732c31ad"><td class="memItemLeft" align="right" valign="top"><a id="ga419a1fc5285d1742e4808d63732c31ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cvDrawRect</b>&#160;&#160;&#160;cvRectangle</td></tr>
<tr class="separator:ga419a1fc5285d1742e4808d63732c31ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf73695a68e6782512f0ecb958e22ece"><td class="memItemLeft" align="right" valign="top"><a id="gaaf73695a68e6782512f0ecb958e22ece"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cvDrawLine</b>&#160;&#160;&#160;cvLine</td></tr>
<tr class="separator:gaaf73695a68e6782512f0ecb958e22ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a67686039a3997def8c1ea4994294d"><td class="memItemLeft" align="right" valign="top"><a id="ga66a67686039a3997def8c1ea4994294d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cvDrawCircle</b>&#160;&#160;&#160;cvCircle</td></tr>
<tr class="separator:ga66a67686039a3997def8c1ea4994294d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a0a0e5b57ac41e0051e37b3e249505"><td class="memItemLeft" align="right" valign="top"><a id="ga70a0a0e5b57ac41e0051e37b3e249505"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cvDrawEllipse</b>&#160;&#160;&#160;cvEllipse</td></tr>
<tr class="separator:ga70a0a0e5b57ac41e0051e37b3e249505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d6df8e82501399f3f619f30e3fa0f9"><td class="memItemLeft" align="right" valign="top"><a id="gaf5d6df8e82501399f3f619f30e3fa0f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cvDrawPolyLine</b>&#160;&#160;&#160;cvPolyLine</td></tr>
<tr class="separator:gaf5d6df8e82501399f3f619f30e3fa0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d99d5caee87b79157e1b9d491be9c25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_NEXT_LINE_POINT</b>(line_iterator)</td></tr>
<tr class="separator:ga8d99d5caee87b79157e1b9d491be9c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c8488369d94bc5ff00836859da4cf3"><td class="memItemLeft" align="right" valign="top"><a id="ga15c8488369d94bc5ff00836859da4cf3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_SIMPLEX</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga15c8488369d94bc5ff00836859da4cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1600a7994221230ba2e9b7bd835f01"><td class="memItemLeft" align="right" valign="top"><a id="ga3c1600a7994221230ba2e9b7bd835f01"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_PLAIN</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga3c1600a7994221230ba2e9b7bd835f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f709df2f80855399f42d6ca4b3db818"><td class="memItemLeft" align="right" valign="top"><a id="ga2f709df2f80855399f42d6ca4b3db818"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_DUPLEX</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga2f709df2f80855399f42d6ca4b3db818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b6e76528d1eb546b8c425b80568b19"><td class="memItemLeft" align="right" valign="top"><a id="gad5b6e76528d1eb546b8c425b80568b19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_COMPLEX</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:gad5b6e76528d1eb546b8c425b80568b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa920c2a58d66756073813934290b32"><td class="memItemLeft" align="right" valign="top"><a id="gaafa920c2a58d66756073813934290b32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_TRIPLEX</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gaafa920c2a58d66756073813934290b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7bee788a4f4fd2aff89c38b7277a64"><td class="memItemLeft" align="right" valign="top"><a id="gaee7bee788a4f4fd2aff89c38b7277a64"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_COMPLEX_SMALL</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:gaee7bee788a4f4fd2aff89c38b7277a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8592da082e69a71c558e38faef3ad2b1"><td class="memItemLeft" align="right" valign="top"><a id="ga8592da082e69a71c558e38faef3ad2b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_SCRIPT_SIMPLEX</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ga8592da082e69a71c558e38faef3ad2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae29525ea0d8010b79b657827bf9d2fe9"><td class="memItemLeft" align="right" valign="top"><a id="gae29525ea0d8010b79b657827bf9d2fe9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_HERSHEY_SCRIPT_COMPLEX</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:gae29525ea0d8010b79b657827bf9d2fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12cfb7a768bfc561259f7fd36f38a4dd"><td class="memItemLeft" align="right" valign="top"><a id="ga12cfb7a768bfc561259f7fd36f38a4dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_ITALIC</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ga12cfb7a768bfc561259f7fd36f38a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd5dab67ad63b70c583128b366f26ad"><td class="memItemLeft" align="right" valign="top"><a id="ga6dd5dab67ad63b70c583128b366f26ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_FONT_VECTOR0</b>&#160;&#160;&#160;CV_FONT_HERSHEY_SIMPLEX</td></tr>
<tr class="separator:ga6dd5dab67ad63b70c583128b366f26ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd47b69c3f9fc86ba30c92488645229d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gadd47b69c3f9fc86ba30c92488645229d">CV_INIT_3X3_DELTAS</a>(deltas,  step,  nch)</td></tr>
<tr class="separator:gadd47b69c3f9fc86ba30c92488645229d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga006b1ff87dfa7cf766db6c6a09a43310"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_cv_font.html">CvFont</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga006b1ff87dfa7cf766db6c6a09a43310">CvFont</a></td></tr>
<tr class="separator:ga006b1ff87dfa7cf766db6c6a09a43310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae187bc007c9e041da9b97dcfe0431b64"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_cv_connected_comp.html">CvConnectedComp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gae187bc007c9e041da9b97dcfe0431b64">CvConnectedComp</a></td></tr>
<tr class="separator:gae187bc007c9e041da9b97dcfe0431b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga738efca5ab93feb8333bbe24f8d57839"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_cv_moments.html">CvMoments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga738efca5ab93feb8333bbe24f8d57839">CvMoments</a></td></tr>
<tr class="separator:ga738efca5ab93feb8333bbe24f8d57839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a4d1d82e0dd8e0faa464584472747a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_cv_hu_moments.html">CvHuMoments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga85a4d1d82e0dd8e0faa464584472747a">CvHuMoments</a></td></tr>
<tr class="separator:ga85a4d1d82e0dd8e0faa464584472747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7976571b4fb9c00f8f63e864a3d6cfe7"><td class="memItemLeft" align="right" valign="top"><a id="ga7976571b4fb9c00f8f63e864a3d6cfe7"></a>
typedef float(CV_CDECL *&#160;</td><td class="memItemRight" valign="bottom"><b>CvDistanceFunction</b>) (const float *a, const float *b, void *user_param)</td></tr>
<tr class="separator:ga7976571b4fb9c00f8f63e864a3d6cfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d28023276f66bd42d8a7f97a0712ae"><td class="memItemLeft" align="right" valign="top"><a id="ga11d28023276f66bd42d8a7f97a0712ae"></a>
typedef struct _CvContourScanner *&#160;</td><td class="memItemRight" valign="bottom"><b>CvContourScanner</b></td></tr>
<tr class="separator:ga11d28023276f66bd42d8a7f97a0712ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126c3960af8241b0065211bcb0c4c4ee"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_cv_chain_pt_reader.html">CvChainPtReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga126c3960af8241b0065211bcb0c4c4ee">CvChainPtReader</a></td></tr>
<tr class="separator:ga126c3960af8241b0065211bcb0c4c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601b02375a2915aa2e653562da03cd93"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_cv_convexity_defect.html">CvConvexityDefect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga601b02375a2915aa2e653562da03cd93">CvConvexityDefect</a></td></tr>
<tr class="separator:ga601b02375a2915aa2e653562da03cd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga68a3a4144ad5ad650bed7f0ede3611c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga68a3a4144ad5ad650bed7f0ede3611c2">SmoothMethod_c</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__c.html#gga68a3a4144ad5ad650bed7f0ede3611c2aa06086448eff38b500b296baa0ff6590">CV_BLUR_NO_SCALE</a> =0, 
<a class="el" href="group__imgproc__c.html#gga68a3a4144ad5ad650bed7f0ede3611c2abd20b6c1b1f0779073712a370a3c64f9">CV_BLUR</a> =1, 
<a class="el" href="group__imgproc__c.html#gga68a3a4144ad5ad650bed7f0ede3611c2a5f9c9d19089c103e1324b65ef51b77b1">CV_GAUSSIAN</a> =2, 
<a class="el" href="group__imgproc__c.html#gga68a3a4144ad5ad650bed7f0ede3611c2a0110fa78c2574e7eceb7e4d3a9015a56">CV_MEDIAN</a> =3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__c.html#gga68a3a4144ad5ad650bed7f0ede3611c2af3992d7005749422f871b7ea70e975b0">CV_BILATERAL</a> =4
<br />
 }</td></tr>
<tr class="separator:ga68a3a4144ad5ad650bed7f0ede3611c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52ea6a123f47db5e6b145e5fc5e369a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_GAUSSIAN_5x5</b> = 7
 }</td></tr>
<tr class="separator:gaa52ea6a123f47db5e6b145e5fc5e369a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccaefcc48c7849e1f3defa3f1fd1f8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_SCHARR</b> =-1, 
<b>CV_MAX_SOBEL_KSIZE</b> =7
 }</td></tr>
<tr class="separator:gafccaefcc48c7849e1f3defa3f1fd1f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7477aaaec7caec07471eb609c556f5f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>CV_BGR2BGRA</b> =0, 
<b>CV_RGB2RGBA</b> =CV_BGR2BGRA, 
<b>CV_BGRA2BGR</b> =1, 
<b>CV_RGBA2RGB</b> =CV_BGRA2BGR, 
<br />
&#160;&#160;<b>CV_BGR2RGBA</b> =2, 
<b>CV_RGB2BGRA</b> =CV_BGR2RGBA, 
<b>CV_RGBA2BGR</b> =3, 
<b>CV_BGRA2RGB</b> =CV_RGBA2BGR, 
<br />
&#160;&#160;<b>CV_BGR2RGB</b> =4, 
<b>CV_RGB2BGR</b> =CV_BGR2RGB, 
<b>CV_BGRA2RGBA</b> =5, 
<b>CV_RGBA2BGRA</b> =CV_BGRA2RGBA, 
<br />
&#160;&#160;<b>CV_BGR2GRAY</b> =6, 
<b>CV_RGB2GRAY</b> =7, 
<b>CV_GRAY2BGR</b> =8, 
<b>CV_GRAY2RGB</b> =CV_GRAY2BGR, 
<br />
&#160;&#160;<b>CV_GRAY2BGRA</b> =9, 
<b>CV_GRAY2RGBA</b> =CV_GRAY2BGRA, 
<b>CV_BGRA2GRAY</b> =10, 
<b>CV_RGBA2GRAY</b> =11, 
<br />
&#160;&#160;<b>CV_BGR2BGR565</b> =12, 
<b>CV_RGB2BGR565</b> =13, 
<b>CV_BGR5652BGR</b> =14, 
<b>CV_BGR5652RGB</b> =15, 
<br />
&#160;&#160;<b>CV_BGRA2BGR565</b> =16, 
<b>CV_RGBA2BGR565</b> =17, 
<b>CV_BGR5652BGRA</b> =18, 
<b>CV_BGR5652RGBA</b> =19, 
<br />
&#160;&#160;<b>CV_GRAY2BGR565</b> =20, 
<b>CV_BGR5652GRAY</b> =21, 
<b>CV_BGR2BGR555</b> =22, 
<b>CV_RGB2BGR555</b> =23, 
<br />
&#160;&#160;<b>CV_BGR5552BGR</b> =24, 
<b>CV_BGR5552RGB</b> =25, 
<b>CV_BGRA2BGR555</b> =26, 
<b>CV_RGBA2BGR555</b> =27, 
<br />
&#160;&#160;<b>CV_BGR5552BGRA</b> =28, 
<b>CV_BGR5552RGBA</b> =29, 
<b>CV_GRAY2BGR555</b> =30, 
<b>CV_BGR5552GRAY</b> =31, 
<br />
&#160;&#160;<b>CV_BGR2XYZ</b> =32, 
<b>CV_RGB2XYZ</b> =33, 
<b>CV_XYZ2BGR</b> =34, 
<b>CV_XYZ2RGB</b> =35, 
<br />
&#160;&#160;<b>CV_BGR2YCrCb</b> =36, 
<b>CV_RGB2YCrCb</b> =37, 
<b>CV_YCrCb2BGR</b> =38, 
<b>CV_YCrCb2RGB</b> =39, 
<br />
&#160;&#160;<b>CV_BGR2HSV</b> =40, 
<b>CV_RGB2HSV</b> =41, 
<b>CV_BGR2Lab</b> =44, 
<b>CV_RGB2Lab</b> =45, 
<br />
&#160;&#160;<b>CV_BayerBG2BGR</b> =46, 
<b>CV_BayerGB2BGR</b> =47, 
<b>CV_BayerRG2BGR</b> =48, 
<b>CV_BayerGR2BGR</b> =49, 
<br />
&#160;&#160;<b>CV_BayerBG2RGB</b> =CV_BayerRG2BGR, 
<b>CV_BayerGB2RGB</b> =CV_BayerGR2BGR, 
<b>CV_BayerRG2RGB</b> =CV_BayerBG2BGR, 
<b>CV_BayerGR2RGB</b> =CV_BayerGB2BGR, 
<br />
&#160;&#160;<b>CV_BGR2Luv</b> =50, 
<b>CV_RGB2Luv</b> =51, 
<b>CV_BGR2HLS</b> =52, 
<b>CV_RGB2HLS</b> =53, 
<br />
&#160;&#160;<b>CV_HSV2BGR</b> =54, 
<b>CV_HSV2RGB</b> =55, 
<b>CV_Lab2BGR</b> =56, 
<b>CV_Lab2RGB</b> =57, 
<br />
&#160;&#160;<b>CV_Luv2BGR</b> =58, 
<b>CV_Luv2RGB</b> =59, 
<b>CV_HLS2BGR</b> =60, 
<b>CV_HLS2RGB</b> =61, 
<br />
&#160;&#160;<b>CV_BayerBG2BGR_VNG</b> =62, 
<b>CV_BayerGB2BGR_VNG</b> =63, 
<b>CV_BayerRG2BGR_VNG</b> =64, 
<b>CV_BayerGR2BGR_VNG</b> =65, 
<br />
&#160;&#160;<b>CV_BayerBG2RGB_VNG</b> =CV_BayerRG2BGR_VNG, 
<b>CV_BayerGB2RGB_VNG</b> =CV_BayerGR2BGR_VNG, 
<b>CV_BayerRG2RGB_VNG</b> =CV_BayerBG2BGR_VNG, 
<b>CV_BayerGR2RGB_VNG</b> =CV_BayerGB2BGR_VNG, 
<br />
&#160;&#160;<b>CV_BGR2HSV_FULL</b> = 66, 
<b>CV_RGB2HSV_FULL</b> = 67, 
<b>CV_BGR2HLS_FULL</b> = 68, 
<b>CV_RGB2HLS_FULL</b> = 69, 
<br />
&#160;&#160;<b>CV_HSV2BGR_FULL</b> = 70, 
<b>CV_HSV2RGB_FULL</b> = 71, 
<b>CV_HLS2BGR_FULL</b> = 72, 
<b>CV_HLS2RGB_FULL</b> = 73, 
<br />
&#160;&#160;<b>CV_LBGR2Lab</b> = 74, 
<b>CV_LRGB2Lab</b> = 75, 
<b>CV_LBGR2Luv</b> = 76, 
<b>CV_LRGB2Luv</b> = 77, 
<br />
&#160;&#160;<b>CV_Lab2LBGR</b> = 78, 
<b>CV_Lab2LRGB</b> = 79, 
<b>CV_Luv2LBGR</b> = 80, 
<b>CV_Luv2LRGB</b> = 81, 
<br />
&#160;&#160;<b>CV_BGR2YUV</b> = 82, 
<b>CV_RGB2YUV</b> = 83, 
<b>CV_YUV2BGR</b> = 84, 
<b>CV_YUV2RGB</b> = 85, 
<br />
&#160;&#160;<b>CV_BayerBG2GRAY</b> = 86, 
<b>CV_BayerGB2GRAY</b> = 87, 
<b>CV_BayerRG2GRAY</b> = 88, 
<b>CV_BayerGR2GRAY</b> = 89, 
<br />
&#160;&#160;<b>CV_YUV2RGB_NV12</b> = 90, 
<b>CV_YUV2BGR_NV12</b> = 91, 
<b>CV_YUV2RGB_NV21</b> = 92, 
<b>CV_YUV2BGR_NV21</b> = 93, 
<br />
&#160;&#160;<b>CV_YUV420sp2RGB</b> = CV_YUV2RGB_NV21, 
<b>CV_YUV420sp2BGR</b> = CV_YUV2BGR_NV21, 
<b>CV_YUV2RGBA_NV12</b> = 94, 
<b>CV_YUV2BGRA_NV12</b> = 95, 
<br />
&#160;&#160;<b>CV_YUV2RGBA_NV21</b> = 96, 
<b>CV_YUV2BGRA_NV21</b> = 97, 
<b>CV_YUV420sp2RGBA</b> = CV_YUV2RGBA_NV21, 
<b>CV_YUV420sp2BGRA</b> = CV_YUV2BGRA_NV21, 
<br />
&#160;&#160;<b>CV_YUV2RGB_YV12</b> = 98, 
<b>CV_YUV2BGR_YV12</b> = 99, 
<b>CV_YUV2RGB_IYUV</b> = 100, 
<b>CV_YUV2BGR_IYUV</b> = 101, 
<br />
&#160;&#160;<b>CV_YUV2RGB_I420</b> = CV_YUV2RGB_IYUV, 
<b>CV_YUV2BGR_I420</b> = CV_YUV2BGR_IYUV, 
<b>CV_YUV420p2RGB</b> = CV_YUV2RGB_YV12, 
<b>CV_YUV420p2BGR</b> = CV_YUV2BGR_YV12, 
<br />
&#160;&#160;<b>CV_YUV2RGBA_YV12</b> = 102, 
<b>CV_YUV2BGRA_YV12</b> = 103, 
<b>CV_YUV2RGBA_IYUV</b> = 104, 
<b>CV_YUV2BGRA_IYUV</b> = 105, 
<br />
&#160;&#160;<b>CV_YUV2RGBA_I420</b> = CV_YUV2RGBA_IYUV, 
<b>CV_YUV2BGRA_I420</b> = CV_YUV2BGRA_IYUV, 
<b>CV_YUV420p2RGBA</b> = CV_YUV2RGBA_YV12, 
<b>CV_YUV420p2BGRA</b> = CV_YUV2BGRA_YV12, 
<br />
&#160;&#160;<b>CV_YUV2GRAY_420</b> = 106, 
<b>CV_YUV2GRAY_NV21</b> = CV_YUV2GRAY_420, 
<b>CV_YUV2GRAY_NV12</b> = CV_YUV2GRAY_420, 
<b>CV_YUV2GRAY_YV12</b> = CV_YUV2GRAY_420, 
<br />
&#160;&#160;<b>CV_YUV2GRAY_IYUV</b> = CV_YUV2GRAY_420, 
<b>CV_YUV2GRAY_I420</b> = CV_YUV2GRAY_420, 
<b>CV_YUV420sp2GRAY</b> = CV_YUV2GRAY_420, 
<b>CV_YUV420p2GRAY</b> = CV_YUV2GRAY_420, 
<br />
&#160;&#160;<b>CV_YUV2RGB_UYVY</b> = 107, 
<b>CV_YUV2BGR_UYVY</b> = 108, 
<b>CV_YUV2RGB_Y422</b> = CV_YUV2RGB_UYVY, 
<b>CV_YUV2BGR_Y422</b> = CV_YUV2BGR_UYVY, 
<br />
&#160;&#160;<b>CV_YUV2RGB_UYNV</b> = CV_YUV2RGB_UYVY, 
<b>CV_YUV2BGR_UYNV</b> = CV_YUV2BGR_UYVY, 
<b>CV_YUV2RGBA_UYVY</b> = 111, 
<b>CV_YUV2BGRA_UYVY</b> = 112, 
<br />
&#160;&#160;<b>CV_YUV2RGBA_Y422</b> = CV_YUV2RGBA_UYVY, 
<b>CV_YUV2BGRA_Y422</b> = CV_YUV2BGRA_UYVY, 
<b>CV_YUV2RGBA_UYNV</b> = CV_YUV2RGBA_UYVY, 
<b>CV_YUV2BGRA_UYNV</b> = CV_YUV2BGRA_UYVY, 
<br />
&#160;&#160;<b>CV_YUV2RGB_YUY2</b> = 115, 
<b>CV_YUV2BGR_YUY2</b> = 116, 
<b>CV_YUV2RGB_YVYU</b> = 117, 
<b>CV_YUV2BGR_YVYU</b> = 118, 
<br />
&#160;&#160;<b>CV_YUV2RGB_YUYV</b> = CV_YUV2RGB_YUY2, 
<b>CV_YUV2BGR_YUYV</b> = CV_YUV2BGR_YUY2, 
<b>CV_YUV2RGB_YUNV</b> = CV_YUV2RGB_YUY2, 
<b>CV_YUV2BGR_YUNV</b> = CV_YUV2BGR_YUY2, 
<br />
&#160;&#160;<b>CV_YUV2RGBA_YUY2</b> = 119, 
<b>CV_YUV2BGRA_YUY2</b> = 120, 
<b>CV_YUV2RGBA_YVYU</b> = 121, 
<b>CV_YUV2BGRA_YVYU</b> = 122, 
<br />
&#160;&#160;<b>CV_YUV2RGBA_YUYV</b> = CV_YUV2RGBA_YUY2, 
<b>CV_YUV2BGRA_YUYV</b> = CV_YUV2BGRA_YUY2, 
<b>CV_YUV2RGBA_YUNV</b> = CV_YUV2RGBA_YUY2, 
<b>CV_YUV2BGRA_YUNV</b> = CV_YUV2BGRA_YUY2, 
<br />
&#160;&#160;<b>CV_YUV2GRAY_UYVY</b> = 123, 
<b>CV_YUV2GRAY_YUY2</b> = 124, 
<b>CV_YUV2GRAY_Y422</b> = CV_YUV2GRAY_UYVY, 
<b>CV_YUV2GRAY_UYNV</b> = CV_YUV2GRAY_UYVY, 
<br />
&#160;&#160;<b>CV_YUV2GRAY_YVYU</b> = CV_YUV2GRAY_YUY2, 
<b>CV_YUV2GRAY_YUYV</b> = CV_YUV2GRAY_YUY2, 
<b>CV_YUV2GRAY_YUNV</b> = CV_YUV2GRAY_YUY2, 
<b>CV_RGBA2mRGBA</b> = 125, 
<br />
&#160;&#160;<b>CV_mRGBA2RGBA</b> = 126, 
<b>CV_RGB2YUV_I420</b> = 127, 
<b>CV_BGR2YUV_I420</b> = 128, 
<b>CV_RGB2YUV_IYUV</b> = CV_RGB2YUV_I420, 
<br />
&#160;&#160;<b>CV_BGR2YUV_IYUV</b> = CV_BGR2YUV_I420, 
<b>CV_RGBA2YUV_I420</b> = 129, 
<b>CV_BGRA2YUV_I420</b> = 130, 
<b>CV_RGBA2YUV_IYUV</b> = CV_RGBA2YUV_I420, 
<br />
&#160;&#160;<b>CV_BGRA2YUV_IYUV</b> = CV_BGRA2YUV_I420, 
<b>CV_RGB2YUV_YV12</b> = 131, 
<b>CV_BGR2YUV_YV12</b> = 132, 
<b>CV_RGBA2YUV_YV12</b> = 133, 
<br />
&#160;&#160;<b>CV_BGRA2YUV_YV12</b> = 134, 
<b>CV_BayerBG2BGR_EA</b> = 135, 
<b>CV_BayerGB2BGR_EA</b> = 136, 
<b>CV_BayerRG2BGR_EA</b> = 137, 
<br />
&#160;&#160;<b>CV_BayerGR2BGR_EA</b> = 138, 
<b>CV_BayerBG2RGB_EA</b> = CV_BayerRG2BGR_EA, 
<b>CV_BayerGB2RGB_EA</b> = CV_BayerGR2BGR_EA, 
<b>CV_BayerRG2RGB_EA</b> = CV_BayerBG2BGR_EA, 
<br />
&#160;&#160;<b>CV_BayerGR2RGB_EA</b> = CV_BayerGB2BGR_EA, 
<b>CV_COLORCVT_MAX</b> = 139
<br />
 }</td></tr>
<tr class="separator:gaa7477aaaec7caec07471eb609c556f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6db2c38ebc194c80d154d53851a4d5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>CV_INTER_NN</b> =0, 
<b>CV_INTER_LINEAR</b> =1, 
<b>CV_INTER_CUBIC</b> =2, 
<b>CV_INTER_AREA</b> =3, 
<br />
&#160;&#160;<b>CV_INTER_LANCZOS4</b> =4
<br />
 }</td></tr>
<tr class="separator:gaa6db2c38ebc194c80d154d53851a4d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c221b877c671251f317a43dbea2583"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_WARP_FILL_OUTLIERS</b> =8, 
<b>CV_WARP_INVERSE_MAP</b> =16
 }</td></tr>
<tr class="separator:gae7c221b877c671251f317a43dbea2583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b30479580723fe97bab56d9b69239d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gab5b30479580723fe97bab56d9b69239d">MorphShapes_c</a> { <b>CV_SHAPE_RECT</b> =0, 
<b>CV_SHAPE_CROSS</b> =1, 
<b>CV_SHAPE_ELLIPSE</b> =2, 
<a class="el" href="group__imgproc__c.html#ggab5b30479580723fe97bab56d9b69239dae7372371053c086eb9cf79d41769af59">CV_SHAPE_CUSTOM</a> =100
 }</td></tr>
<tr class="separator:gab5b30479580723fe97bab56d9b69239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa6e789ab8d8c920f2104ee8c183196"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>CV_MOP_ERODE</b> =0, 
<b>CV_MOP_DILATE</b> =1, 
<b>CV_MOP_OPEN</b> =2, 
<b>CV_MOP_CLOSE</b> =3, 
<br />
&#160;&#160;<b>CV_MOP_GRADIENT</b> =4, 
<b>CV_MOP_TOPHAT</b> =5, 
<b>CV_MOP_BLACKHAT</b> =6
<br />
 }</td></tr>
<tr class="separator:ga0fa6e789ab8d8c920f2104ee8c183196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8d14defa336cd0180dccd1e0170dd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>CV_TM_SQDIFF</b> =0, 
<b>CV_TM_SQDIFF_NORMED</b> =1, 
<b>CV_TM_CCORR</b> =2, 
<b>CV_TM_CCORR_NORMED</b> =3, 
<br />
&#160;&#160;<b>CV_TM_CCOEFF</b> =4, 
<b>CV_TM_CCOEFF_NORMED</b> =5
<br />
 }</td></tr>
<tr class="separator:ga6d8d14defa336cd0180dccd1e0170dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b7364b5ceec8a2d131dc2cf2587628"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>CV_RETR_EXTERNAL</b> =0, 
<b>CV_RETR_LIST</b> =1, 
<b>CV_RETR_CCOMP</b> =2, 
<b>CV_RETR_TREE</b> =3, 
<br />
&#160;&#160;<b>CV_RETR_FLOODFILL</b> =4
<br />
 }</td></tr>
<tr class="separator:ga48b7364b5ceec8a2d131dc2cf2587628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc5993fe6fd7fec62e94ef57859c353"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>CV_CHAIN_CODE</b> =0, 
<b>CV_CHAIN_APPROX_NONE</b> =1, 
<b>CV_CHAIN_APPROX_SIMPLE</b> =2, 
<b>CV_CHAIN_APPROX_TC89_L1</b> =3, 
<br />
&#160;&#160;<b>CV_CHAIN_APPROX_TC89_KCOS</b> =4, 
<b>CV_LINK_RUNS</b> =5
<br />
 }</td></tr>
<tr class="separator:gaafc5993fe6fd7fec62e94ef57859c353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d22175c5de65fbe6a0b3b53305dee4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_POLY_APPROX_DP</b> = 0
 }</td></tr>
<tr class="separator:ga87d22175c5de65fbe6a0b3b53305dee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd971ae682604ff73cdb88645725968d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gacd971ae682604ff73cdb88645725968d">ShapeMatchModes</a> { <a class="el" href="group__imgproc__c.html#ggacd971ae682604ff73cdb88645725968da6ae4597e01365cd5c3469dc2f5cd2fea">CV_CONTOURS_MATCH_I1</a> =1, 
<a class="el" href="group__imgproc__c.html#ggacd971ae682604ff73cdb88645725968dae3011fca74bc54836e9457de352069eb">CV_CONTOURS_MATCH_I2</a> =2, 
<a class="el" href="group__imgproc__c.html#ggacd971ae682604ff73cdb88645725968dad2141011f1cd57f6542c7da2412c9fe3">CV_CONTOURS_MATCH_I3</a> =3
 }</td></tr>
<tr class="memdesc:gacd971ae682604ff73cdb88645725968d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape matching methods.  <a href="group__imgproc__c.html#gacd971ae682604ff73cdb88645725968d">More...</a><br /></td></tr>
<tr class="separator:gacd971ae682604ff73cdb88645725968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed332df4696233768771e93d4081c3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_CLOCKWISE</b> =1, 
<b>CV_COUNTER_CLOCKWISE</b> =2
 }</td></tr>
<tr class="separator:ga2ed332df4696233768771e93d4081c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e279efabf854742684341c3e4f50d31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>CV_COMP_CORREL</b> =0, 
<b>CV_COMP_CHISQR</b> =1, 
<b>CV_COMP_INTERSECT</b> =2, 
<b>CV_COMP_BHATTACHARYYA</b> =3, 
<br />
&#160;&#160;<b>CV_COMP_HELLINGER</b> =CV_COMP_BHATTACHARYYA, 
<b>CV_COMP_CHISQR_ALT</b> =4, 
<b>CV_COMP_KL_DIV</b> =5
<br />
 }</td></tr>
<tr class="separator:ga3e279efabf854742684341c3e4f50d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3667ada0f76359974e3bdb799ada12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_DIST_MASK_3</b> =3, 
<b>CV_DIST_MASK_5</b> =5, 
<b>CV_DIST_MASK_PRECISE</b> =0
 }</td></tr>
<tr class="separator:ga3d3667ada0f76359974e3bdb799ada12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12627b43234a2c5005eca7a2a0a88cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_DIST_LABEL_CCOMP</b> = 0, 
<b>CV_DIST_LABEL_PIXEL</b> = 1
 }</td></tr>
<tr class="separator:gac12627b43234a2c5005eca7a2a0a88cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4eb8a7f480877e96248c1c2b2b96a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4a85dc4b9e7225ea418574237f0490b2a6">CV_DIST_USER</a> =-1, 
<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4a0b4bea01885957ad908478061c57e67b">CV_DIST_L1</a> =1, 
<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4ae60a48ac6e8738abf6746c4beb4a9962">CV_DIST_L2</a> =2, 
<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4abac689302eb020962e5ef5615de87c07">CV_DIST_C</a> =3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4ae76bff7327eb425bf30cca11e4bc1387">CV_DIST_L12</a> =4, 
<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4abcb84a93465c9ac0e37c0e17d0faae7e">CV_DIST_FAIR</a> =5, 
<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4ac9d04b49e7f44944c936c707650327e4">CV_DIST_WELSCH</a> =6, 
<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4a1725669ada87a92eea265d0346d09513">CV_DIST_HUBER</a> =7
<br />
 }</td></tr>
<tr class="separator:gabe4eb8a7f480877e96248c1c2b2b96a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff73139485369f629981d087e744c90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90a6af8cb4caea50fb9578d4543aa7b6f20">CV_THRESH_BINARY</a> =0, 
<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90a5605ead87cfc7a9a8daa1448f7fba488">CV_THRESH_BINARY_INV</a> =1, 
<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90ab24c5803c81111f2758c91b14dd48cf1">CV_THRESH_TRUNC</a> =2, 
<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90aaab30b5f1f73c2e5b280982f35d7c46d">CV_THRESH_TOZERO</a> =3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90ac166f17f23efb6bcc221e9df92917de5">CV_THRESH_TOZERO_INV</a> =4, 
<b>CV_THRESH_MASK</b> =7, 
<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90a2456934f4f01402e80006a317ea2693e">CV_THRESH_OTSU</a> =8, 
<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90ad963b0512c243be1ec737eadfc4f3cfe">CV_THRESH_TRIANGLE</a> =16
<br />
 }</td></tr>
<tr class="separator:ga5ff73139485369f629981d087e744c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b8f0a0cc23d28aafa1b827c46a5305"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_ADAPTIVE_THRESH_MEAN_C</b> =0, 
<b>CV_ADAPTIVE_THRESH_GAUSSIAN_C</b> =1
 }</td></tr>
<tr class="separator:ga15b8f0a0cc23d28aafa1b827c46a5305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831b5795adf211dfa086182261563b02"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_FLOODFILL_FIXED_RANGE</b> =(1 &lt;&lt; 16), 
<b>CV_FLOODFILL_MASK_ONLY</b> =(1 &lt;&lt; 17)
 }</td></tr>
<tr class="separator:ga831b5795adf211dfa086182261563b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62371d642974c67a0c0efa77d54fcbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_CANNY_L2_GRADIENT</b> =(1 &lt;&lt; 31)
 }</td></tr>
<tr class="separator:gaa62371d642974c67a0c0efa77d54fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f2c6e4d47f62f6b65c5887eb096fd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CV_HOUGH_STANDARD</b> =0, 
<b>CV_HOUGH_PROBABILISTIC</b> =1, 
<b>CV_HOUGH_MULTI_SCALE</b> =2, 
<b>CV_HOUGH_GRADIENT</b> =3
 }</td></tr>
<tr class="separator:ga82f2c6e4d47f62f6b65c5887eb096fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga51a5e3d67c770fdb9275f7e24792f959"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga51a5e3d67c770fdb9275f7e24792f959">CVAPI</a> (void) cvAcc(const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *image</td></tr>
<tr class="memdesc:ga51a5e3d67c770fdb9275f7e24792f959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds image to accumulator.  <a href="#ga51a5e3d67c770fdb9275f7e24792f959">More...</a><br /></td></tr>
<tr class="separator:ga51a5e3d67c770fdb9275f7e24792f959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5c771319668e056ba7f15eca166cff"><td class="memItemLeft" align="right" valign="top"><a id="gaaa5c771319668e056ba7f15eca166cff"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *mask&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (NULL))</td></tr>
<tr class="separator:gaaa5c771319668e056ba7f15eca166cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a5f3a1b094a31da1fbedf1e133ee19"><td class="memItemLeft" align="right" valign="top"><a id="ga65a5f3a1b094a31da1fbedf1e133ee19"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point.html">CvPoint</a> int <a class="el" href="struct_cv_scalar.html">CvScalar</a> value&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (cvScalarAll(0)))</td></tr>
<tr class="separator:ga65a5f3a1b094a31da1fbedf1e133ee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ac5e4dfb73bf4634aa173cee7d283e"><td class="memItemLeft" align="right" valign="top"><a id="gaa7ac5e4dfb73bf4634aa173cee7d283e"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int smoothtype&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (<a class="el" href="group__imgproc__c.html#gga68a3a4144ad5ad650bed7f0ede3611c2a5f9c9d19089c103e1324b65ef51b77b1">CV_GAUSSIAN</a>)</td></tr>
<tr class="separator:gaa7ac5e4dfb73bf4634aa173cee7d283e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155809239e1509f1bec447a60e3aa068"><td class="memItemLeft" align="right" valign="top"><a id="ga155809239e1509f1bec447a60e3aa068"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int smoothtype int size1&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (3)</td></tr>
<tr class="separator:ga155809239e1509f1bec447a60e3aa068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4d98944bd839f7b2ceed4472c46c95"><td class="memItemLeft" align="right" valign="top"><a id="gaaa4d98944bd839f7b2ceed4472c46c95"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int smoothtype int size1 int size2&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (0)</td></tr>
<tr class="separator:gaaa4d98944bd839f7b2ceed4472c46c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5031a7a2f50d598cbf624e8b29281bc2"><td class="memItemLeft" align="right" valign="top"><a id="ga5031a7a2f50d598cbf624e8b29281bc2"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> <a class="el" href="struct_cv_point.html">CvPoint</a> anchor&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (<a class="el" href="group__core__c.html#ga52acfee56f24f5d9c08651861fa675e9">cvPoint</a>(-1,-1)))</td></tr>
<tr class="separator:ga5031a7a2f50d598cbf624e8b29281bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9feffe40872ecf0d3df038be6fb27aa1"><td class="memItemLeft" align="right" valign="top"><a id="ga9feffe40872ecf0d3df038be6fb27aa1"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int filter&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_GAUSSIAN_5x5))</td></tr>
<tr class="separator:ga9feffe40872ecf0d3df038be6fb27aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8fdd9692fb829c1356993a64892de4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gabb8fdd9692fb829c1356993a64892de4">CVAPI</a> (<a class="el" href="struct_cv_mat.html">CvMat</a> **) cvCreatePyramid(const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *img</td></tr>
<tr class="memdesc:gabb8fdd9692fb829c1356993a64892de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds pyramid for an image.  <a href="#gabb8fdd9692fb829c1356993a64892de4">More...</a><br /></td></tr>
<tr class="separator:gabb8fdd9692fb829c1356993a64892de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7ec10e94116791adc0c7c54439d66f"><td class="memItemLeft" align="right" valign="top"><a id="gace7ec10e94116791adc0c7c54439d66f"></a>
int double const <a class="el" href="struct_cv_size.html">CvSize</a> *layer_sizes <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *bufarr int calc&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (1)</td></tr>
<tr class="separator:gace7ec10e94116791adc0c7c54439d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033b3f15b123ba868beafe502af8b042"><td class="memItemLeft" align="right" valign="top"><a id="ga033b3f15b123ba868beafe502af8b042"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double double int max_level <a class="el" href="struct_cv_term_criteria.html">CvTermCriteria</a> termcrit&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 5, 1)))</td></tr>
<tr class="separator:ga033b3f15b123ba868beafe502af8b042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9138ad42a2e40fb60e7740a565d482"><td class="memItemLeft" align="right" valign="top"><a id="ga9f9138ad42a2e40fb60e7740a565d482"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int interpolation&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_INTER_LINEAR))</td></tr>
<tr class="separator:ga9f9138ad42a2e40fb60e7740a565d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db31fae4d42b929829ca9ca3fae785b"><td class="memItemLeft" align="right" valign="top"><a id="ga1db31fae4d42b929829ca9ca3fae785b"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> int flags&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)</td></tr>
<tr class="separator:ga1db31fae4d42b929829ca9ca3fae785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace04cf6f56c0ecd22389ec1ce48353e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gace04cf6f56c0ecd22389ec1ce48353e3">CVAPI</a> (<a class="el" href="struct_cv_mat.html">CvMat</a> *) cvGetAffineTransform(const <a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> *src</td></tr>
<tr class="memdesc:gace04cf6f56c0ecd22389ec1ce48353e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2)  <a href="#gace04cf6f56c0ecd22389ec1ce48353e3">More...</a><br /></td></tr>
<tr class="separator:gace04cf6f56c0ecd22389ec1ce48353e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0442042ffad7f6f7d236c3800f838f82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga0442042ffad7f6f7d236c3800f838f82">CVAPI</a> (<a class="el" href="struct___ipl_conv_kernel.html">IplConvKernel</a> *) cvCreateStructuringElementEx(int cols</td></tr>
<tr class="memdesc:ga0442042ffad7f6f7d236c3800f838f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a structuring element of the specified size and shape for morphological operations.  <a href="#ga0442042ffad7f6f7d236c3800f838f82">More...</a><br /></td></tr>
<tr class="separator:ga0442042ffad7f6f7d236c3800f838f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac287d5e2dafc42c35cd87987c3d927e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gac287d5e2dafc42c35cd87987c3d927e2">CVAPI</a> (double) cvGetSpatialMoment(<a class="el" href="struct_cv_moments.html">CvMoments</a> *moments</td></tr>
<tr class="memdesc:gac287d5e2dafc42c35cd87987c3d927e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve spatial moments.  <a href="#gac287d5e2dafc42c35cd87987c3d927e2">More...</a><br /></td></tr>
<tr class="separator:gac287d5e2dafc42c35cd87987c3d927e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad555d588024aee765c372989bb171070"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gad555d588024aee765c372989bb171070">CVAPI</a> (int) cvSampleLine(const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *image</td></tr>
<tr class="memdesc:gad555d588024aee765c372989bb171070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches pixels that belong to the specified line segment and stores them to the buffer.  <a href="#gad555d588024aee765c372989bb171070">More...</a><br /></td></tr>
<tr class="separator:gad555d588024aee765c372989bb171070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb30b9914eae58898315b4b11d6059e2"><td class="memItemLeft" align="right" valign="top"><a id="gafb30b9914eae58898315b4b11d6059e2"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_point.html">CvPoint</a> void int connectivity&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (8))</td></tr>
<tr class="separator:gafb30b9914eae58898315b4b11d6059e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1da947bf9b837289044138e7d3e987"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gaee1da947bf9b837289044138e7d3e987">CVAPI</a> (float) cvCalcEMD2(const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *signature1</td></tr>
<tr class="memdesc:gaee1da947bf9b837289044138e7d3e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes earth mover distance between two weighted point sets (called signatures)  <a href="#gaee1da947bf9b837289044138e7d3e987">More...</a><br /></td></tr>
<tr class="separator:gaee1da947bf9b837289044138e7d3e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7c775f36b463d2f3461770fb9a7131"><td class="memItemLeft" align="right" valign="top"><a id="gacc7c775f36b463d2f3461770fb9a7131"></a>
<a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> <a class="el" href="struct_cv_seq.html">CvSeq</a> int header_size&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (sizeof(<a class="el" href="struct_cv_contour.html">CvContour</a>))</td></tr>
<tr class="separator:gacc7c775f36b463d2f3461770fb9a7131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2ab7c8923afc103341eea3778f1f99"><td class="memItemLeft" align="right" valign="top"><a id="gacb2ab7c8923afc103341eea3778f1f99"></a>
<a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> <a class="el" href="struct_cv_seq.html">CvSeq</a> int header_size int mode&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_RETR_LIST)</td></tr>
<tr class="separator:gacb2ab7c8923afc103341eea3778f1f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e21509a9ac9df4c3cc1ad855351535"><td class="memItemLeft" align="right" valign="top"><a id="ga89e21509a9ac9df4c3cc1ad855351535"></a>
<a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> <a class="el" href="struct_cv_seq.html">CvSeq</a> int header_size int mode int method&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_CHAIN_APPROX_SIMPLE)</td></tr>
<tr class="separator:ga89e21509a9ac9df4c3cc1ad855351535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a763a40e2455faa17650da84d30413"><td class="memItemLeft" align="right" valign="top"><a id="gae0a763a40e2455faa17650da84d30413"></a>
<a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> <a class="el" href="struct_cv_seq.html">CvSeq</a> int header_size int mode int method <a class="el" href="struct_cv_point.html">CvPoint</a> offset&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (<a class="el" href="group__core__c.html#ga52acfee56f24f5d9c08651861fa675e9">cvPoint</a>(0, 0)))</td></tr>
<tr class="separator:gae0a763a40e2455faa17650da84d30413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d53c44495eec732e4234ff6c5520c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gaa7d53c44495eec732e4234ff6c5520c5">CVAPI</a> (CvContourScanner) cvStartFindContours(<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *image</td></tr>
<tr class="memdesc:gaa7d53c44495eec732e4234ff6c5520c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes contour retrieving process.  <a href="#gaa7d53c44495eec732e4234ff6c5520c5">More...</a><br /></td></tr>
<tr class="separator:gaa7d53c44495eec732e4234ff6c5520c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a507106d740ffc41fffe687f5425a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gaf3a507106d740ffc41fffe687f5425a9">CVAPI</a> (<a class="el" href="struct_cv_seq.html">CvSeq</a> *) cvFindNextContour(CvContourScanner scanner)</td></tr>
<tr class="memdesc:gaf3a507106d740ffc41fffe687f5425a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves next contour.  <a href="#gaf3a507106d740ffc41fffe687f5425a9">More...</a><br /></td></tr>
<tr class="separator:gaf3a507106d740ffc41fffe687f5425a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c416bbc47675aeb7899785b68d40f41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga9c416bbc47675aeb7899785b68d40f41">CVAPI</a> (<a class="el" href="struct_cv_point.html">CvPoint</a>) cvReadChainPoint(<a class="el" href="struct_cv_chain_pt_reader.html">CvChainPtReader</a> *reader)</td></tr>
<tr class="memdesc:ga9c416bbc47675aeb7899785b68d40f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next chain point.  <a href="#ga9c416bbc47675aeb7899785b68d40f41">More...</a><br /></td></tr>
<tr class="separator:ga9c416bbc47675aeb7899785b68d40f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9302fb1df26d7d8ad5951cbc23b3a560"><td class="memItemLeft" align="right" valign="top"><a id="ga9302fb1df26d7d8ad5951cbc23b3a560"></a>
<a class="el" href="struct_cv_slice.html">CvSlice</a> slice&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_WHOLE_SEQ)</td></tr>
<tr class="separator:ga9302fb1df26d7d8ad5951cbc23b3a560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36af53454fe82d453443d42f8d3b1e29"><td class="memItemLeft" align="right" valign="top"><a id="ga36af53454fe82d453443d42f8d3b1e29"></a>
<a class="el" href="struct_cv_slice.html">CvSlice</a> slice int is_closed&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (-1))</td></tr>
<tr class="separator:ga36af53454fe82d453443d42f8d3b1e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1730af55940e59d9c9a51c689e58fdfb"><td class="memItemLeft" align="right" valign="top">CV_INLINE double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga1730af55940e59d9c9a51c689e58fdfb">cvContourPerimeter</a> (const void *contour)</td></tr>
<tr class="separator:ga1730af55940e59d9c9a51c689e58fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b978364ca82684500a76cb94fa4858"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga33b978364ca82684500a76cb94fa4858">CVAPI</a> (<a class="el" href="struct_cv_rect.html">CvRect</a>) cvBoundingRect(<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *points</td></tr>
<tr class="memdesc:ga33b978364ca82684500a76cb94fa4858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates contour bounding rectangle (update=1) or just retrieves pre-calculated rectangle (update=0)  <a href="#ga33b978364ca82684500a76cb94fa4858">More...</a><br /></td></tr>
<tr class="separator:ga33b978364ca82684500a76cb94fa4858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df99dca7ee28666131ae7f179902402"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga8df99dca7ee28666131ae7f179902402">CVAPI</a> (<a class="el" href="struct_cv_box2_d.html">CvBox2D</a>) cvMinAreaRect2(const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *points</td></tr>
<tr class="memdesc:ga8df99dca7ee28666131ae7f179902402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds minimum area rotated rectangle bounding a set of points.  <a href="#ga8df99dca7ee28666131ae7f179902402">More...</a><br /></td></tr>
<tr class="separator:ga8df99dca7ee28666131ae7f179902402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7495bacd7689928ba8b67918cc8d6e24"><td class="memItemLeft" align="right" valign="top"><a id="ga7495bacd7689928ba8b67918cc8d6e24"></a>
void *hull_storage int orientation&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_CLOCKWISE)</td></tr>
<tr class="separator:ga7495bacd7689928ba8b67918cc8d6e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350083876719f90933fb55a534cf8abd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga350083876719f90933fb55a534cf8abd">CVAPI</a> (<a class="el" href="struct_cv_histogram.html">CvHistogram</a> *) cvCreateHist(int dims</td></tr>
<tr class="memdesc:ga350083876719f90933fb55a534cf8abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a histogram.  <a href="#ga350083876719f90933fb55a534cf8abd">More...</a><br /></td></tr>
<tr class="separator:ga350083876719f90933fb55a534cf8abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6074ca64cb8410c90cf045a13a6f5d96"><td class="memItemLeft" align="right" valign="top">CV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga6074ca64cb8410c90cf045a13a6f5d96">cvCalcHist</a> (<a class="el" href="group__core__c.html#ga249298f383f3b430b476542076320c57">IplImage</a> **image, <a class="el" href="struct_cv_histogram.html">CvHistogram</a> *hist, int accumulate CV_DEFAULT(0), const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *mask CV_DEFAULT(NULL))</td></tr>
<tr class="separator:ga6074ca64cb8410c90cf045a13a6f5d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9368f4dfbc4d7a3de1d379ae7aba9aee"><td class="memItemLeft" align="right" valign="top"><a id="ga9368f4dfbc4d7a3de1d379ae7aba9aee"></a>
const <a class="el" href="struct_cv_histogram.html">CvHistogram</a> <a class="el" href="struct_cv_histogram.html">CvHistogram</a> double scale&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (255))</td></tr>
<tr class="separator:ga9368f4dfbc4d7a3de1d379ae7aba9aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598e9535f8c34a02f7937b58dac1856f"><td class="memItemLeft" align="right" valign="top"><a id="ga598e9535f8c34a02f7937b58dac1856f"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int distance_type&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (<a class="el" href="group__imgproc__c.html#ggabe4eb8a7f480877e96248c1c2b2b96a4ae60a48ac6e8738abf6746c4beb4a9962">CV_DIST_L2</a>)</td></tr>
<tr class="separator:ga598e9535f8c34a02f7937b58dac1856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91107c6a8c2808bc55dc1eb1a389f44e"><td class="memItemLeft" align="right" valign="top"><a id="ga91107c6a8c2808bc55dc1eb1a389f44e"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int distance_type int mask_size const float *mask <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *labels int labelType&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_DIST_LABEL_CCOMP))</td></tr>
<tr class="separator:ga91107c6a8c2808bc55dc1eb1a389f44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d3886b053e1a00c63b5682a1cfc5887"><td class="memItemLeft" align="right" valign="top"><a id="ga8d3886b053e1a00c63b5682a1cfc5887"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double int adaptive_method&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_ADAPTIVE_THRESH_MEAN_C)</td></tr>
<tr class="separator:ga8d3886b053e1a00c63b5682a1cfc5887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e1466acff71188bf9af2aaddd1c963"><td class="memItemLeft" align="right" valign="top"><a id="gab7e1466acff71188bf9af2aaddd1c963"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double int adaptive_method int threshold_type&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (<a class="el" href="group__imgproc__c.html#gga5ff73139485369f629981d087e744c90a6af8cb4caea50fb9578d4543aa7b6f20">CV_THRESH_BINARY</a>)</td></tr>
<tr class="separator:gab7e1466acff71188bf9af2aaddd1c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d44f6eed094b68eaf061d98270ffebc"><td class="memItemLeft" align="right" valign="top"><a id="ga7d44f6eed094b68eaf061d98270ffebc"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double int adaptive_method int threshold_type int block_size double param1&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (5))</td></tr>
<tr class="separator:ga7d44f6eed094b68eaf061d98270ffebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e711f93750641af5e339d3085e11945"><td class="memItemLeft" align="right" valign="top"><a id="ga9e711f93750641af5e339d3085e11945"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a> lo_diff <a class="el" href="struct_cv_scalar.html">CvScalar</a> up_diff <a class="el" href="struct_cv_connected_comp.html">CvConnectedComp</a> *comp int flags&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (4)</td></tr>
<tr class="separator:ga9e711f93750641af5e339d3085e11945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91326918d09ef46576409ac7992e68d3"><td class="memItemLeft" align="right" valign="top"><a id="ga91326918d09ef46576409ac7992e68d3"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int int aperture_size double k&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (0.04))</td></tr>
<tr class="separator:ga91326918d09ef46576409ac7992e68d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e8f97ef490a77584029778ab475d2d"><td class="memItemLeft" align="right" valign="top"><a id="ga35e8f97ef490a77584029778ab475d2d"></a>
void int double double int double param1 double param2 double min_theta double max_theta&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (CV_PI))</td></tr>
<tr class="separator:ga35e8f97ef490a77584029778ab475d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27a2ed1924a1f1e986e68d07ea52365"><td class="memItemLeft" align="right" valign="top"><a id="gae27a2ed1924a1f1e986e68d07ea52365"></a>
void int double double double param1&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (100)</td></tr>
<tr class="separator:gae27a2ed1924a1f1e986e68d07ea52365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad870859764211611926d13a0cead740f"><td class="memItemLeft" align="right" valign="top"><a id="gad870859764211611926d13a0cead740f"></a>
CV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>cvEllipseBox</b> (<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *img, <a class="el" href="struct_cv_box2_d.html">CvBox2D</a> box, <a class="el" href="struct_cv_scalar.html">CvScalar</a> color, int thickness CV_DEFAULT(1), int line_type CV_DEFAULT(8), int shift CV_DEFAULT(0))</td></tr>
<tr class="separator:gad870859764211611926d13a0cead740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b7578c82a196024269361c9315834f"><td class="memItemLeft" align="right" valign="top"><a id="ga28b7578c82a196024269361c9315834f"></a>
CV_INLINE <a class="el" href="struct_cv_font.html">CvFont</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cvFont</b> (double scale, int thickness CV_DEFAULT(1))</td></tr>
<tr class="separator:ga28b7578c82a196024269361c9315834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d2831a6803431357d3b9236ba9da7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#ga85d2831a6803431357d3b9236ba9da7e">CVAPI</a> (<a class="el" href="struct_cv_scalar.html">CvScalar</a>) cvColorToScalar(double packed_color</td></tr>
<tr class="memdesc:ga85d2831a6803431357d3b9236ba9da7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks color value.  <a href="#ga85d2831a6803431357d3b9236ba9da7e">More...</a><br /></td></tr>
<tr class="separator:ga85d2831a6803431357d3b9236ba9da7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7af9b91bd155084353325bf9007926e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gae7af9b91bd155084353325bf9007926e">CVAPI</a> (void) cvPOSIT(CvPOSITObject *posit_object</td></tr>
<tr class="memdesc:gae7af9b91bd155084353325bf9007926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates an image header.  <a href="#gae7af9b91bd155084353325bf9007926e">More...</a><br /></td></tr>
<tr class="separator:gae7af9b91bd155084353325bf9007926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f6b6ab285bd56be34dc13f8865c3a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__c.html#gae5f6b6ab285bd56be34dc13f8865c3a6">CVAPI</a> (double) cvCalibrateCamera2(const <a class="el" href="struct_cv_mat.html">CvMat</a> *object_points</td></tr>
<tr class="memdesc:gae5f6b6ab285bd56be34dc13f8865c3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of two arrays in Euclidean metrics.  <a href="#gae5f6b6ab285bd56be34dc13f8865c3a6">More...</a><br /></td></tr>
<tr class="separator:gae5f6b6ab285bd56be34dc13f8865c3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga718e61ac54ab69a36c063fac0e4d9034"><td class="memItemLeft" align="right" valign="top"><a id="ga718e61ac54ab69a36c063fac0e4d9034"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b></td></tr>
<tr class="separator:ga718e61ac54ab69a36c063fac0e4d9034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27caca711ca5fa4c336f5c83e73ee77"><td class="memItemLeft" align="right" valign="top"><a id="gae27caca711ca5fa4c336f5c83e73ee77"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sqsum</b></td></tr>
<tr class="separator:gae27caca711ca5fa4c336f5c83e73ee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e3ae1b0675509698e45b95135c1aed"><td class="memItemLeft" align="right" valign="top"><a id="ga76e3ae1b0675509698e45b95135c1aed"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>image2</b></td></tr>
<tr class="separator:ga76e3ae1b0675509698e45b95135c1aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6f81ac0e7e4cfb545c6acf7cb8c8c6"><td class="memItemLeft" align="right" valign="top"><a id="ga3d6f81ac0e7e4cfb545c6acf7cb8c8c6"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>acc</b></td></tr>
<tr class="separator:ga3d6f81ac0e7e4cfb545c6acf7cb8c8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75620528cfc7d5f1288004fa760804ee"><td class="memItemLeft" align="right" valign="top"><a id="ga75620528cfc7d5f1288004fa760804ee"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>alpha</b></td></tr>
<tr class="separator:ga75620528cfc7d5f1288004fa760804ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2b96e41a49dc4d072b2a0707f56596"><td class="memItemLeft" align="right" valign="top"><a id="gaaf2b96e41a49dc4d072b2a0707f56596"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dst</b></td></tr>
<tr class="separator:gaaf2b96e41a49dc4d072b2a0707f56596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecaf8d39ccebc1daaa89ee5f071a9090"><td class="memItemLeft" align="right" valign="top"><a id="gaecaf8d39ccebc1daaa89ee5f071a9090"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>offset</b></td></tr>
<tr class="separator:gaecaf8d39ccebc1daaa89ee5f071a9090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217d51a46c1bcfec1157d02663e6e499"><td class="memItemLeft" align="right" valign="top"><a id="ga217d51a46c1bcfec1157d02663e6e499"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point.html">CvPoint</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>bordertype</b></td></tr>
<tr class="separator:ga217d51a46c1bcfec1157d02663e6e499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863a75780ba6c5de552f5361cb0d2c89"><td class="memItemLeft" align="right" valign="top"><a id="ga863a75780ba6c5de552f5361cb0d2c89"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>kernel</b></td></tr>
<tr class="separator:ga863a75780ba6c5de552f5361cb0d2c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8623df17157c2a7156fb9c28ef382e1"><td class="memItemLeft" align="right" valign="top"><a id="gaf8623df17157c2a7156fb9c28ef382e1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_layers</b></td></tr>
<tr class="separator:gaf8623df17157c2a7156fb9c28ef382e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cede51fff3afeea0dbae57b71f59f3d"><td class="memItemLeft" align="right" valign="top"><a id="ga3cede51fff3afeea0dbae57b71f59f3d"></a>
int double&#160;</td><td class="memItemRight" valign="bottom"><b>rate</b></td></tr>
<tr class="separator:ga3cede51fff3afeea0dbae57b71f59f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14bc2e984efdff6b1fa7e106f3ac14a"><td class="memItemLeft" align="right" valign="top"><a id="gac14bc2e984efdff6b1fa7e106f3ac14a"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>sp</b></td></tr>
<tr class="separator:gac14bc2e984efdff6b1fa7e106f3ac14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacecaf9a0f96f944ff768b10358b45839"><td class="memItemLeft" align="right" valign="top"><a id="gacecaf9a0f96f944ff768b10358b45839"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double double&#160;</td><td class="memItemRight" valign="bottom"><b>sr</b></td></tr>
<tr class="separator:gacecaf9a0f96f944ff768b10358b45839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef275836228f2bc63122df9ce1fe363"><td class="memItemLeft" align="right" valign="top"><a id="ga2ef275836228f2bc63122df9ce1fe363"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>markers</b></td></tr>
<tr class="separator:ga2ef275836228f2bc63122df9ce1fe363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152326eb8ab5341b9bd064a595c12bcf"><td class="memItemLeft" align="right" valign="top"><a id="ga152326eb8ab5341b9bd064a595c12bcf"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>xorder</b></td></tr>
<tr class="separator:ga152326eb8ab5341b9bd064a595c12bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf808592e0e098f664fa9a775050020c5"><td class="memItemLeft" align="right" valign="top"><a id="gaf808592e0e098f664fa9a775050020c5"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int int&#160;</td><td class="memItemRight" valign="bottom"><b>yorder</b></td></tr>
<tr class="separator:gaf808592e0e098f664fa9a775050020c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9fd13fa1f888f8baeda154bb1a3691"><td class="memItemLeft" align="right" valign="top"><a id="ga9a9fd13fa1f888f8baeda154bb1a3691"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>code</b></td></tr>
<tr class="separator:ga9a9fd13fa1f888f8baeda154bb1a3691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga008b162e48582f87c99e01ed983379a4"><td class="memItemLeft" align="right" valign="top"><a id="ga008b162e48582f87c99e01ed983379a4"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>map_matrix</b></td></tr>
<tr class="separator:ga008b162e48582f87c99e01ed983379a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00147158cd32c0f762ad7d5917e6d8fd"><td class="memItemLeft" align="right" valign="top"><a id="ga00147158cd32c0f762ad7d5917e6d8fd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>angle</b></td></tr>
<tr class="separator:ga00147158cd32c0f762ad7d5917e6d8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf08b297b807a1b8810a4bbaa70ca3d99"><td class="memItemLeft" align="right" valign="top"><a id="gaf08b297b807a1b8810a4bbaa70ca3d99"></a>
double double&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b></td></tr>
<tr class="separator:gaf08b297b807a1b8810a4bbaa70ca3d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ed33f30ee89704887ae4e4dbb20d46"><td class="memItemLeft" align="right" valign="top"><a id="ga81ed33f30ee89704887ae4e4dbb20d46"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mapx</b></td></tr>
<tr class="separator:ga81ed33f30ee89704887ae4e4dbb20d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga934abd37467ed645178fbe201add061e"><td class="memItemLeft" align="right" valign="top"><a id="ga934abd37467ed645178fbe201add061e"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mapy</b></td></tr>
<tr class="separator:ga934abd37467ed645178fbe201add061e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90714ebeccca789e3abac84458ebbf71"><td class="memItemLeft" align="right" valign="top"><a id="ga90714ebeccca789e3abac84458ebbf71"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mapxy</b></td></tr>
<tr class="separator:ga90714ebeccca789e3abac84458ebbf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d3e578079a6f5d58c01fc2dd9298431"><td class="memItemLeft" align="right" valign="top"><a id="ga8d3e578079a6f5d58c01fc2dd9298431"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mapalpha</b></td></tr>
<tr class="separator:ga8d3e578079a6f5d58c01fc2dd9298431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74d5c2b1b8e008e97876b334e343b30"><td class="memItemLeft" align="right" valign="top"><a id="gac74d5c2b1b8e008e97876b334e343b30"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a>&#160;</td><td class="memItemRight" valign="bottom"><b>center</b></td></tr>
<tr class="separator:gac74d5c2b1b8e008e97876b334e343b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404a4d60c53041fc1a1cd804d1c07cbb"><td class="memItemLeft" align="right" valign="top"><a id="ga404a4d60c53041fc1a1cd804d1c07cbb"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>M</b></td></tr>
<tr class="separator:ga404a4d60c53041fc1a1cd804d1c07cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa127cf4ed721c001f0dd39efd29b9790"><td class="memItemLeft" align="right" valign="top"><a id="gaa127cf4ed721c001f0dd39efd29b9790"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>maxRadius</b></td></tr>
<tr class="separator:gaa127cf4ed721c001f0dd39efd29b9790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58a1e2076a587fcc1f9a33eb175b51e"><td class="memItemLeft" align="right" valign="top"><a id="gad58a1e2076a587fcc1f9a33eb175b51e"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>camera_matrix</b></td></tr>
<tr class="separator:gad58a1e2076a587fcc1f9a33eb175b51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f778a76ec97614752f79f89dc5bb131"><td class="memItemLeft" align="right" valign="top"><a id="ga1f778a76ec97614752f79f89dc5bb131"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>distortion_coeffs</b></td></tr>
<tr class="separator:ga1f778a76ec97614752f79f89dc5bb131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c756a9cb6c3bd1183d167795c18eae"><td class="memItemLeft" align="right" valign="top"><a id="ga80c756a9cb6c3bd1183d167795c18eae"></a>
const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dist_coeffs</b></td></tr>
<tr class="separator:ga80c756a9cb6c3bd1183d167795c18eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51837f120208319f026dc8c4a71e56e0"><td class="memItemLeft" align="right" valign="top"><a id="ga51837f120208319f026dc8c4a71e56e0"></a>
const <a class="el" href="struct_cv_mat.html">CvMat</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>R</b></td></tr>
<tr class="separator:ga51837f120208319f026dc8c4a71e56e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b624d322c0af50677dde52c24a8e208"><td class="memItemLeft" align="right" valign="top"><a id="ga3b624d322c0af50677dde52c24a8e208"></a>
const <a class="el" href="struct_cv_mat.html">CvMat</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>new_camera_matrix</b></td></tr>
<tr class="separator:ga3b624d322c0af50677dde52c24a8e208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061459acc9e078fa4699e0e349887215"><td class="memItemLeft" align="right" valign="top"><a id="ga061459acc9e078fa4699e0e349887215"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b></td></tr>
<tr class="separator:ga061459acc9e078fa4699e0e349887215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b134fdedcf1992f116e51586aab83b"><td class="memItemLeft" align="right" valign="top"><a id="ga09b134fdedcf1992f116e51586aab83b"></a>
int int&#160;</td><td class="memItemRight" valign="bottom"><b>anchor_x</b></td></tr>
<tr class="separator:ga09b134fdedcf1992f116e51586aab83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3c9ff8f5f922e98e589a1644b97f89"><td class="memItemLeft" align="right" valign="top"><a id="ga6d3c9ff8f5f922e98e589a1644b97f89"></a>
int int int&#160;</td><td class="memItemRight" valign="bottom"><b>anchor_y</b></td></tr>
<tr class="separator:ga6d3c9ff8f5f922e98e589a1644b97f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9441d55ee8217146ade7775f35b642c3"><td class="memItemLeft" align="right" valign="top"><a id="ga9441d55ee8217146ade7775f35b642c3"></a>
int int int int&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b></td></tr>
<tr class="separator:ga9441d55ee8217146ade7775f35b642c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe009251fa48e9266e8b38c63b7b8003"><td class="memItemLeft" align="right" valign="top"><a id="gafe009251fa48e9266e8b38c63b7b8003"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>temp</b></td></tr>
<tr class="separator:gafe009251fa48e9266e8b38c63b7b8003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d478f3138e9216027607723d7dc945a"><td class="memItemLeft" align="right" valign="top"><a id="ga2d478f3138e9216027607723d7dc945a"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct___ipl_conv_kernel.html">IplConvKernel</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>element</b></td></tr>
<tr class="separator:ga2d478f3138e9216027607723d7dc945a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bb091587abe659f1f154fd5f7bd664"><td class="memItemLeft" align="right" valign="top"><a id="gaf8bb091587abe659f1f154fd5f7bd664"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct___ipl_conv_kernel.html">IplConvKernel</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>operation</b></td></tr>
<tr class="separator:gaf8bb091587abe659f1f154fd5f7bd664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155fbcf844810c2eb333c91505eb9169"><td class="memItemLeft" align="right" valign="top"><a id="ga155fbcf844810c2eb333c91505eb9169"></a>
<a class="el" href="struct_cv_moments.html">CvMoments</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>moments</b></td></tr>
<tr class="separator:ga155fbcf844810c2eb333c91505eb9169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7cc62fb5dda4a1e48f61426d6a0be0"><td class="memItemLeft" align="right" valign="top"><a id="ga6a7cc62fb5dda4a1e48f61426d6a0be0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>x_order</b></td></tr>
<tr class="separator:ga6a7cc62fb5dda4a1e48f61426d6a0be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d9a765d7b2fad6bbd96b4bdaa26006d"><td class="memItemLeft" align="right" valign="top"><a id="ga8d9a765d7b2fad6bbd96b4bdaa26006d"></a>
int int&#160;</td><td class="memItemRight" valign="bottom"><b>y_order</b></td></tr>
<tr class="separator:ga8d9a765d7b2fad6bbd96b4bdaa26006d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f88a9a8dd191a1b4c3131acd130dec0"><td class="memItemLeft" align="right" valign="top"><a id="ga3f88a9a8dd191a1b4c3131acd130dec0"></a>
<a class="el" href="struct_cv_hu_moments.html">CvHuMoments</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>hu_moments</b></td></tr>
<tr class="separator:ga3f88a9a8dd191a1b4c3131acd130dec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d93852899c445e76457745010aa0a5a"><td class="memItemLeft" align="right" valign="top"><a id="ga3d93852899c445e76457745010aa0a5a"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pt1</b></td></tr>
<tr class="separator:ga3d93852899c445e76457745010aa0a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902850a9e0c91c1564bccebb6d1759dd"><td class="memItemLeft" align="right" valign="top"><a id="ga902850a9e0c91c1564bccebb6d1759dd"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pt2</b></td></tr>
<tr class="separator:ga902850a9e0c91c1564bccebb6d1759dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9db6ccf8d1a2abfd9a0a162547f9666"><td class="memItemLeft" align="right" valign="top"><a id="gac9db6ccf8d1a2abfd9a0a162547f9666"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_point.html">CvPoint</a> void *&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr class="separator:gac9db6ccf8d1a2abfd9a0a162547f9666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dda0ce9b269462404396ce3e9eedf00"><td class="memItemLeft" align="right" valign="top"><a id="ga3dda0ce9b269462404396ce3e9eedf00"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>templ</b></td></tr>
<tr class="separator:ga3dda0ce9b269462404396ce3e9eedf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d55b7cb8d50997fe33def0b3b76eac"><td class="memItemLeft" align="right" valign="top"><a id="ga40d55b7cb8d50997fe33def0b3b76eac"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>result</b></td></tr>
<tr class="separator:ga40d55b7cb8d50997fe33def0b3b76eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b9819cc20b34aa0ae2bfa4486e7a65"><td class="memItemLeft" align="right" valign="top"><a id="gab9b9819cc20b34aa0ae2bfa4486e7a65"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>method</b></td></tr>
<tr class="separator:gab9b9819cc20b34aa0ae2bfa4486e7a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930c0d1061f9be0d2ff2cecaed2dbf71"><td class="memItemLeft" align="right" valign="top"><a id="ga930c0d1061f9be0d2ff2cecaed2dbf71"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>signature2</b></td></tr>
<tr class="separator:ga930c0d1061f9be0d2ff2cecaed2dbf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84226f42f87fdc01462ad7a7eac3d487"><td class="memItemLeft" align="right" valign="top"><a id="ga84226f42f87fdc01462ad7a7eac3d487"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>distance_type</b></td></tr>
<tr class="separator:ga84226f42f87fdc01462ad7a7eac3d487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be8b1b966b726e0e6975f5a230084cb"><td class="memItemLeft" align="right" valign="top"><a id="ga4be8b1b966b726e0e6975f5a230084cb"></a>
<a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b></td></tr>
<tr class="separator:ga4be8b1b966b726e0e6975f5a230084cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2db73f45f0621ff974aefe645ab4c62"><td class="memItemLeft" align="right" valign="top"><a id="gaa2db73f45f0621ff974aefe645ab4c62"></a>
<a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> <a class="el" href="struct_cv_seq.html">CvSeq</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>first_contour</b></td></tr>
<tr class="separator:gaa2db73f45f0621ff974aefe645ab4c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20e144084dc96197dce2629ce89bb0c"><td class="memItemLeft" align="right" valign="top"><a id="gad20e144084dc96197dce2629ce89bb0c"></a>
<a class="el" href="struct_cv_seq.html">CvSeq</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>new_contour</b></td></tr>
<tr class="separator:gad20e144084dc96197dce2629ce89bb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbcad7e2fb0c0adb2492c861d2cc2684"><td class="memItemLeft" align="right" valign="top"><a id="gafbcad7e2fb0c0adb2492c861d2cc2684"></a>
<a class="el" href="struct_cv_chain_pt_reader.html">CvChainPtReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>reader</b></td></tr>
<tr class="separator:gafbcad7e2fb0c0adb2492c861d2cc2684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5c1b1bef3aaad5af98436c73397964"><td class="memItemLeft" align="right" valign="top"><a id="ga4e5c1b1bef3aaad5af98436c73397964"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>header_size</b></td></tr>
<tr class="separator:ga4e5c1b1bef3aaad5af98436c73397964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabece9d4af1ab09d2f85ade473757e32"><td class="memItemLeft" align="right" valign="top"><a id="gaabece9d4af1ab09d2f85ade473757e32"></a>
int <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> int double&#160;</td><td class="memItemRight" valign="bottom"><b>eps</b></td></tr>
<tr class="separator:gaabece9d4af1ab09d2f85ade473757e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bea932e1cd0c79d103a7870a1921a4e"><td class="memItemLeft" align="right" valign="top"><a id="ga7bea932e1cd0c79d103a7870a1921a4e"></a>
<a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> float *&#160;</td><td class="memItemRight" valign="bottom"><b>radius</b></td></tr>
<tr class="separator:ga7bea932e1cd0c79d103a7870a1921a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa904589fe53b9d0855be70217c674503"><td class="memItemLeft" align="right" valign="top"><a id="gaa904589fe53b9d0855be70217c674503"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>object2</b></td></tr>
<tr class="separator:gaa904589fe53b9d0855be70217c674503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7249c6f0ee7ae47703937ade4484e71"><td class="memItemLeft" align="right" valign="top"><a id="gaf7249c6f0ee7ae47703937ade4484e71"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>convexhull</b></td></tr>
<tr class="separator:gaf7249c6f0ee7ae47703937ade4484e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c62ff9aa0c6549a8a350d65d604a644"><td class="memItemLeft" align="right" valign="top"><a id="ga0c62ff9aa0c6549a8a350d65d604a644"></a>
const <a class="el" href="struct_cv_rect.html">CvRect</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rect2</b></td></tr>
<tr class="separator:ga0c62ff9aa0c6549a8a350d65d604a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350b3a83768fbff7ceba7d1be6fe3475"><td class="memItemLeft" align="right" valign="top"><a id="ga350b3a83768fbff7ceba7d1be6fe3475"></a>
<a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pt</b> [4]</td></tr>
<tr class="separator:ga350b3a83768fbff7ceba7d1be6fe3475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9325e85114e7b9ab738a23b62ea10a0"><td class="memItemLeft" align="right" valign="top"><a id="gad9325e85114e7b9ab738a23b62ea10a0"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mat</b></td></tr>
<tr class="separator:gad9325e85114e7b9ab738a23b62ea10a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bacd7838f19522529fd9dc7542e4404"><td class="memItemLeft" align="right" valign="top"><a id="ga9bacd7838f19522529fd9dc7542e4404"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_contour.html">CvContour</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>contour_header</b></td></tr>
<tr class="separator:ga9bacd7838f19522529fd9dc7542e4404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9dfec626c83c539c0de3610e4645c32"><td class="memItemLeft" align="right" valign="top"><a id="gae9dfec626c83c539c0de3610e4645c32"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_contour.html">CvContour</a> <a class="el" href="struct_cv_seq_block.html">CvSeqBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>block</b></td></tr>
<tr class="separator:gae9dfec626c83c539c0de3610e4645c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e2f615530d8f509c159263ce5f8ee1d"><td class="memItemLeft" align="right" valign="top"><a id="ga3e2f615530d8f509c159263ce5f8ee1d"></a>
<a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>measure_dist</b></td></tr>
<tr class="separator:ga3e2f615530d8f509c159263ce5f8ee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc291f06aa904173ea1ada4741707f6"><td class="memItemLeft" align="right" valign="top"><a id="gafcc291f06aa904173ea1ada4741707f6"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>sizes</b></td></tr>
<tr class="separator:gafcc291f06aa904173ea1ada4741707f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84612d8738bf935200cf32a103d8efe1"><td class="memItemLeft" align="right" valign="top"><a id="ga84612d8738bf935200cf32a103d8efe1"></a>
int int&#160;</td><td class="memItemRight" valign="bottom"><b>type</b></td></tr>
<tr class="separator:ga84612d8738bf935200cf32a103d8efe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60fbc54af325f6db106ca96909a8fc0"><td class="memItemLeft" align="right" valign="top"><a id="gab60fbc54af325f6db106ca96909a8fc0"></a>
float **&#160;</td><td class="memItemRight" valign="bottom"><b>ranges</b></td></tr>
<tr class="separator:gab60fbc54af325f6db106ca96909a8fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0663c690702cf27bead756ca1afba84"><td class="memItemLeft" align="right" valign="top"><a id="gab0663c690702cf27bead756ca1afba84"></a>
int <a class="el" href="struct_cv_histogram.html">CvHistogram</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>hist</b></td></tr>
<tr class="separator:gab0663c690702cf27bead756ca1afba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3dc842ea71c5382d30510405b364b5"><td class="memItemLeft" align="right" valign="top"><a id="ga9c3dc842ea71c5382d30510405b364b5"></a>
int <a class="el" href="struct_cv_histogram.html">CvHistogram</a> float *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:ga9c3dc842ea71c5382d30510405b364b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7647afad3251f8f10fec3f5a86ab62f1"><td class="memItemLeft" align="right" valign="top"><a id="ga7647afad3251f8f10fec3f5a86ab62f1"></a>
float *&#160;</td><td class="memItemRight" valign="bottom"><b>min_value</b></td></tr>
<tr class="separator:ga7647afad3251f8f10fec3f5a86ab62f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6b92660b0500936c7ec2c2cabbf936"><td class="memItemLeft" align="right" valign="top"><a id="ga0d6b92660b0500936c7ec2c2cabbf936"></a>
float float *&#160;</td><td class="memItemRight" valign="bottom"><b>max_value</b></td></tr>
<tr class="separator:ga0d6b92660b0500936c7ec2c2cabbf936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d935d2d81b1aaccebdf6badbf59ba0"><td class="memItemLeft" align="right" valign="top"><a id="ga38d935d2d81b1aaccebdf6badbf59ba0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>factor</b></td></tr>
<tr class="separator:ga38d935d2d81b1aaccebdf6badbf59ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b004637d3b8895570fd73c28492698"><td class="memItemLeft" align="right" valign="top"><a id="ga32b004637d3b8895570fd73c28492698"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>threshold</b></td></tr>
<tr class="separator:ga32b004637d3b8895570fd73c28492698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4bc2102c97b6b98fe35d6be2f7b768"><td class="memItemLeft" align="right" valign="top"><a id="gadd4bc2102c97b6b98fe35d6be2f7b768"></a>
const <a class="el" href="struct_cv_histogram.html">CvHistogram</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>hist2</b></td></tr>
<tr class="separator:gadd4bc2102c97b6b98fe35d6be2f7b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7106e2abc437ad981830d14176d15f09"><td class="memItemLeft" align="right" valign="top"><a id="ga7106e2abc437ad981830d14176d15f09"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>number</b></td></tr>
<tr class="separator:ga7106e2abc437ad981830d14176d15f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e12f6e5472cdb21ec13ab5365ffd987"><td class="memItemLeft" align="right" valign="top"><a id="ga7e12f6e5472cdb21ec13ab5365ffd987"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_size.html">CvSize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>range</b></td></tr>
<tr class="separator:ga7e12f6e5472cdb21ec13ab5365ffd987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadafca33a5b5031b92bb5fc441ac693d2"><td class="memItemLeft" align="right" valign="top"><a id="gadafca33a5b5031b92bb5fc441ac693d2"></a>
const <a class="el" href="struct_cv_histogram.html">CvHistogram</a> <a class="el" href="struct_cv_histogram.html">CvHistogram</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dst_hist</b></td></tr>
<tr class="separator:gadafca33a5b5031b92bb5fc441ac693d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a36f5d9d7b616c2830e6fdca3e336c6"><td class="memItemLeft" align="right" valign="top"><a id="ga1a36f5d9d7b616c2830e6fdca3e336c6"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double double int&#160;</td><td class="memItemRight" valign="bottom"><b>threshold_type</b></td></tr>
<tr class="separator:ga1a36f5d9d7b616c2830e6fdca3e336c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427cc9320072202b2b4e883f9e80f9f4"><td class="memItemLeft" align="right" valign="top"><a id="ga427cc9320072202b2b4e883f9e80f9f4"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>seed_point</b></td></tr>
<tr class="separator:ga427cc9320072202b2b4e883f9e80f9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07e81df88d801bfa6a232eaab4fc8b85"><td class="memItemLeft" align="right" valign="top"><a id="ga07e81df88d801bfa6a232eaab4fc8b85"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>new_val</b></td></tr>
<tr class="separator:ga07e81df88d801bfa6a232eaab4fc8b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0934986249e7ba69309a154af3260f89"><td class="memItemLeft" align="right" valign="top"><a id="ga0934986249e7ba69309a154af3260f89"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>edges</b></td></tr>
<tr class="separator:ga0934986249e7ba69309a154af3260f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3624a49ef9de4b4c14537d162ac49d26"><td class="memItemLeft" align="right" valign="top"><a id="ga3624a49ef9de4b4c14537d162ac49d26"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>threshold1</b></td></tr>
<tr class="separator:ga3624a49ef9de4b4c14537d162ac49d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f1cfe5469d77d47449d73966d484b84"><td class="memItemLeft" align="right" valign="top"><a id="ga9f1cfe5469d77d47449d73966d484b84"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double double&#160;</td><td class="memItemRight" valign="bottom"><b>threshold2</b></td></tr>
<tr class="separator:ga9f1cfe5469d77d47449d73966d484b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223e965e192c7025d6c6be77305f515b"><td class="memItemLeft" align="right" valign="top"><a id="ga223e965e192c7025d6c6be77305f515b"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>corners</b></td></tr>
<tr class="separator:ga223e965e192c7025d6c6be77305f515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59dd32a490ca2fad6a4a46af67e17e8"><td class="memItemLeft" align="right" valign="top"><a id="gae59dd32a490ca2fad6a4a46af67e17e8"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>eigenvv</b></td></tr>
<tr class="separator:gae59dd32a490ca2fad6a4a46af67e17e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7c85a0cd4aeceb7043475ac38fe836"><td class="memItemLeft" align="right" valign="top"><a id="ga2d7c85a0cd4aeceb7043475ac38fe836"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>block_size</b></td></tr>
<tr class="separator:ga2d7c85a0cd4aeceb7043475ac38fe836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35106468055b5473fa419a56f28465eb"><td class="memItemLeft" align="right" valign="top"><a id="ga35106468055b5473fa419a56f28465eb"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>eigenval</b></td></tr>
<tr class="separator:ga35106468055b5473fa419a56f28465eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85aced528e9c1063bfd49846d5f1af76"><td class="memItemLeft" align="right" valign="top"><a id="ga85aced528e9c1063bfd49846d5f1af76"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>harris_response</b></td></tr>
<tr class="separator:ga85aced528e9c1063bfd49846d5f1af76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc2704a5a1dd88fdd8c6d76754645f0"><td class="memItemLeft" align="right" valign="top"><a id="ga3fc2704a5a1dd88fdd8c6d76754645f0"></a>
<a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>count</b></td></tr>
<tr class="separator:ga3fc2704a5a1dd88fdd8c6d76754645f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d2e5a438a6bb322126274298e0023a"><td class="memItemLeft" align="right" valign="top"><a id="ga31d2e5a438a6bb322126274298e0023a"></a>
<a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int <a class="el" href="struct_cv_size.html">CvSize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>win</b></td></tr>
<tr class="separator:ga31d2e5a438a6bb322126274298e0023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1071bc733058b1f1af8dec75ab93adf"><td class="memItemLeft" align="right" valign="top"><a id="gaf1071bc733058b1f1af8dec75ab93adf"></a>
<a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int <a class="el" href="struct_cv_size.html">CvSize</a> <a class="el" href="struct_cv_size.html">CvSize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>zero_zone</b></td></tr>
<tr class="separator:gaf1071bc733058b1f1af8dec75ab93adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac808aaac88b1d5574652acbfb70cdaf4"><td class="memItemLeft" align="right" valign="top"><a id="gac808aaac88b1d5574652acbfb70cdaf4"></a>
<a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int <a class="el" href="struct_cv_size.html">CvSize</a> <a class="el" href="struct_cv_size.html">CvSize</a> <a class="el" href="struct_cv_term_criteria.html">CvTermCriteria</a>&#160;</td><td class="memItemRight" valign="bottom"><b>criteria</b></td></tr>
<tr class="separator:gac808aaac88b1d5574652acbfb70cdaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1a9b65c22503df6c55c44af83aad1b"><td class="memItemLeft" align="right" valign="top"><a id="ga7e1a9b65c22503df6c55c44af83aad1b"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>eig_image</b></td></tr>
<tr class="separator:ga7e1a9b65c22503df6c55c44af83aad1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac205173ec158badc3390b963eeb87c9a"><td class="memItemLeft" align="right" valign="top"><a id="gac205173ec158badc3390b963eeb87c9a"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>temp_image</b></td></tr>
<tr class="separator:gac205173ec158badc3390b963eeb87c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c82033b6451ac1c5ca8c80855f783b"><td class="memItemLeft" align="right" valign="top"><a id="gaf4c82033b6451ac1c5ca8c80855f783b"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int *&#160;</td><td class="memItemRight" valign="bottom"><b>corner_count</b></td></tr>
<tr class="separator:gaf4c82033b6451ac1c5ca8c80855f783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d2a3c6f6473a32a7a4d6df5bc38c57d"><td class="memItemLeft" align="right" valign="top"><a id="ga8d2a3c6f6473a32a7a4d6df5bc38c57d"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int double&#160;</td><td class="memItemRight" valign="bottom"><b>quality_level</b></td></tr>
<tr class="separator:ga8d2a3c6f6473a32a7a4d6df5bc38c57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e46a052bd7949031bdb066097390a7f"><td class="memItemLeft" align="right" valign="top"><a id="ga6e46a052bd7949031bdb066097390a7f"></a>
<a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> <a class="el" href="struct_cv_point2_d32f.html">CvPoint2D32f</a> int double double&#160;</td><td class="memItemRight" valign="bottom"><b>min_distance</b></td></tr>
<tr class="separator:ga6e46a052bd7949031bdb066097390a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3fef5dde04c4a918865d7163981ab10"><td class="memItemLeft" align="right" valign="top"><a id="gaa3fef5dde04c4a918865d7163981ab10"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>line_storage</b></td></tr>
<tr class="separator:gaa3fef5dde04c4a918865d7163981ab10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8783b6b909806d38134f1f342005bf"><td class="memItemLeft" align="right" valign="top"><a id="ga7d8783b6b909806d38134f1f342005bf"></a>
void int double&#160;</td><td class="memItemRight" valign="bottom"><b>rho</b></td></tr>
<tr class="separator:ga7d8783b6b909806d38134f1f342005bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ba48f41646a904a861746079d43f17"><td class="memItemLeft" align="right" valign="top"><a id="ga90ba48f41646a904a861746079d43f17"></a>
void int double double&#160;</td><td class="memItemRight" valign="bottom"><b>theta</b></td></tr>
<tr class="separator:ga90ba48f41646a904a861746079d43f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619215aef78fa210e6c249343ad6f5eb"><td class="memItemLeft" align="right" valign="top"><a id="ga619215aef78fa210e6c249343ad6f5eb"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>circle_storage</b></td></tr>
<tr class="separator:ga619215aef78fa210e6c249343ad6f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72596cdef510cb9cb1a2b07a9189912"><td class="memItemLeft" align="right" valign="top"><a id="gab72596cdef510cb9cb1a2b07a9189912"></a>
void int double&#160;</td><td class="memItemRight" valign="bottom"><b>dp</b></td></tr>
<tr class="separator:gab72596cdef510cb9cb1a2b07a9189912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf282458d33df07746d614fc2e83fb915"><td class="memItemLeft" align="right" valign="top"><a id="gaf282458d33df07746d614fc2e83fb915"></a>
void int double double&#160;</td><td class="memItemRight" valign="bottom"><b>min_dist</b></td></tr>
<tr class="separator:gaf282458d33df07746d614fc2e83fb915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c138ad421cb7c04c0e7712cc888c3b"><td class="memItemLeft" align="right" valign="top"><a id="gac4c138ad421cb7c04c0e7712cc888c3b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dist_type</b></td></tr>
<tr class="separator:gac4c138ad421cb7c04c0e7712cc888c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa568d70073af643d128aec36edc11bd"><td class="memItemLeft" align="right" valign="top"><a id="gaaa568d70073af643d128aec36edc11bd"></a>
int double&#160;</td><td class="memItemRight" valign="bottom"><b>param</b></td></tr>
<tr class="separator:gaaa568d70073af643d128aec36edc11bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d019f60ad3622468bbdd106d76618e"><td class="memItemLeft" align="right" valign="top"><a id="ga48d019f60ad3622468bbdd106d76618e"></a>
int double double&#160;</td><td class="memItemRight" valign="bottom"><b>reps</b></td></tr>
<tr class="separator:ga48d019f60ad3622468bbdd106d76618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c99d614f6f66c437e8cb01d1e2fe1a"><td class="memItemLeft" align="right" valign="top"><a id="ga54c99d614f6f66c437e8cb01d1e2fe1a"></a>
int double double double&#160;</td><td class="memItemRight" valign="bottom"><b>aeps</b></td></tr>
<tr class="separator:ga54c99d614f6f66c437e8cb01d1e2fe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7146038506976205c451bf9d62f663b4"><td class="memItemLeft" align="right" valign="top"><a id="ga7146038506976205c451bf9d62f663b4"></a>
int double double double float *&#160;</td><td class="memItemRight" valign="bottom"><b>line</b></td></tr>
<tr class="separator:ga7146038506976205c451bf9d62f663b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea898fa4dd23d613d19923509d8e249"><td class="memItemLeft" align="right" valign="top"><a id="ga4ea898fa4dd23d613d19923509d8e249"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>color</b></td></tr>
<tr class="separator:ga4ea898fa4dd23d613d19923509d8e249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54709f3b06b33b66763f1613cc7fb571"><td class="memItemLeft" align="right" valign="top"><a id="ga54709f3b06b33b66763f1613cc7fb571"></a>
<a class="el" href="struct_cv_rect.html">CvRect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>r</b></td></tr>
<tr class="separator:ga54709f3b06b33b66763f1613cc7fb571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9447463cf154fcf48fd979790bf647d6"><td class="memItemLeft" align="right" valign="top"><a id="ga9447463cf154fcf48fd979790bf647d6"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_size.html">CvSize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>axes</b></td></tr>
<tr class="separator:ga9447463cf154fcf48fd979790bf647d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae46c356ae5eae88e86de0945ecce535"><td class="memItemLeft" align="right" valign="top"><a id="gaae46c356ae5eae88e86de0945ecce535"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_size.html">CvSize</a> double double&#160;</td><td class="memItemRight" valign="bottom"><b>start_angle</b></td></tr>
<tr class="separator:gaae46c356ae5eae88e86de0945ecce535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22642cd5bba446dbb60f72130849f91"><td class="memItemLeft" align="right" valign="top"><a id="gab22642cd5bba446dbb60f72130849f91"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_size.html">CvSize</a> double double double&#160;</td><td class="memItemRight" valign="bottom"><b>end_angle</b></td></tr>
<tr class="separator:gab22642cd5bba446dbb60f72130849f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab62b1919fa12a68dd1196a0d42f7937e"><td class="memItemLeft" align="right" valign="top"><a id="gab62b1919fa12a68dd1196a0d42f7937e"></a>
const <a class="el" href="struct_cv_point.html">CvPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pts</b></td></tr>
<tr class="separator:gab62b1919fa12a68dd1196a0d42f7937e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4641f27a1a1d935354d25750637b31"><td class="memItemLeft" align="right" valign="top"><a id="ga1d4641f27a1a1d935354d25750637b31"></a>
const <a class="el" href="struct_cv_point.html">CvPoint</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>npts</b></td></tr>
<tr class="separator:ga1d4641f27a1a1d935354d25750637b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2730ea8d331d56b653a9bd464800705"><td class="memItemLeft" align="right" valign="top"><a id="gad2730ea8d331d56b653a9bd464800705"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> const int int&#160;</td><td class="memItemRight" valign="bottom"><b>contours</b></td></tr>
<tr class="separator:gad2730ea8d331d56b653a9bd464800705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4c20ad4606da0483131d8334887035"><td class="memItemLeft" align="right" valign="top"><a id="ga5b4c20ad4606da0483131d8334887035"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> const int int int&#160;</td><td class="memItemRight" valign="bottom"><b>is_closed</b></td></tr>
<tr class="separator:ga5b4c20ad4606da0483131d8334887035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473ad7afd12dfd7f50bfdb121546ecf4"><td class="memItemLeft" align="right" valign="top"><a id="ga473ad7afd12dfd7f50bfdb121546ecf4"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_point.html">CvPoint</a> <a class="el" href="struct_cv_line_iterator.html">CvLineIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>line_iterator</b></td></tr>
<tr class="separator:ga473ad7afd12dfd7f50bfdb121546ecf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c26418680b543c9d49e0fa50387beb7"><td class="memItemLeft" align="right" valign="top"><a id="ga2c26418680b543c9d49e0fa50387beb7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>font_face</b></td></tr>
<tr class="separator:ga2c26418680b543c9d49e0fa50387beb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad232f4a0c75619f6771b77f139c428c1"><td class="memItemLeft" align="right" valign="top"><a id="gad232f4a0c75619f6771b77f139c428c1"></a>
int double&#160;</td><td class="memItemRight" valign="bottom"><b>hscale</b></td></tr>
<tr class="separator:gad232f4a0c75619f6771b77f139c428c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f39c807f592c16df9e15d1f12b7f89"><td class="memItemLeft" align="right" valign="top"><a id="ga07f39c807f592c16df9e15d1f12b7f89"></a>
int double double&#160;</td><td class="memItemRight" valign="bottom"><b>vscale</b></td></tr>
<tr class="separator:ga07f39c807f592c16df9e15d1f12b7f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16343090e80c4472521560f30113d96c"><td class="memItemLeft" align="right" valign="top"><a id="ga16343090e80c4472521560f30113d96c"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>text</b></td></tr>
<tr class="separator:ga16343090e80c4472521560f30113d96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64134bb6e06c9eb9e583ca404fb9ee5e"><td class="memItemLeft" align="right" valign="top"><a id="ga64134bb6e06c9eb9e583ca404fb9ee5e"></a>
const char <a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>org</b></td></tr>
<tr class="separator:ga64134bb6e06c9eb9e583ca404fb9ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf614986202b1d48186de69552e1e53fb"><td class="memItemLeft" align="right" valign="top"><a id="gaf614986202b1d48186de69552e1e53fb"></a>
const char <a class="el" href="struct_cv_point.html">CvPoint</a> const <a class="el" href="struct_cv_font.html">CvFont</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>font</b></td></tr>
<tr class="separator:gaf614986202b1d48186de69552e1e53fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3c7e3fafeab30d8b0fffe52ae5242b"><td class="memItemLeft" align="right" valign="top"><a id="ga3f3c7e3fafeab30d8b0fffe52ae5242b"></a>
const <a class="el" href="struct_cv_font.html">CvFont</a> <a class="el" href="struct_cv_size.html">CvSize</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>text_size</b></td></tr>
<tr class="separator:ga3f3c7e3fafeab30d8b0fffe52ae5242b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95651caa23acde12caf9a96e42a796ba"><td class="memItemLeft" align="right" valign="top"><a id="ga95651caa23acde12caf9a96e42a796ba"></a>
const <a class="el" href="struct_cv_font.html">CvFont</a> <a class="el" href="struct_cv_size.html">CvSize</a> int *&#160;</td><td class="memItemRight" valign="bottom"><b>baseline</b></td></tr>
<tr class="separator:ga95651caa23acde12caf9a96e42a796ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e193b91453df3db5e0f2b55326e1f46"><td class="memItemLeft" align="right" valign="top"><a id="ga4e193b91453df3db5e0f2b55326e1f46"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>arrtype</b></td></tr>
<tr class="separator:ga4e193b91453df3db5e0f2b55326e1f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54049bf4c7b3eaadcc161d2a3385b1b8"><td class="memItemLeft" align="right" valign="top"><a id="ga54049bf4c7b3eaadcc161d2a3385b1b8"></a>
<a class="el" href="struct_cv_size.html">CvSize</a> int int&#160;</td><td class="memItemRight" valign="bottom"><b>arc_start</b></td></tr>
<tr class="separator:ga54049bf4c7b3eaadcc161d2a3385b1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8362b2b783fa9b5020f72d7c06cd723b"><td class="memItemLeft" align="right" valign="top"><a id="ga8362b2b783fa9b5020f72d7c06cd723b"></a>
<a class="el" href="struct_cv_size.html">CvSize</a> int int int&#160;</td><td class="memItemRight" valign="bottom"><b>arc_end</b></td></tr>
<tr class="separator:ga8362b2b783fa9b5020f72d7c06cd723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5763d62f5c6f37e64f38d25dddcc10fa"><td class="memItemLeft" align="right" valign="top"><a id="ga5763d62f5c6f37e64f38d25dddcc10fa"></a>
<a class="el" href="struct_cv_size.html">CvSize</a> int int int <a class="el" href="struct_cv_point.html">CvPoint</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>delta</b></td></tr>
<tr class="separator:ga5763d62f5c6f37e64f38d25dddcc10fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc53f0a2ae231f4fb30fb213be65a50"><td class="memItemLeft" align="right" valign="top"><a id="gadbc53f0a2ae231f4fb30fb213be65a50"></a>
<a class="el" href="struct_cv_seq.html">CvSeq</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>contour</b></td></tr>
<tr class="separator:gadbc53f0a2ae231f4fb30fb213be65a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8feb6df0c80b5756cb5f8247373b31f3"><td class="memItemLeft" align="right" valign="top"><a id="ga8feb6df0c80b5756cb5f8247373b31f3"></a>
<a class="el" href="struct_cv_seq.html">CvSeq</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>external_color</b></td></tr>
<tr class="separator:ga8feb6df0c80b5756cb5f8247373b31f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb721a49742abd2b77c1db98fe58c635"><td class="memItemLeft" align="right" valign="top"><a id="gafb721a49742abd2b77c1db98fe58c635"></a>
<a class="el" href="struct_cv_seq.html">CvSeq</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hole_color</b></td></tr>
<tr class="separator:gafb721a49742abd2b77c1db98fe58c635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d955ad271b90fdcbd2e6c96a9d4cd3"><td class="memItemLeft" align="right" valign="top"><a id="ga56d955ad271b90fdcbd2e6c96a9d4cd3"></a>
<a class="el" href="struct_cv_seq.html">CvSeq</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a> <a class="el" href="struct_cv_scalar.html">CvScalar</a> int&#160;</td><td class="memItemRight" valign="bottom"><b>max_level</b></td></tr>
<tr class="separator:ga56d955ad271b90fdcbd2e6c96a9d4cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gadd47b69c3f9fc86ba30c92488645229d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd47b69c3f9fc86ba30c92488645229d">&#9670;&nbsp;</a></span>CV_INIT_3X3_DELTAS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_INIT_3X3_DELTAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">deltas, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">step, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nch&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((deltas)[0] =  (nch),  (deltas)[1] = -(step) + (nch),  \</div><div class="line">     (deltas)[2] = -(step), (deltas)[3] = -(step) - (nch),  \</div><div class="line">     (deltas)[4] = -(nch),  (deltas)[5] =  (step) - (nch),  \</div><div class="line">     (deltas)[6] =  (step), (deltas)[7] =  (step) + (nch))</div></div><!-- fragment --><p>initializes 8-element array for fast access to 3x3 neighborhood of a pixel </p>

</div>
</div>
<a id="ga8d99d5caee87b79157e1b9d491be9c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d99d5caee87b79157e1b9d491be9c25">&#9670;&nbsp;</a></span>CV_NEXT_LINE_POINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_NEXT_LINE_POINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">line_iterator</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                               \</div><div class="line">    int _line_iterator_mask = (line_iterator).err &lt; 0 ? -1 : 0; \</div><div class="line">    (line_iterator).err += (line_iterator).minus_delta +        \</div><div class="line">        ((line_iterator).plus_delta &amp; _line_iterator_mask);     \</div><div class="line">    (line_iterator).ptr += (line_iterator).minus_step +         \</div><div class="line">        ((line_iterator).plus_step &amp; _line_iterator_mask);      \</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga126c3960af8241b0065211bcb0c4c4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga126c3960af8241b0065211bcb0c4c4ee">&#9670;&nbsp;</a></span>CvChainPtReader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_cv_chain_pt_reader.html">CvChainPtReader</a>
 <a class="el" href="struct_cv_chain_pt_reader.html">CvChainPtReader</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Freeman chain reader state </p>

</div>
</div>
<a id="gae187bc007c9e041da9b97dcfe0431b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae187bc007c9e041da9b97dcfe0431b64">&#9670;&nbsp;</a></span>CvConnectedComp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_cv_connected_comp.html">CvConnectedComp</a>
 <a class="el" href="struct_cv_connected_comp.html">CvConnectedComp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connected component structure </p>

</div>
</div>
<a id="ga601b02375a2915aa2e653562da03cd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga601b02375a2915aa2e653562da03cd93">&#9670;&nbsp;</a></span>CvConvexityDefect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_cv_convexity_defect.html">CvConvexityDefect</a>  <a class="el" href="struct_cv_convexity_defect.html">CvConvexityDefect</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convexity defect </p>

</div>
</div>
<a id="ga006b1ff87dfa7cf766db6c6a09a43310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga006b1ff87dfa7cf766db6c6a09a43310">&#9670;&nbsp;</a></span>CvFont</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_cv_font.html">CvFont</a>
 <a class="el" href="struct_cv_font.html">CvFont</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Font structure </p>

</div>
</div>
<a id="ga85a4d1d82e0dd8e0faa464584472747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85a4d1d82e0dd8e0faa464584472747a">&#9670;&nbsp;</a></span>CvHuMoments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_cv_hu_moments.html">CvHuMoments</a>
 <a class="el" href="struct_cv_hu_moments.html">CvHuMoments</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hu invariants </p>

</div>
</div>
<a id="ga738efca5ab93feb8333bbe24f8d57839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga738efca5ab93feb8333bbe24f8d57839">&#9670;&nbsp;</a></span>CvMoments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_cv_moments.html">CvMoments</a>
 <a class="el" href="struct_cv_moments.html">CvMoments</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spatial and central moments </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa52ea6a123f47db5e6b145e5fc5e369a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52ea6a123f47db5e6b145e5fc5e369a">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters used in pyramid decomposition </p>

</div>
</div>
<a id="gafccaefcc48c7849e1f3defa3f1fd1f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafccaefcc48c7849e1f3defa3f1fd1f8a">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special filters </p>

</div>
</div>
<a id="gaa7477aaaec7caec07471eb609c556f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7477aaaec7caec07471eb609c556f5f">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constants for color conversion </p>

</div>
</div>
<a id="gaa6db2c38ebc194c80d154d53851a4d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6db2c38ebc194c80d154d53851a4d5d">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sub-pixel interpolation methods </p>

</div>
</div>
<a id="gae7c221b877c671251f317a43dbea2583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c221b877c671251f317a43dbea2583">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>... and other image warping flags </p>

</div>
</div>
<a id="ga0fa6e789ab8d8c920f2104ee8c183196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa6e789ab8d8c920f2104ee8c183196">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Morphological operations </p>

</div>
</div>
<a id="ga6d8d14defa336cd0180dccd1e0170dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8d14defa336cd0180dccd1e0170dd5">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template matching methods </p>

</div>
</div>
<a id="ga48b7364b5ceec8a2d131dc2cf2587628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b7364b5ceec8a2d131dc2cf2587628">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contour retrieval modes </p>

</div>
</div>
<a id="gaafc5993fe6fd7fec62e94ef57859c353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafc5993fe6fd7fec62e94ef57859c353">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contour approximation methods </p>

</div>
</div>
<a id="ga87d22175c5de65fbe6a0b3b53305dee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d22175c5de65fbe6a0b3b53305dee4">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contour approximation algorithms </p>

</div>
</div>
<a id="ga2ed332df4696233768771e93d4081c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed332df4696233768771e93d4081c3f">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shape orientation </p>

</div>
</div>
<a id="ga3e279efabf854742684341c3e4f50d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e279efabf854742684341c3e4f50d31">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Histogram comparison methods </p>

</div>
</div>
<a id="ga3d3667ada0f76359974e3bdb799ada12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d3667ada0f76359974e3bdb799ada12">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask size for distance transform </p>

</div>
</div>
<a id="gac12627b43234a2c5005eca7a2a0a88cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12627b43234a2c5005eca7a2a0a88cd">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Content of output label array: connected components or pixels </p>

</div>
</div>
<a id="gabe4eb8a7f480877e96248c1c2b2b96a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4eb8a7f480877e96248c1c2b2b96a4">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distance types for Distance Transform and M-estimators </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4a85dc4b9e7225ea418574237f0490b2a6"></a>CV_DIST_USER&#160;</td><td class="fielddoc"><p>User defined distance </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4a0b4bea01885957ad908478061c57e67b"></a>CV_DIST_L1&#160;</td><td class="fielddoc"><p>distance = |x1-x2| + |y1-y2| </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4ae60a48ac6e8738abf6746c4beb4a9962"></a>CV_DIST_L2&#160;</td><td class="fielddoc"><p>the simple euclidean distance </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4abac689302eb020962e5ef5615de87c07"></a>CV_DIST_C&#160;</td><td class="fielddoc"><p>distance = max(|x1-x2|,|y1-y2|) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4ae76bff7327eb425bf30cca11e4bc1387"></a>CV_DIST_L12&#160;</td><td class="fielddoc"><p>L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4abcb84a93465c9ac0e37c0e17d0faae7e"></a>CV_DIST_FAIR&#160;</td><td class="fielddoc"><p>distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4ac9d04b49e7f44944c936c707650327e4"></a>CV_DIST_WELSCH&#160;</td><td class="fielddoc"><p>distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe4eb8a7f480877e96248c1c2b2b96a4a1725669ada87a92eea265d0346d09513"></a>CV_DIST_HUBER&#160;</td><td class="fielddoc"><p>distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5ff73139485369f629981d087e744c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ff73139485369f629981d087e744c90">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Threshold types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5ff73139485369f629981d087e744c90a6af8cb4caea50fb9578d4543aa7b6f20"></a>CV_THRESH_BINARY&#160;</td><td class="fielddoc"><p>value = value &gt; threshold ? max_value : 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5ff73139485369f629981d087e744c90a5605ead87cfc7a9a8daa1448f7fba488"></a>CV_THRESH_BINARY_INV&#160;</td><td class="fielddoc"><p>value = value &gt; threshold ? 0 : max_value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5ff73139485369f629981d087e744c90ab24c5803c81111f2758c91b14dd48cf1"></a>CV_THRESH_TRUNC&#160;</td><td class="fielddoc"><p>value = value &gt; threshold ? threshold : value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5ff73139485369f629981d087e744c90aaab30b5f1f73c2e5b280982f35d7c46d"></a>CV_THRESH_TOZERO&#160;</td><td class="fielddoc"><p>value = value &gt; threshold ? value : 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5ff73139485369f629981d087e744c90ac166f17f23efb6bcc221e9df92917de5"></a>CV_THRESH_TOZERO_INV&#160;</td><td class="fielddoc"><p>value = value &gt; threshold ? 0 : value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5ff73139485369f629981d087e744c90a2456934f4f01402e80006a317ea2693e"></a>CV_THRESH_OTSU&#160;</td><td class="fielddoc"><p>use Otsu algorithm to choose the optimal threshold value; combine the flag with one of the above CV_THRESH_* values </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5ff73139485369f629981d087e744c90ad963b0512c243be1ec737eadfc4f3cfe"></a>CV_THRESH_TRIANGLE&#160;</td><td class="fielddoc"><p>use Triangle algorithm to choose the optimal threshold value; combine the flag with one of the above CV_THRESH_* values, but not with CV_THRESH_OTSU </p>
</td></tr>
</table>

</div>
</div>
<a id="ga15b8f0a0cc23d28aafa1b827c46a5305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b8f0a0cc23d28aafa1b827c46a5305">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adaptive threshold methods </p>

</div>
</div>
<a id="ga831b5795adf211dfa086182261563b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga831b5795adf211dfa086182261563b02">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FloodFill flags </p>

</div>
</div>
<a id="gaa62371d642974c67a0c0efa77d54fcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62371d642974c67a0c0efa77d54fcbd">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Canny edge detector flags </p>

</div>
</div>
<a id="ga82f2c6e4d47f62f6b65c5887eb096fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82f2c6e4d47f62f6b65c5887eb096fd5">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variants of a Hough transform </p>

</div>
</div>
<a id="gab5b30479580723fe97bab56d9b69239d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5b30479580723fe97bab56d9b69239d">&#9670;&nbsp;</a></span>MorphShapes_c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__c.html#gab5b30479580723fe97bab56d9b69239d">MorphShapes_c</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shapes of a structuring element for morphological operations </p><dl class="section see"><dt>See also</dt><dd>cv::MorphShapes, cv::getStructuringElement </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab5b30479580723fe97bab56d9b69239dae7372371053c086eb9cf79d41769af59"></a>CV_SHAPE_CUSTOM&#160;</td><td class="fielddoc"><p>custom structuring element </p>
</td></tr>
</table>

</div>
</div>
<a id="gacd971ae682604ff73cdb88645725968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd971ae682604ff73cdb88645725968d">&#9670;&nbsp;</a></span>ShapeMatchModes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__c.html#gacd971ae682604ff73cdb88645725968d">ShapeMatchModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shape matching methods. </p>
<p><img class="formulaInl" alt="$A$" src="form_4.png"/> denotes object1, <img class="formulaInl" alt="$B$" src="form_345.png"/> denotes object2</p>
<p><img class="formulaInl" alt="$\begin{array}{l} m^A_i = \mathrm{sign} (h^A_i) \cdot \log{h^A_i} \\ m^B_i = \mathrm{sign} (h^B_i) \cdot \log{h^B_i} \end{array}$" src="form_346.png"/></p>
<p>and <img class="formulaInl" alt="$h^A_i, h^B_i$" src="form_347.png"/> are the Hu moments of <img class="formulaInl" alt="$A$" src="form_4.png"/> and <img class="formulaInl" alt="$B$" src="form_345.png"/> , respectively. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd971ae682604ff73cdb88645725968da6ae4597e01365cd5c3469dc2f5cd2fea"></a>CV_CONTOURS_MATCH_I1&#160;</td><td class="fielddoc"><p class="formulaDsp">
<img class="formulaDsp" alt="\[I_1(A,B) = \sum _{i=1...7} \left | \frac{1}{m^A_i} - \frac{1}{m^B_i} \right |\]" src="form_351.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="ggacd971ae682604ff73cdb88645725968dae3011fca74bc54836e9457de352069eb"></a>CV_CONTOURS_MATCH_I2&#160;</td><td class="fielddoc"><p class="formulaDsp">
<img class="formulaDsp" alt="\[I_2(A,B) = \sum _{i=1...7} \left | m^A_i - m^B_i \right |\]" src="form_352.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="ggacd971ae682604ff73cdb88645725968dad2141011f1cd57f6542c7da2412c9fe3"></a>CV_CONTOURS_MATCH_I3&#160;</td><td class="fielddoc"><p class="formulaDsp">
<img class="formulaDsp" alt="\[I_3(A,B) = \max _{i=1...7} \frac{ \left| m^A_i - m^B_i \right| }{ \left| m^A_i \right| }\]" src="form_353.png"/>
</p>
 </td></tr>
</table>

</div>
</div>
<a id="ga68a3a4144ad5ad650bed7f0ede3611c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68a3a4144ad5ad650bed7f0ede3611c2">&#9670;&nbsp;</a></span>SmoothMethod_c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__c.html#ga68a3a4144ad5ad650bed7f0ede3611c2">SmoothMethod_c</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Image smooth methods </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga68a3a4144ad5ad650bed7f0ede3611c2aa06086448eff38b500b296baa0ff6590"></a>CV_BLUR_NO_SCALE&#160;</td><td class="fielddoc"><p>linear convolution with <img class="formulaInl" alt="$\texttt{size1}\times\texttt{size2}$" src="form_348.png"/> box kernel (all 1's). If you want to smooth different pixels with different-size box kernels, you can use the integral image that is computed using integral </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68a3a4144ad5ad650bed7f0ede3611c2abd20b6c1b1f0779073712a370a3c64f9"></a>CV_BLUR&#160;</td><td class="fielddoc"><p>linear convolution with <img class="formulaInl" alt="$\texttt{size1}\times\texttt{size2}$" src="form_348.png"/> box kernel (all 1's) with subsequent scaling by <img class="formulaInl" alt="$1/(\texttt{size1}\cdot\texttt{size2})$" src="form_349.png"/> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68a3a4144ad5ad650bed7f0ede3611c2a5f9c9d19089c103e1324b65ef51b77b1"></a>CV_GAUSSIAN&#160;</td><td class="fielddoc"><p>linear convolution with a <img class="formulaInl" alt="$\texttt{size1}\times\texttt{size2}$" src="form_348.png"/> Gaussian kernel </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68a3a4144ad5ad650bed7f0ede3611c2a0110fa78c2574e7eceb7e4d3a9015a56"></a>CV_MEDIAN&#160;</td><td class="fielddoc"><p>median filter with a <img class="formulaInl" alt="$\texttt{size1}\times\texttt{size1}$" src="form_350.png"/> square aperture </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68a3a4144ad5ad650bed7f0ede3611c2af3992d7005749422f871b7ea70e975b0"></a>CV_BILATERAL&#160;</td><td class="fielddoc"><p>bilateral filter with a <img class="formulaInl" alt="$\texttt{size1}\times\texttt{size1}$" src="form_350.png"/> square aperture, color sigma= sigma1 and spatial sigma= sigma2. If size1=0, the aperture square side is set to cvRound(sigma2*1.5)*2+1. See cv::bilateralFilter </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga51a5e3d67c770fdb9275f7e24792f959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51a5e3d67c770fdb9275f7e24792f959">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds image to accumulator. </p>
<p>Draws contour outlines or filled interiors on the image.</p>
<p>Calculates bounding box of text stroke (useful for alignment)</p>
<p>Renders text stroke with specified font and color at specified location. <a class="el" href="struct_cv_font.html">CvFont</a> should be initialized with cvInitFont.</p>
<p>Initializes font structure (OpenCV 1.x API).</p>
<p>Draws one or more polygonal curves.</p>
<p>Fills an area bounded by one or more arbitrary polygons.</p>
<p>Fills convex or monotonous polygon.</p>
<p>Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector.</p>
<p>Draws a circle with specified center and radius.</p>
<p>Draws a rectangle specified by a <a class="el" href="struct_cv_rect.html">CvRect</a> structure.</p>
<p>Draws a rectangle given two opposite corners of the rectangle (pt1 &amp; pt2)</p>
<p>Draws 4-connected, 8-connected or antialiased line segment connecting two points.</p>
<p>Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)</p>
<p>Finds a sparse set of points within the selected region that seem to be easy to track.</p>
<p>Adjust corner position using some sort of gradient search.</p>
<p>Harris corner detector:</p>
<p>Calculates minimal eigenvalue for 2x2 gradient covariation matrix at every image pixel.</p>
<p>Calculates eigen values and vectors of 2x2 gradient covariation matrix at every image pixel.</p>
<p>Calculates constraint image for corner detection.</p>
<p>Runs canny edge detector.</p>
<p>Fills the connected component until the color difference gets large enough.</p>
<p>Applies adaptive threshold to grayscale image.</p>
<p>Applies distance transform to binary image.</p>
<p>equalizes histogram of 8-bit single-channel image</p>
<p>Divides one histogram by another.</p>
<p>Locates a template within an image by using a histogram comparison.</p>
<p>Calculates back project.</p>
<p>Calculates array histogram.</p>
<p>Calculates bayesian probabilistic histograms (each or src and dst is an array of <em>number</em> histograms.</p>
<p>Copies a histogram.</p>
<p>Thresholds the histogram.</p>
<p>Normalizes the histogram.</p>
<p>Finds the minimum and maximum histogram bins.</p>
<p>Clears the histogram.</p>
<p>Releases the histogram.</p>
<p>Sets the bounds of the histogram bins.</p>
<p>Finds coordinates of the box vertices.</p>
<p>Initializes Freeman chain reader.</p>
<p>Substitutes the last retrieved contour with the new one.</p>
<p>Measures similarity between template and overlapped windows in the source image and fills the resultant image with the measurements.</p>
<p>Retrieves quadrangle from the input array.</p>
<p>Retrieves the rectangular image region with specified center from the input array.</p>
<p>Calculates 7 Hu's invariants from precalculated spatial and central moments.</p>
<p>Calculates all spatial and central moments up to the 3rd order.</p>
<p>Performs complex morphological transformation.</p>
<p>dilates input image (applies maximum filter) one or more times.</p>
<p>erodes input image (applies minimum filter) one or more times. If element pointer is NULL, 3x3 rectangular element is used</p>
<p>releases structuring element</p>
<p>Computes the original (undistorted) feature coordinates from the observed (distorted) coordinates.</p>
<p>Computes undistortion+rectification map for a head of stereo camera.</p>
<p>Computes transformation map from intrinsic camera parameters that can used by cvRemap.</p>
<p>Transforms the input image to compensate lens distortion.</p>
<p>Performs forward or inverse log-polar image transform.</p>
<p>Converts mapx &amp; mapy from floating-point to integer formats for cvRemap.</p>
<p>Performs generic geometric transformation using the specified coordinate maps.</p>
<p>Warps image with perspective (projective) transform.</p>
<p>Warps image with affine transform.</p>
<p>Resizes image (input array is resized to fit the destination array)</p>
<p>Converts input array pixels from one color space to another.</p>
<p>Calculates the image Laplacian: (d2/dx + d2/dy)I.</p>
<p>Calculates an image derivative using generalized Sobel.</p>
<p>Segments image using seed "markers".</p>
<p>Filters image using meanshift algorithm.</p>
<p>Releases pyramid.</p>
<p>Up-samples image and smoothes the result with gaussian kernel.</p>
<p>Smoothes the input image with gaussian kernel and then down-samples it.</p>
<p>Finds integral image: SUM(X,Y) = sum(x&lt;X,y&lt;Y)I(x,y)</p>
<p>Convolves an image with the kernel.</p>
<p>Smooths the image in one of several ways.</p>
<p>Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha.</p>
<p>Adds a product of two images to accumulator.</p>
<p>Adds squared image to accumulator.</p>
<dl class="section see"><dt>See also</dt><dd>cv::accumulate</dd>
<dd>
cv::accumulateSquare</dd>
<dd>
cv::accumulateProduct</dd>
<dd>
cv::accumulateWeighted</dd></dl>
<p>Copies source 2D array inside of the larger destination array and makes a border of the specified type (IPL_BORDER_*) around the copied area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source image </td></tr>
    <tr><td class="paramname">dst</td><td>The destination image </td></tr>
    <tr><td class="paramname">smoothtype</td><td>Type of the smoothing, see SmoothMethod_c </td></tr>
    <tr><td class="paramname">size1</td><td>The first parameter of the smoothing operation, the aperture width. Must be a positive odd number (1, 3, 5, ...) </td></tr>
    <tr><td class="paramname">size2</td><td>The second parameter of the smoothing operation, the aperture height. Ignored by CV_MEDIAN and CV_BILATERAL methods. In the case of simple scaled/non-scaled and Gaussian blur if size2 is zero, it is set to size1. Otherwise it must be a positive odd number. </td></tr>
    <tr><td class="paramname">sigma1</td><td>In the case of a Gaussian parameter this parameter may specify Gaussian <img class="formulaInl" alt="$\sigma$" src="form_336.png"/> (standard deviation). If it is zero, it is calculated from the kernel size: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\sigma = 0.3 (n/2 - 1) + 0.8 \quad \text{where} \quad n= \begin{array}{l l} \mbox{\texttt{size1} for horizontal kernel} \\ \mbox{\texttt{size2} for vertical kernel} \end{array}\]" src="form_337.png"/>
</p>
 Using standard sigma for small kernels ( <img class="formulaInl" alt="$3\times 3$" src="form_338.png"/> to <img class="formulaInl" alt="$7\times 7$" src="form_339.png"/> ) gives better speed. If sigma1 is not zero, while size1 and size2 are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation). </td></tr>
    <tr><td class="paramname">sigma2</td><td>additional parameter for bilateral filtering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::GaussianBlur, cv::blur, cv::medianBlur, cv::bilateralFilter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input image. </td></tr>
    <tr><td class="paramname">dst</td><td>output image of the same size and the same number of channels as src. </td></tr>
    <tr><td class="paramname">kernel</td><td>convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. </td></tr>
    <tr><td class="paramname">anchor</td><td>anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::filter2D</dd>
<dd>
cv::integral</dd></dl>
<p>dst_width = floor(src_width/2)[+1], dst_height = floor(src_height/2)[+1] </p><dl class="section see"><dt>See also</dt><dd>cv::pyrDown</dd></dl>
<p>dst_width = src_width*2, dst_height = src_height*2 </p><dl class="section see"><dt>See also</dt><dd>cv::pyrUp</dd>
<dd>
cv::pyrMeanShiftFiltering</dd>
<dd>
cv::watershed</dd></dl>
<p>(aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator. Scharr can be used only for the first dx or dy derivative </p><dl class="section see"><dt>See also</dt><dd>cv::Sobel</dd>
<dd>
cv::Laplacian</dd>
<dd>
cv::cvtColor</dd>
<dd>
cv::resize</dd></dl>
<dl class="section note"><dt>Note</dt><dd>::cvGetQuadrangleSubPix is similar to ::cvWarpAffine, but the outliers are extrapolated using replication border mode. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>cv::warpAffine</dd>
<dd>
cv::warpPerspective</dd>
<dd>
cv::remap</dd>
<dd>
cv::convertMaps</dd>
<dd>
cv::logPolar</dd></dl>
<p>Performs forward or inverse linear-polar image transform </p><dl class="section see"><dt>See also</dt><dd>cv::linearPolar</dd>
<dd>
cv::undistort</dd>
<dd>
cv::initUndistortRectifyMap</dd>
<dd>
cv::undistortPoints</dd>
<dd>
cvCreateStructuringElementEx</dd>
<dd>
cv::erode</dd></dl>
<p>If element pointer is NULL, 3x3 rectangular element is used </p><dl class="section see"><dt>See also</dt><dd>cv::dilate</dd>
<dd>
cv::morphologyEx</dd>
<dd>
cv::moments</dd>
<dd>
cv::HuMoments</dd></dl>
<p>dst(x,y) &lt;- src(x + center.x - dst_width/2, y + center.y - dst_height/2). Values of pixels with fractional coordinates are retrieved using bilinear interpolation </p><dl class="section see"><dt>See also</dt><dd>cv::getRectSubPix</dd></dl>
<p>matrixarr = ( a11 a12 | b1 ) dst(x,y) &lt;- src(A[x y]' + b) ( a21 a22 | b2 ) (bilinear interpolation is used to retrieve pixels with fractional coordinates) </p><dl class="section see"><dt>See also</dt><dd>cvWarpAffine</dd>
<dd>
cv::matchTemplate</dd></dl>
<p>(if the substitutor is null, the last retrieved contour is removed from the tree) </p><dl class="section see"><dt>See also</dt><dd>cvFindContours</dd></dl>
<p>The reader is used to iteratively get coordinates of all the chain points. If the Freeman codes should be read as is, a simple sequence reader should be used </p><dl class="section see"><dt>See also</dt><dd>cvApproxChains</dd></dl>
<p>This is a standalone function for setting bin ranges in the histogram. For a more detailed description of the parameters ranges and uniform, see the :ocvCalcHist function that can initialize the ranges as well. Ranges for the histogram bins must be set before the histogram is calculated or the backproject of the histogram is calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">ranges</td><td>Array of bin ranges arrays. See :ocvCreateHist for details. </td></tr>
    <tr><td class="paramname">uniform</td><td>Uniformity flag. See :ocvCreateHist for details.</td></tr>
  </table>
  </dd>
</dl>
<p>The function releases the histogram (header and the data). The pointer to the histogram is cleared by the function. If *hist pointer is already NULL, the function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Double pointer to the released histogram.</td></tr>
  </table>
  </dd>
</dl>
<p>The function sets all of the histogram bins to 0 in case of a dense histogram and removes all histogram bins in case of a sparse array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram.</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds the minimum and maximum histogram bins and their positions. All of output arguments are optional. Among several extremas with the same value the ones with the minimum index (in the lexicographical order) are returned. In case of several maximums or minimums, the earliest in the lexicographical order (extrema locations) is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">min_value</td><td>Pointer to the minimum value of the histogram. </td></tr>
    <tr><td class="paramname">max_value</td><td>Pointer to the maximum value of the histogram. </td></tr>
    <tr><td class="paramname">min_idx</td><td>Pointer to the array of coordinates for the minimum. </td></tr>
    <tr><td class="paramname">max_idx</td><td>Pointer to the array of coordinates for the maximum.</td></tr>
  </table>
  </dd>
</dl>
<p>The function normalizes the histogram bins by scaling them so that the sum of the bins becomes equal to factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Pointer to the histogram. </td></tr>
    <tr><td class="paramname">factor</td><td>Normalization factor.</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears histogram bins that are below the specified threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Pointer to the histogram. </td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold level.</td></tr>
  </table>
  </dd>
</dl>
<p>The function makes a copy of the histogram. If the second histogram pointer *dst is NULL, a new histogram of the same size as src is created. Otherwise, both histograms must have equal types and sizes. Then the function copies the bin values of the source histogram to the destination histogram and sets the same bin value ranges as in src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source histogram. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination histogram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::calcHist</dd>
<dd>
cvCalcBackProject, cv::calcBackProject</dd></dl>
<p>The function calculates the back projection by comparing histograms of the source image patches with the given histogram. The function is similar to matchTemplate, but instead of comparing the raster patch with all its possible positions within the search window, the function CalcBackProjectPatch compares histograms. See the algorithm diagram below:</p>
<div class="image">
<img src="pics/backprojectpatch.png" alt="image"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Source images (though, you may pass CvMat** as well). </td></tr>
    <tr><td class="paramname">dst</td><td>Destination image. </td></tr>
    <tr><td class="paramname">range</td><td></td></tr>
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">method</td><td>Comparison method passed to cvCompareHist (see the function description). </td></tr>
    <tr><td class="paramname">factor</td><td>Normalization factor for histograms that affects the normalization scale of the destination image. Pass 1 if not sure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvCalcBackProjectPatch</dd></dl>
<p>The function calculates the object probability density from two histograms as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{disthist} (I)= \forkthree{0}{if \(\texttt{hist1}(I)=0\)}{\texttt{scale}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) &gt; \texttt{hist1}(I)\)}{\frac{\texttt{hist2}(I) \cdot \texttt{scale}}{\texttt{hist1}(I)}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) \le \texttt{hist1}(I)\)}\]" src="form_344.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist1</td><td>First histogram (the divisor). </td></tr>
    <tr><td class="paramname">hist2</td><td>Second histogram. </td></tr>
    <tr><td class="paramname">dst_hist</td><td>Destination histogram. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor for the destination histogram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::equalizeHist</dd>
<dd>
cv::distanceTransform</dd></dl>
<p>The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and CV_ADAPTIVE_THRESH_GAUSSIAN_C are: neighborhood size (3, 5, 7 etc.), and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...) </p><dl class="section see"><dt>See also</dt><dd>cv::adaptiveThreshold</dd>
<dd>
cv::floodFill</dd>
<dd>
cv::Canny</dd></dl>
<p>Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy. Applying threshold to the result gives coordinates of corners </p><dl class="section see"><dt>See also</dt><dd>cv::preCornerDetect</dd>
<dd>
cv::cornerEigenValsAndVecs</dd>
<dd>
cv::cornerMinEigenVal</dd></dl>
<p>Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel </p><dl class="section see"><dt>See also</dt><dd>cv::cornerHarris</dd>
<dd>
cv::cornerSubPix</dd>
<dd>
cv::goodFeaturesToTrack</dd>
<dd>
cv::fitLine</dd>
<dd>
cv::line</dd></dl>
<p>if thickness&lt;0 (e.g. thickness == CV_FILLED), the filled box is drawn </p><dl class="section see"><dt>See also</dt><dd>cv::rectangle</dd>
<dd>
cv::rectangle</dd></dl>
<p>Thickness works in the same way as with cvRectangle </p><dl class="section see"><dt>See also</dt><dd>cv::circle</dd></dl>
<p>depending on <em>thickness</em>, <em>start_angle</em> and <em>end_angle</em> parameters. The resultant figure is rotated by <em>angle</em>. All the angles are in degrees </p><dl class="section see"><dt>See also</dt><dd>cv::ellipse</dd>
<dd>
cv::fillConvexPoly</dd>
<dd>
cv::fillPoly</dd>
<dd>
cv::polylines</dd></dl>
<p>The function initializes the font structure that can be passed to text rendering functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">font</td><td>Pointer to the font structure initialized by the function </td></tr>
    <tr><td class="paramname">font_face</td><td>Font name identifier. See cv::HersheyFonts and corresponding old CV_* identifiers. </td></tr>
    <tr><td class="paramname">hscale</td><td>Horizontal scale. If equal to 1.0f , the characters have the original width depending on the font type. If equal to 0.5f , the characters are of half the original width. </td></tr>
    <tr><td class="paramname">vscale</td><td>Vertical scale. If equal to 1.0f , the characters have the original height depending on the font type. If equal to 0.5f , the characters are of half the original height. </td></tr>
    <tr><td class="paramname">shear</td><td>Approximate tangent of the character slope relative to the vertical line. A zero value means a non-italic font, 1.0f means about a 45 degree slope, etc. </td></tr>
    <tr><td class="paramname">thickness</td><td>Thickness of the text strokes </td></tr>
    <tr><td class="paramname">line_type</td><td>Type of the strokes, see line description</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvPutText</dd>
<dd>
cvInitFont, cvGetTextSize, cvFont, cv::putText</dd>
<dd>
cv::getTextSize</dd>
<dd>
cv::drawContours </dd></dl>

</div>
</div>
<a id="gae7af9b91bd155084353325bf9007926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7af9b91bd155084353325bf9007926e">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates an image header. </p>
<p>stop capturing/reading and free resources</p>
<p>close video file writer</p>
<p>Draws contour outlines or filled interiors on the image.</p>
<p>Calculates bounding box of text stroke (useful for alignment)</p>
<p>Renders text stroke with specified font and color at specified location. <a class="el" href="struct_cv_font.html">CvFont</a> should be initialized with cvInitFont.</p>
<p>Initializes font structure (OpenCV 1.x API).</p>
<p>Draws one or more polygonal curves.</p>
<p>Fills an area bounded by one or more arbitrary polygons.</p>
<p>Fills convex or monotonous polygon.</p>
<p>Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector.</p>
<p>Draws a circle with specified center and radius.</p>
<p>Draws a rectangle specified by a <a class="el" href="struct_cv_rect.html">CvRect</a> structure.</p>
<p>Draws a rectangle given two opposite corners of the rectangle (pt1 &amp; pt2)</p>
<p>Draws 4-connected, 8-connected or antialiased line segment connecting two points.</p>
<p>Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)</p>
<p>Finds a sparse set of points within the selected region that seem to be easy to track.</p>
<p>Adjust corner position using some sort of gradient search.</p>
<p>Harris corner detector:</p>
<p>Calculates minimal eigenvalue for 2x2 gradient covariation matrix at every image pixel.</p>
<p>Calculates eigen values and vectors of 2x2 gradient covariation matrix at every image pixel.</p>
<p>Calculates constraint image for corner detection.</p>
<p>Runs canny edge detector.</p>
<p>Fills the connected component until the color difference gets large enough.</p>
<p>Applies adaptive threshold to grayscale image.</p>
<p>Applies distance transform to binary image.</p>
<p>equalizes histogram of 8-bit single-channel image</p>
<p>Divides one histogram by another.</p>
<p>Locates a template within an image by using a histogram comparison.</p>
<p>Calculates back project.</p>
<p>Calculates array histogram.</p>
<p>Calculates bayesian probabilistic histograms (each or src and dst is an array of <em>number</em> histograms.</p>
<p>Copies a histogram.</p>
<p>Thresholds the histogram.</p>
<p>Normalizes the histogram.</p>
<p>Finds the minimum and maximum histogram bins.</p>
<p>Clears the histogram.</p>
<p>Releases the histogram.</p>
<p>Sets the bounds of the histogram bins.</p>
<p>Finds coordinates of the box vertices.</p>
<p>Initializes Freeman chain reader.</p>
<p>Substitutes the last retrieved contour with the new one.</p>
<p>Measures similarity between template and overlapped windows in the source image and fills the resultant image with the measurements.</p>
<p>Retrieves quadrangle from the input array.</p>
<p>Retrieves the rectangular image region with specified center from the input array.</p>
<p>Calculates 7 Hu's invariants from precalculated spatial and central moments.</p>
<p>Calculates all spatial and central moments up to the 3rd order.</p>
<p>Performs complex morphological transformation.</p>
<p>dilates input image (applies maximum filter) one or more times.</p>
<p>erodes input image (applies minimum filter) one or more times. If element pointer is NULL, 3x3 rectangular element is used</p>
<p>releases structuring element</p>
<p>Computes the original (undistorted) feature coordinates from the observed (distorted) coordinates.</p>
<p>Computes undistortion+rectification map for a head of stereo camera.</p>
<p>Computes transformation map from intrinsic camera parameters that can used by cvRemap.</p>
<p>Transforms the input image to compensate lens distortion.</p>
<p>Performs forward or inverse log-polar image transform.</p>
<p>Converts mapx &amp; mapy from floating-point to integer formats for cvRemap.</p>
<p>Performs generic geometric transformation using the specified coordinate maps.</p>
<p>Warps image with perspective (projective) transform.</p>
<p>Warps image with affine transform.</p>
<p>Resizes image (input array is resized to fit the destination array)</p>
<p>Converts input array pixels from one color space to another.</p>
<p>Calculates the image Laplacian: (d2/dx + d2/dy)I.</p>
<p>Calculates an image derivative using generalized Sobel.</p>
<p>Segments image using seed "markers".</p>
<p>Filters image using meanshift algorithm.</p>
<p>Releases pyramid.</p>
<p>Up-samples image and smoothes the result with gaussian kernel.</p>
<p>Smoothes the input image with gaussian kernel and then down-samples it.</p>
<p>Finds integral image: SUM(X,Y) = sum(x&lt;X,y&lt;Y)I(x,y)</p>
<p>Convolves an image with the kernel.</p>
<p>Smooths the image in one of several ways.</p>
<p>Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha.</p>
<p>Adds a product of two images to accumulator.</p>
<p>Adds squared image to accumulator.</p>
<p>Saves an object to a file.</p>
<p>Releases an object.</p>
<p>Unregisters the type.</p>
<p>Registers a new type.</p>
<p>Writes a file node to another file storage.</p>
<p>Reads multiple numbers.</p>
<p>Initializes file node sequence reader.</p>
<p>Initializes the file node sequence reader.</p>
<p>Writes multiple numbers in Base64.</p>
<p>Writes multiple numbers.</p>
<p>Starts the next stream.</p>
<p>Writes an object to file storage.</p>
<p>Writes a comment.</p>
<p>Writes a text string.</p>
<p>Writes a floating-point value.</p>
<p>Writes an integer value.</p>
<p>Finishes writing to a file node collection.</p>
<p>Starts writing a new structure.</p>
<p>Releases file storage.</p>
<p>Makes OpenCV use IPL functions for allocating IplImage and IplROI structures.</p>
<p>Calculates the cross product of two 3D vectors.</p>
<p>Fills an array with random numbers and updates the RNG state.</p>
<p>Converts one array to another with optional linear transformation.</p>
<p>Clears the array.</p>
<p>Sets every element of an array to a given value.</p>
<p>Copies one array to another.</p>
<p>Retrieves low-level information about the array.</p>
<p>Assigns user data to the array header.</p>
<p>Releases array data.</p>
<p>Allocates array data.</p>
<p>Change a specific array element.</p>
<p>Change the particular array element.</p>
<p>Deallocates sparse array.</p>
<p>Deallocates a matrix.</p>
<p>Resets the image ROI to include the entire image and releases the ROI structure.</p>
<p>Sets an image Region Of Interest (ROI) for a given rectangle.</p>
<p>Sets the channel of interest in an IplImage.</p>
<p>Deallocates the image header and the image data.</p>
<p>This call is an analogue of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(image )</div><div class="line">{</div><div class="line">    iplDeallocate(*image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI);</div><div class="line">    *image = 0;</div><div class="line">}</div></div><!-- fragment --><p> but it does not use IPL functions by default (see the CV_TURN_ON_IPL_COMPATIBILITY macro). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>This call is a shortened form of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*image )</div><div class="line">{</div><div class="line">    cvReleaseData(*image);</div><div class="line">    cvReleaseImageHeader(image);</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>If the ROI is set to NULL and the coi is <em>not</em> 0, the ROI is allocated. Most OpenCV functions do not* support the COI setting, so to process an individual image/matrix channel one may copy (via cvCopy or cvSplit) the channel to a separate image/matrix, process it and then copy the result back (via cvCopy or cvMerge) if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">coi</td><td>The channel of interest. 0 - all channels are selected, 1 - first channel is selected, etc. Note that the channel indices become 1-based.</td></tr>
  </table>
  </dd>
</dl>
<p>If the original image ROI was NULL and the rect is not the whole image, the ROI structure is allocated.</p>
<p>Most OpenCV functions support the use of ROI and treat the image rectangle as a separate image. For example, all of the pixel coordinates are counted from the top-left (or bottom-left) corner of the ROI, not the original image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">rect</td><td>The ROI rectangle</td></tr>
  </table>
  </dd>
</dl>
<p>This produces a similar result to the following, but in addition it releases the ROI structure. : </p><div class="fragment"><div class="line">cvSetImageROI(image, <a class="code" href="group__core__c.html#gafaffdb9052823163862a88209f379921">cvRect</a>(0, 0, image-&gt;width, image-&gt;height ));</div><div class="line">cvSetImageCOI(image, 0);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>The function decrements the matrix data reference counter and deallocates matrix header. If the data reference counter is 0, it also deallocates the data. : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*mat )</div><div class="line">    <a class="code" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85">cvDecRefData</a>(*mat);</div><div class="line">cvFree((<span class="keywordtype">void</span>**)mat);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the matrix</td></tr>
  </table>
  </dd>
</dl>
<p>low-level scalar &lt;-&gt; raw data conversion functions</p>
<p>The function releases the sparse array and clears the array pointer upon exit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the array</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign the new value to a particular array element. In the case of a sparse array the functions create the node if it does not exist yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx</td><td>Array of the element indices </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign a new value to a specific element of a single-channel array. If the array has multiple channels, a runtime error is raised. Note that the Set*D function can be used safely for both single-channel and multiple-channel arrays, though they are a bit slower.</p>
<p>In the case of a sparse array the functions create the node if it does not yet exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>clears element of ND dense array, in case of sparse arrays it deletes the specified node</p>
<p>Repeats source 2d array several times in both horizontal and vertical direction to fill destination array</p>
<p>The function allocates image, matrix or multi-dimensional dense array data. Note that in the case of matrix types OpenCV allocation functions are used. In the case of IplImage they are used unless CV_TURN_ON_IPL_COMPATIBILITY() has been called before. In the latter case IPL functions are used to allocate the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function releases the array data. In the case of <a class="el" href="struct_cv_mat.html">CvMat</a> or <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> it simply calls <a class="el" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85" title="Decrements an array data reference counter. ">cvDecRefData()</a>, that is the function can not deallocate external data. See also the note to cvCreateData . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function assigns user data to the array header. Header should be initialized before using cvCreateMatHeader, cvCreateImageHeader, cvCreateMatNDHeader, cvInitMatHeader, cvInitImageHeader or cvInitMatNDHeader. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>User data </td></tr>
    <tr><td class="paramname">step</td><td>Full row length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function fills output variables with low-level information about the array data. All output</p>
<p>parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, the parameters of ROI are returned.</p>
<p>The following example shows how to get access to array elements. It computes absolute values of the array elements : </p><div class="fragment"><div class="line"><span class="keywordtype">float</span>* data;</div><div class="line"><span class="keywordtype">int</span> step;</div><div class="line"><a class="code" href="struct_cv_size.html">CvSize</a> size;</div><div class="line"></div><div class="line">cvGetRawData(array, (uchar**)&amp;data, &amp;step, &amp;size);</div><div class="line">step /= <span class="keyword">sizeof</span>(data[0]);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = 0; y &lt; size.height; y++, data += step )</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x = 0; x &lt; size.width; x++ )</div><div class="line">        data[x] = (<span class="keywordtype">float</span>)fabs(data[x]);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>Output pointer to the whole image origin or ROI origin if ROI is set </td></tr>
    <tr><td class="paramname">step</td><td>Output full row length in bytes </td></tr>
    <tr><td class="paramname">roi_size</td><td>Output ROI size</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies selected elements from an input array to an output array:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} (I)= \texttt{src} (I) \quad \text{if} \quad \texttt{mask} (I) \ne 0.\]" src="form_158.png"/>
</p>
<p>If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions, and the same size. The function can also copy sparse arrays (mask is not supported in this case). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source array </td></tr>
    <tr><td class="paramname">dst</td><td>The destination array </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies the scalar value to every selected element of the destination array: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{arr} (I)= \texttt{value} \quad \text{if} \quad \texttt{mask} (I) \ne 0\]" src="form_159.png"/>
</p>
<p> If array arr is of IplImage type, then is ROI used, but COI must not be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">value</td><td>Fill value </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears the array. In the case of dense arrays (<a class="el" href="struct_cv_mat.html">CvMat</a>, <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> or IplImage), cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0). In the case of sparse arrays all the elements are removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to be cleared</td></tr>
  </table>
  </dd>
</dl>
<p>Splits a multi-channel array into the set of single-channel arrays or extracts particular [color] plane</p>
<p>Merges a set of single-channel arrays into the single multi-channel array or inserts one particular [color] plane to the array</p>
<p>Copies several channels from input arrays to certain channels of output arrays</p>
<p>The function has several different purposes, and thus has several different names. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} (I) = \texttt{scale} \texttt{src} (I) + ( \texttt{shift} _0, \texttt{shift} _1,...)\]" src="form_160.png"/>
</p>
<p>All the channels of multi-channel arrays are processed independently.</p>
<p>The type of conversion is done with rounding and saturation, that is if the result of scaling + conversion can not be represented exactly by a value of the destination array element type, it is set to the nearest representable value on the real axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source array </td></tr>
    <tr><td class="paramname">dst</td><td>Destination array </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor </td></tr>
    <tr><td class="paramname">shift</td><td>Value added to the scaled source array elements</td></tr>
  </table>
  </dd>
</dl>
<p>Performs linear transformation on every source array element, stores absolute value of the result: dst(x,y,c) = abs(scale*src(x,y,c)+shift). destination array must have 8u type. In other cases one may use cvConvertScale + cvAbsDiffS</p>
<p>dst(mask) = src1(mask) + src2(mask)</p>
<p>dst(mask) = src(mask) + value</p>
<p>dst(mask) = src1(mask) - src2(mask)</p>
<p>dst(mask) = value - src(mask)</p>
<p>dst(idx) = src1(idx) * src2(idx) * scale (scaled element-wise multiplication of 2 arrays)</p>
<p>element-wise division/inversion with scaling: dst(idx) = src1(idx) * scale / src2(idx) or dst(idx) = scale / src2(idx) if src1 == 0</p>
<p>dst = src1 * scale + src2</p>
<p>dst = src1 * alpha + src2 * beta + gamma</p>
<p>dst(idx) = src1(idx) &amp; src2(idx)</p>
<p>dst(idx) = src(idx) &amp; value</p>
<p>dst(idx) = src1(idx) | src2(idx)</p>
<p>dst(idx) = src(idx) | value</p>
<p>dst(idx) = src1(idx) ^ src2(idx)</p>
<p>dst(idx) = src(idx) ^ value</p>
<p>dst(idx) = ~src(idx)</p>
<p>dst(idx) = lower(idx) &lt;= src(idx) &lt; upper(idx)</p>
<p>dst(idx) = lower &lt;= src(idx) &lt; upper</p>
<p>The comparison operation support single-channel arrays only. Destination image should be 8uC1 or 8sC1 dst(idx) = src1(idx) <em>cmp_op</em> src2(idx)</p>
<p>dst(idx) = src1(idx) <em>cmp_op</em> value</p>
<p>dst(idx) = min(src1(idx),src2(idx))</p>
<p>dst(idx) = max(src1(idx),src2(idx))</p>
<p>dst(idx) = min(src(idx),value)</p>
<p>dst(idx) = max(src(idx),value)</p>
<p>dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))</p>
<p>dst(x,y,c) = abs(src(x,y,c) - value(c))</p>
<p>Does cartesian-&gt;polar coordinates conversion. Either of output components (magnitude or angle) is optional</p>
<p>Does polar-&gt;cartesian coordinates conversion. Either of output components (magnitude or angle) is optional. If magnitude is missing it is assumed to be all 1's</p>
<p>Does powering: dst(idx) = src(idx)^power</p>
<p>Does exponention: dst(idx) = exp(src(idx)). Overflow is not handled yet. Underflow is handled. Maximal relative error is ~7e-6 for single-precision input</p>
<p>Calculates natural logarithms: dst(idx) = log(abs(src(idx))). Logarithm of 0 gives large negative number(~-700) Maximal relative error is ~3e-7 for single-precision output</p>
<p>The function fills the destination array with uniformly or normally distributed random numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>CvRNG state initialized by cvRNG </td></tr>
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">dist_type</td><td>Distribution type <blockquote class="doxtable">
<ul>
<li><b>CV_RAND_UNI</b> uniform distribution</li>
<li><b>CV_RAND_NORMAL</b> normal or Gaussian distribution </li>
</ul>
</blockquote>
</td></tr>
    <tr><td class="paramname">param1</td><td>The first parameter of the distribution. In the case of a uniform distribution it is the inclusive lower boundary of the random numbers range. In the case of a normal distribution it is the mean value of the random numbers. </td></tr>
    <tr><td class="paramname">param2</td><td>The second parameter of the distribution. In the case of a uniform distribution it is the exclusive upper boundary of the random numbers range. In the case of a normal distribution it is the standard deviation of the random numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>randu, randn, RNG::fill.</dd></dl>
<p>Finds all real and complex roots of a polynomial equation</p>
<p>The function calculates the cross product of two 3D vectors: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} = \texttt{src1} \times \texttt{src2}\]" src="form_163.png"/>
</p>
<p> or: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\begin{array}{l} \texttt{dst} _1 = \texttt{src1} _2 \texttt{src2} _3 - \texttt{src1} _3 \texttt{src2} _2 \\ \texttt{dst} _2 = \texttt{src1} _3 \texttt{src2} _1 - \texttt{src1} _1 \texttt{src2} _3 \\ \texttt{dst} _3 = \texttt{src1} _1 \texttt{src2} _2 - \texttt{src1} _2 \texttt{src2} _1 \end{array}\]" src="form_164.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>The first source vector </td></tr>
    <tr><td class="paramname">src2</td><td>The second source vector </td></tr>
    <tr><td class="paramname">dst</td><td>The destination vector</td></tr>
  </table>
  </dd>
</dl>
<p>Extended matrix transform: dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T</p>
<p>Transforms each element of source array and stores resultant vectors in destination array</p>
<p>Does perspective transform on every element of input array</p>
<p>Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)</p>
<p>Tranposes matrix. Square matrices can be transposed in-place</p>
<p>Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part</p>
<p>Mirror array data around horizontal (flip=0), vertical (flip=1) or both(flip=-1) axises: cvFlip(src) flips images vertically and sequences horizontally (inplace)</p>
<p>Performs Singular Value Decomposition of a matrix</p>
<p>Performs Singular Value Back Substitution (solves A*X = B): flags must be the same as in cvSVD</p>
<p>Finds eigen values and vectors of a symmetric matrix</p>
<ul>
<li><p class="startli">Finds selected eigen values and vectors of a symmetric matrix */ Makes an identity matrix (mat_ij = i == j)</p>
<p class="startli">Calculates covariation matrix for a set of vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__c.html#core_c_CovarFlags">flags</a></dd></dl>
<p>Calculates mean and standard deviation of pixel values</p>
</li>
</ul>
<p>Finds global minimum, maximum and their positions</p>
<dl class="section see"><dt>See also</dt><dd>ref core_c_NormFlags "flags"</dd>
<dd>
<a class="el" href="group__core__c.html#core_c_ReduceFlags">flags</a></dd></dl>
<p>Discrete Fourier Transform: complex-&gt;complex, real-&gt;ccs (forward), ccs-&gt;real (inverse) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y)) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Discrete Cosine Transform </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Releases memory storage. All the children of a parent must be released before the parent. A child storage returns all the blocks to parent when it is released</p>
<p>Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos) to reuse memory allocated for the storage - cvClearSeq,cvClearSet ... do not free any memory. A child storage returns all the blocks to the parent when it is cleared</p>
<p>Remember a storage "free memory" position</p>
<p>Restore a storage "free memory" position</p>
<p>Changes default size (granularity) of sequence blocks. The default size is ~1Kbyte</p>
<p>Removes the last element from sequence and optionally saves it</p>
<p>Removes the first element from sequence and optioanally saves it</p>
<p>Adds several new elements to the end of sequence</p>
<p>Removes several elements from the end of sequence and optionally saves them</p>
<p>Removes specified sequence element</p>
<p>Removes all the elements from the sequence. The freed memory can be reused later only by the same sequence unless cvClearMemStorage or cvRestoreMemStoragePos is called</p>
<p>Initializes sequence writer. The new elements will be added to the end of sequence</p>
<p>Combination of cvCreateSeq and cvStartAppendToSeq</p>
<p>Updates sequence header. May be useful to get access to some of previously written elements via cvGetSeqElem or sequence reader</p>
<p>Initializes sequence reader. The sequence can be read in forward or backward direction</p>
<p>Changes sequence reader position. It may seek to an absolute or to relative to the current position</p>
<p>Removes sequence slice</p>
<p>Inserts a sequence or array into another sequence</p>
<p>Sorts sequence in-place given element comparison function</p>
<p>Reverses order of sequence elements in-place</p>
<p>Removes element from the set by its index</p>
<p>Removes all the elements from the set</p>
<p>Remove edge connecting two vertices</p>
<p>Remove all vertices and edges from the graph</p>
<p>Releases graph scanner.</p>
<p>Does look-up transformation. Elements of the source array (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table</p>
<p>Inserts sequence into tree with specified "parent" sequence. If parent is equal to frame (e.g. the most external contour), then added contour will have null pointer to parent.</p>
<p>Removes contour from tree (together with the contour children).</p>
<p>Normally, the function is not called directly. Instead, a simple macro CV_TURN_ON_IPL_COMPATIBILITY() is used that calls cvSetIPLAllocators and passes there pointers to IPL allocation functions. : </p><div class="fragment"><div class="line">...</div><div class="line">CV_TURN_ON_IPL_COMPATIBILITY()</div><div class="line">...</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_header</td><td>pointer to a function, creating IPL image header. </td></tr>
    <tr><td class="paramname">allocate_data</td><td>pointer to a function, allocating IPL image data. </td></tr>
    <tr><td class="paramname">deallocate</td><td>pointer to a function, deallocating IPL image. </td></tr>
    <tr><td class="paramname">create_roi</td><td>pointer to a function, creating IPL image ROI (i.e. Region of Interest). </td></tr>
    <tr><td class="paramname">clone_image</td><td>pointer to a function, cloning an IPL image.</td></tr>
  </table>
  </dd>
</dl>
<p>The function closes the file associated with the storage and releases all the temporary structures. It must be called after all I/O operations with the storage are finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Double pointer to the released file storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function starts writing a compound structure (collection) that can be a sequence or a map. After all the structure fields, which can be scalars or structures, are written, cvEndWriteStruct should be called. The function can be used to group some objects or to implement the write function for a some user object (see <a class="el" href="struct_cv_type_info.html" title="Type information. ">CvTypeInfo</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written structure. The structure can be accessed by this name when the storage is read. </td></tr>
    <tr><td class="paramname">struct_flags</td><td>A combination one of the following values:<ul>
<li><b>CV_NODE_SEQ</b> the written structure is a sequence (see discussion of CvFileStorage ), that is, its elements do not have a name.</li>
<li><b>CV_NODE_MAP</b> the written structure is a map (see discussion of CvFileStorage ), that is, all its elements have names. One and only one of the two above flags must be specified</li>
<li><b>CV_NODE_FLOW</b> the optional flag that makes sense only for YAML streams. It means that the structure is written as a flow (not as a block), which is more compact. It is recommended to use this flag for structures or arrays whose elements are all scalars. </li>
</ul>
</td></tr>
    <tr><td class="paramname">type_name</td><td>Optional parameter - the object type name. In case of XML it is written as a type_id attribute of the structure opening tag. In the case of YAML it is written after a colon following the structure name (see the example in CvFileStorage description). In case of JSON it is written as a name/value pair. Mainly it is used with user objects. When the storage is read, the encoded type name is used to determine the object type (see <a class="el" href="struct_cv_type_info.html" title="Type information. ">CvTypeInfo</a> and cvFindType ). </td></tr>
    <tr><td class="paramname">attributes</td><td>This parameter is not used in the current implementation</td></tr>
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvStartWriteStruct.</dd></dl>
<p>The function writes a single integer value (with or without a name) to the file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a single floating-point value (with or without a name) to file storage. Special values are encoded as follows: NaN (Not A Number) as .NaN, infinity as +.Inf or -.Inf.</p>
<p>The following example shows how to use the low-level writing functions to store custom structures, such as termination criteria, without registering a new type. : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> write_termcriteria( <a class="code" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs, <span class="keyword">const</span> <span class="keywordtype">char</span>* struct_name,</div><div class="line">                         <a class="code" href="struct_cv_term_criteria.html">CvTermCriteria</a>* termcrit )</div><div class="line">{</div><div class="line">    cvStartWriteStruct( fs, struct_name, CV_NODE_MAP, NULL, <a class="code" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0));</div><div class="line">    cvWriteComment( fs, <span class="stringliteral">&quot;termination criteria&quot;</span>, 1 ); <span class="comment">// just a description</span></div><div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_ITER )</div><div class="line">        cvWriteInteger( fs, <span class="stringliteral">&quot;max_iterations&quot;</span>, termcrit-&gt;max_iter );</div><div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_EPS )</div><div class="line">        cvWriteReal( fs, <span class="stringliteral">&quot;accuracy&quot;</span>, termcrit-&gt;epsilon );</div><div class="line">    cvEndWriteStruct( fs );</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a text string to file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written string . Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">str</td><td>The written text string </td></tr>
    <tr><td class="paramname">quote</td><td>If non-zero, the written string is put in quotes, regardless of whether they are required. Otherwise, if the flag is zero, quotes are used only when they are required (e.g. when the string starts with a digit or contains spaces).</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a comment into file storage. The comments are skipped when the storage is read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">comment</td><td>The written comment, single-line or multi-line </td></tr>
    <tr><td class="paramname">eol_comment</td><td>If non-zero, the function tries to put the comment at the end of current line. If the flag is zero, if the comment is multi-line, or if it does not fit at the end of the current line, the comment starts a new line.</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an object to file storage. First, the appropriate type info is found using cvTypeOf. Then, the write method associated with the type info is called.</p>
<p>Attributes are used to customize the writing procedure. The standard types support the following attributes (all the dt attributes have the same format as in cvWriteRawData):</p>
<ol type="1">
<li><a class="el" href="struct_cv_seq.html">CvSeq</a><ul>
<li><b>header_dt</b> description of user fields of the sequence header that follow <a class="el" href="struct_cv_seq.html">CvSeq</a>, or <a class="el" href="struct_cv_chain.html">CvChain</a> (if the sequence is a Freeman chain) or <a class="el" href="struct_cv_contour.html">CvContour</a> (if the sequence is a contour or point sequence)</li>
<li><b>dt</b> description of the sequence elements.</li>
<li><b>recursive</b> if the attribute is present and is not equal to "0" or "false", the whole tree of sequences (contours) is stored.</li>
</ul>
</li>
<li><a class="el" href="struct_cv_graph.html">CvGraph</a><ul>
<li><b>header_dt</b> description of user fields of the graph header that follows <a class="el" href="struct_cv_graph.html">CvGraph</a>;</li>
<li><b>vertex_dt</b> description of user fields of graph vertices</li>
<li><b>edge_dt</b> description of user fields of graph edges (note that the edge weight is always written, so there is no need to specify it explicitly)</li>
</ul>
</li>
</ol>
<p>Below is the code that creates the YAML file shown in the CvFileStorage description: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cxcore.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div><div class="line">{</div><div class="line">    <a class="code" href="struct_cv_mat.html">CvMat</a>* mat = cvCreateMat( 3, 3, CV_32F );</div><div class="line">    <a class="code" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs = cvOpenFileStorage( <span class="stringliteral">&quot;example.yml&quot;</span>, 0, CV_STORAGE_WRITE );</div><div class="line"></div><div class="line">    cvSetIdentity( mat );</div><div class="line">    cvWrite( fs, <span class="stringliteral">&quot;A&quot;</span>, mat, <a class="code" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0) );</div><div class="line"></div><div class="line">    cvReleaseFileStorage( &amp;fs );</div><div class="line">    cvReleaseMat( &amp;mat );</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written object. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the object </td></tr>
    <tr><td class="paramname">attributes</td><td>The attributes of the object. They are specific for each particular type (see the discussion below).</td></tr>
  </table>
  </dd>
</dl>
<p>The function finishes the currently written stream and starts the next stream. In the case of XML the file with multiple streams looks like this: </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line"><span class="comment">&lt;!-- stream #1 data --&gt;</span></div><div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line"><span class="comment">&lt;!-- stream #2 data --&gt;</span></div><div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line">...</div></div><!-- fragment --><p> The YAML file will look like this: </p><div class="fragment"><div class="line">%YAML 1.0</div><div class="line"># stream #1 data</div><div class="line">...</div><div class="line">---</div><div class="line"># stream #2 data</div></div><!-- fragment --><p> This is useful for concatenating files or for resuming the writing process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an array, whose elements consist of single or multiple numbers. The function call can be replaced with a loop containing a few cvWriteInt and cvWriteReal calls, but a single call is more efficient. Note that because none of the elements have a name, they should be written to a sequence rather than a map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the written array </td></tr>
    <tr><td class="paramname">len</td><td>Number of the array elements to write </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element, see <a class="el" href="group__core__xml.html#format_spec">format specification</a></td></tr>
  </table>
  </dd>
</dl>
<p>If either CV_STORAGE_WRITE_BASE64 or <a class="el" href="classcv_1_1_file_storage.html#a973e41cb75ef6230412a567723b7482da74cdcbdb96c29f19e3ccc2ba4ab81614" title="flag, enable both WRITE and BASE64 ">cv::FileStorage::WRITE_BASE64</a> is used, this function will be the same as cvWriteRawData. If neither, the main difference is that it outputs a sequence in Base64 encoding rather than in plain text.</p>
<p>This function can only be used to write a sequence with a type "binary".</p>
<p>Consider the following two examples where their output is the same: </p><div class="fragment"></div><!-- fragment --><p>and </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the written array </td></tr>
    <tr><td class="paramname">len</td><td>Number of the array elements to write </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element, see <a class="el" href="group__core__xml.html#format_spec">format specification</a></td></tr>
  </table>
  </dd>
</dl>
<p>The function initializes the sequence reader to read data from a file node. The initialized reader can be then passed to cvReadRawDataSlice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">reader</td><td>Pointer to the sequence reader</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads one or more elements from the file node, representing a sequence, to a user-specified array. The total number of read sequence elements is a product of total and the number of components in each array element. For example, if dt=2if, the function will read total*3 sequence elements. As with any sequence, some parts of the file node sequence can be skipped or read repeatedly by repositioning the reader using cvSetSeqReaderPos. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">reader</td><td>The sequence reader. Initialize it with cvStartReadRawData . </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to read </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads elements from a file node that represents a sequence of scalars. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a copy of a file node to file storage. Possible applications of the function are merging several file storages into one and conversion between XML, YAML and JSON formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Destination file storage </td></tr>
    <tr><td class="paramname">new_node_name</td><td>New name of the file node in the destination file storage. To keep the existing name, use cvcvGetFileNodeName </td></tr>
    <tr><td class="paramname">node</td><td>The written node </td></tr>
    <tr><td class="paramname">embed</td><td>If the written node is a collection and this parameter is not zero, no extra level of hierarchy is created. Instead, all the elements of node are written into the currently written structure. Of course, map elements can only be embedded into another map, and sequence elements can only be embedded into another sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>The function registers a new type, which is described by info . The function creates a copy of the structure, so the user should delete it after calling the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Type info structure</td></tr>
  </table>
  </dd>
</dl>
<p>The function unregisters a type with a specified name. If the name is unknown, it is possible to locate the type info by an instance of the type using cvTypeOf or by iterating the type list, starting from cvFirstType, and then calling cvUnregisterType(info-&gt;typeName). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>Name of an unregistered type</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds the type of a given object and calls release with the double pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_ptr</td><td>Double pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<p>The function saves an object to a file. It provides a simple interface to cvWrite . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File name </td></tr>
    <tr><td class="paramname">struct_ptr</td><td>Object to save </td></tr>
    <tr><td class="paramname">name</td><td>Optional object name. If it is NULL, the name will be formed from filename . </td></tr>
    <tr><td class="paramname">comment</td><td>Optional comment to put in the beginning of the file </td></tr>
    <tr><td class="paramname">attributes</td><td>Optional attributes passed to cvWrite</td></tr>
  </table>
  </dd>
</dl>
<p>Sets error status silently</p>
<p>Sets error status and performs some additonal actions (displaying message box, writing message to stderr, terminating application etc.) depending on the current error mode</p>
<dl class="section see"><dt>See also</dt><dd>cv::accumulateSquare</dd>
<dd>
cv::accumulateProduct</dd>
<dd>
cv::accumulateWeighted</dd></dl>
<p>Copies source 2D array inside of the larger destination array and makes a border of the specified type (IPL_BORDER_*) around the copied area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source image </td></tr>
    <tr><td class="paramname">dst</td><td>The destination image </td></tr>
    <tr><td class="paramname">smoothtype</td><td>Type of the smoothing, see SmoothMethod_c </td></tr>
    <tr><td class="paramname">size1</td><td>The first parameter of the smoothing operation, the aperture width. Must be a positive odd number (1, 3, 5, ...) </td></tr>
    <tr><td class="paramname">size2</td><td>The second parameter of the smoothing operation, the aperture height. Ignored by CV_MEDIAN and CV_BILATERAL methods. In the case of simple scaled/non-scaled and Gaussian blur if size2 is zero, it is set to size1. Otherwise it must be a positive odd number. </td></tr>
    <tr><td class="paramname">sigma1</td><td>In the case of a Gaussian parameter this parameter may specify Gaussian <img class="formulaInl" alt="$\sigma$" src="form_336.png"/> (standard deviation). If it is zero, it is calculated from the kernel size: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\sigma = 0.3 (n/2 - 1) + 0.8 \quad \text{where} \quad n= \begin{array}{l l} \mbox{\texttt{size1} for horizontal kernel} \\ \mbox{\texttt{size2} for vertical kernel} \end{array}\]" src="form_337.png"/>
</p>
 Using standard sigma for small kernels ( <img class="formulaInl" alt="$3\times 3$" src="form_338.png"/> to <img class="formulaInl" alt="$7\times 7$" src="form_339.png"/> ) gives better speed. If sigma1 is not zero, while size1 and size2 are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation). </td></tr>
    <tr><td class="paramname">sigma2</td><td>additional parameter for bilateral filtering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::GaussianBlur, cv::blur, cv::medianBlur, cv::bilateralFilter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input image. </td></tr>
    <tr><td class="paramname">dst</td><td>output image of the same size and the same number of channels as src. </td></tr>
    <tr><td class="paramname">kernel</td><td>convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. </td></tr>
    <tr><td class="paramname">anchor</td><td>anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::filter2D</dd>
<dd>
cv::integral</dd></dl>
<p>dst_width = floor(src_width/2)[+1], dst_height = floor(src_height/2)[+1] </p><dl class="section see"><dt>See also</dt><dd>cv::pyrDown</dd></dl>
<p>dst_width = src_width*2, dst_height = src_height*2 </p><dl class="section see"><dt>See also</dt><dd>cv::pyrUp</dd>
<dd>
cv::pyrMeanShiftFiltering</dd>
<dd>
cv::watershed</dd></dl>
<p>(aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator. Scharr can be used only for the first dx or dy derivative </p><dl class="section see"><dt>See also</dt><dd>cv::Sobel</dd>
<dd>
cv::Laplacian</dd>
<dd>
cv::cvtColor</dd>
<dd>
cv::resize</dd></dl>
<dl class="section note"><dt>Note</dt><dd>::cvGetQuadrangleSubPix is similar to ::cvWarpAffine, but the outliers are extrapolated using replication border mode. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>cv::warpAffine</dd>
<dd>
cv::warpPerspective</dd>
<dd>
cv::remap</dd>
<dd>
cv::convertMaps</dd>
<dd>
cv::logPolar</dd></dl>
<p>Performs forward or inverse linear-polar image transform </p><dl class="section see"><dt>See also</dt><dd>cv::linearPolar</dd>
<dd>
cv::undistort</dd>
<dd>
cv::initUndistortRectifyMap</dd>
<dd>
cv::undistortPoints</dd>
<dd>
cvCreateStructuringElementEx</dd>
<dd>
cv::erode</dd></dl>
<p>If element pointer is NULL, 3x3 rectangular element is used </p><dl class="section see"><dt>See also</dt><dd>cv::dilate</dd>
<dd>
cv::morphologyEx</dd>
<dd>
cv::moments</dd>
<dd>
cv::HuMoments</dd></dl>
<p>dst(x,y) &lt;- src(x + center.x - dst_width/2, y + center.y - dst_height/2). Values of pixels with fractional coordinates are retrieved using bilinear interpolation </p><dl class="section see"><dt>See also</dt><dd>cv::getRectSubPix</dd></dl>
<p>matrixarr = ( a11 a12 | b1 ) dst(x,y) &lt;- src(A[x y]' + b) ( a21 a22 | b2 ) (bilinear interpolation is used to retrieve pixels with fractional coordinates) </p><dl class="section see"><dt>See also</dt><dd>cvWarpAffine</dd>
<dd>
cv::matchTemplate</dd></dl>
<p>(if the substitutor is null, the last retrieved contour is removed from the tree) </p><dl class="section see"><dt>See also</dt><dd>cvFindContours</dd></dl>
<p>The reader is used to iteratively get coordinates of all the chain points. If the Freeman codes should be read as is, a simple sequence reader should be used </p><dl class="section see"><dt>See also</dt><dd>cvApproxChains</dd></dl>
<p>This is a standalone function for setting bin ranges in the histogram. For a more detailed description of the parameters ranges and uniform, see the :ocvCalcHist function that can initialize the ranges as well. Ranges for the histogram bins must be set before the histogram is calculated or the backproject of the histogram is calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">ranges</td><td>Array of bin ranges arrays. See :ocvCreateHist for details. </td></tr>
    <tr><td class="paramname">uniform</td><td>Uniformity flag. See :ocvCreateHist for details.</td></tr>
  </table>
  </dd>
</dl>
<p>The function releases the histogram (header and the data). The pointer to the histogram is cleared by the function. If *hist pointer is already NULL, the function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Double pointer to the released histogram.</td></tr>
  </table>
  </dd>
</dl>
<p>The function sets all of the histogram bins to 0 in case of a dense histogram and removes all histogram bins in case of a sparse array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram.</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds the minimum and maximum histogram bins and their positions. All of output arguments are optional. Among several extremas with the same value the ones with the minimum index (in the lexicographical order) are returned. In case of several maximums or minimums, the earliest in the lexicographical order (extrema locations) is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">min_value</td><td>Pointer to the minimum value of the histogram. </td></tr>
    <tr><td class="paramname">max_value</td><td>Pointer to the maximum value of the histogram. </td></tr>
    <tr><td class="paramname">min_idx</td><td>Pointer to the array of coordinates for the minimum. </td></tr>
    <tr><td class="paramname">max_idx</td><td>Pointer to the array of coordinates for the maximum.</td></tr>
  </table>
  </dd>
</dl>
<p>The function normalizes the histogram bins by scaling them so that the sum of the bins becomes equal to factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Pointer to the histogram. </td></tr>
    <tr><td class="paramname">factor</td><td>Normalization factor.</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears histogram bins that are below the specified threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Pointer to the histogram. </td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold level.</td></tr>
  </table>
  </dd>
</dl>
<p>The function makes a copy of the histogram. If the second histogram pointer *dst is NULL, a new histogram of the same size as src is created. Otherwise, both histograms must have equal types and sizes. Then the function copies the bin values of the source histogram to the destination histogram and sets the same bin value ranges as in src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source histogram. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination histogram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::calcHist</dd>
<dd>
cvCalcBackProject, cv::calcBackProject</dd></dl>
<p>The function calculates the back projection by comparing histograms of the source image patches with the given histogram. The function is similar to matchTemplate, but instead of comparing the raster patch with all its possible positions within the search window, the function CalcBackProjectPatch compares histograms. See the algorithm diagram below:</p>
<div class="image">
<img src="pics/backprojectpatch.png" alt="image"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Source images (though, you may pass CvMat** as well). </td></tr>
    <tr><td class="paramname">dst</td><td>Destination image. </td></tr>
    <tr><td class="paramname">range</td><td></td></tr>
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">method</td><td>Comparison method passed to cvCompareHist (see the function description). </td></tr>
    <tr><td class="paramname">factor</td><td>Normalization factor for histograms that affects the normalization scale of the destination image. Pass 1 if not sure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvCalcBackProjectPatch</dd></dl>
<p>The function calculates the object probability density from two histograms as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{disthist} (I)= \forkthree{0}{if \(\texttt{hist1}(I)=0\)}{\texttt{scale}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) &gt; \texttt{hist1}(I)\)}{\frac{\texttt{hist2}(I) \cdot \texttt{scale}}{\texttt{hist1}(I)}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) \le \texttt{hist1}(I)\)}\]" src="form_344.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist1</td><td>First histogram (the divisor). </td></tr>
    <tr><td class="paramname">hist2</td><td>Second histogram. </td></tr>
    <tr><td class="paramname">dst_hist</td><td>Destination histogram. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor for the destination histogram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::equalizeHist</dd>
<dd>
cv::distanceTransform</dd></dl>
<p>The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and CV_ADAPTIVE_THRESH_GAUSSIAN_C are: neighborhood size (3, 5, 7 etc.), and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...) </p><dl class="section see"><dt>See also</dt><dd>cv::adaptiveThreshold</dd>
<dd>
cv::floodFill</dd>
<dd>
cv::Canny</dd></dl>
<p>Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy. Applying threshold to the result gives coordinates of corners </p><dl class="section see"><dt>See also</dt><dd>cv::preCornerDetect</dd>
<dd>
cv::cornerEigenValsAndVecs</dd>
<dd>
cv::cornerMinEigenVal</dd></dl>
<p>Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel </p><dl class="section see"><dt>See also</dt><dd>cv::cornerHarris</dd>
<dd>
cv::cornerSubPix</dd>
<dd>
cv::goodFeaturesToTrack</dd>
<dd>
cv::fitLine</dd>
<dd>
cv::line</dd></dl>
<p>if thickness&lt;0 (e.g. thickness == CV_FILLED), the filled box is drawn </p><dl class="section see"><dt>See also</dt><dd>cv::rectangle</dd>
<dd>
cv::rectangle</dd></dl>
<p>Thickness works in the same way as with cvRectangle </p><dl class="section see"><dt>See also</dt><dd>cv::circle</dd></dl>
<p>depending on <em>thickness</em>, <em>start_angle</em> and <em>end_angle</em> parameters. The resultant figure is rotated by <em>angle</em>. All the angles are in degrees </p><dl class="section see"><dt>See also</dt><dd>cv::ellipse</dd>
<dd>
cv::fillConvexPoly</dd>
<dd>
cv::fillPoly</dd>
<dd>
cv::polylines</dd></dl>
<p>The function initializes the font structure that can be passed to text rendering functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">font</td><td>Pointer to the font structure initialized by the function </td></tr>
    <tr><td class="paramname">font_face</td><td>Font name identifier. See cv::HersheyFonts and corresponding old CV_* identifiers. </td></tr>
    <tr><td class="paramname">hscale</td><td>Horizontal scale. If equal to 1.0f , the characters have the original width depending on the font type. If equal to 0.5f , the characters are of half the original width. </td></tr>
    <tr><td class="paramname">vscale</td><td>Vertical scale. If equal to 1.0f , the characters have the original height depending on the font type. If equal to 0.5f , the characters are of half the original height. </td></tr>
    <tr><td class="paramname">shear</td><td>Approximate tangent of the character slope relative to the vertical line. A zero value means a non-italic font, 1.0f means about a 45 degree slope, etc. </td></tr>
    <tr><td class="paramname">thickness</td><td>Thickness of the text strokes </td></tr>
    <tr><td class="paramname">line_type</td><td>Type of the strokes, see line description</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvPutText</dd>
<dd>
cvInitFont, cvGetTextSize, cvFont, cv::putText</dd>
<dd>
cv::getTextSize</dd>
<dd>
cv::drawContours </dd></dl>

</div>
</div>
<a id="gabb8fdd9692fb829c1356993a64892de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb8fdd9692fb829c1356993a64892de4">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_mat.html">CvMat</a> **&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds pyramid for an image. </p>
<dl class="section see"><dt>See also</dt><dd>buildPyramid </dd></dl>

</div>
</div>
<a id="gace04cf6f56c0ecd22389ec1ce48353e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace04cf6f56c0ecd22389ec1ce48353e3">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2) </p>
<p>Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)</p>
<p>Computes rotation_matrix matrix.</p>
<dl class="section see"><dt>See also</dt><dd>cv::getAffineTransform</dd>
<dd>
cv::getRotationMatrix2D</dd>
<dd>
cv::getPerspectiveTransform </dd></dl>

</div>
</div>
<a id="gae5f6b6ab285bd56be34dc13f8865c3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5f6b6ab285bd56be34dc13f8865c3a6">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dot product of two arrays in Euclidean metrics. </p>
<p>Applies fixed-level threshold to grayscale image.</p>
<p>Checks whether the point is inside polygon, outside, on an edge (at a vertex).</p>
<p>Compares two contours by matching their moments.</p>
<p>Calculates area of a contour or contour segment.</p>
<p>Calculates perimeter of a contour or length of a part of contour.</p>
<p>Retrieve normalized central moments.</p>
<p>Retrieve central moments.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array. Must have a single channel. </td></tr>
    <tr><td class="paramname">idx</td><td>Array of the element indices</td></tr>
  </table>
  </dd>
</dl>
<p>The function calculates and returns the Euclidean dot product of two arrays.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[src1 \bullet src2 = \sum _I ( \texttt{src1} (I) \texttt{src2} (I))\]" src="form_161.png"/>
</p>
<p>In the case of multiple channel arrays, the results for all channels are accumulated. In particular, cvDotProduct(a,a) where a is a complex vector, will return <img class="formulaInl" alt="$||\texttt{a}||^2$" src="form_162.png"/>. The function can process multi-dimensional arrays, row by row, layer by layer, and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>The first source array </td></tr>
    <tr><td class="paramname">src2</td><td>The second source array</td></tr>
  </table>
  </dd>
</dl>
<p>Inverts matrix</p>
<p>Calculates determinant of input matrix</p>
<p>Calculates Mahalanobis(weighted) distance</p>
<p>Finds norm, difference norm or relative difference norm for an array (or two arrays) </p><dl class="section see"><dt>See also</dt><dd>ref core_c_NormFlags "flags"</dd>
<dd>
cv::arcLength</dd>
<dd>
cv::contourArea</dd>
<dd>
cv::matchShapes</dd></dl>
<p>Returns positive, negative or zero value, correspondingly. Optionally, measures a signed distance between the point and the nearest polygon edge (measure_dist=1) </p><dl class="section see"><dt>See also</dt><dd>cv::pointPolygonTest</dd></dl>
<p>Compares two histogram</p>
<p>This is a basic operation applied before retrieving contours </p><dl class="section see"><dt>See also</dt><dd>cv::threshold </dd></dl>

</div>
</div>
<a id="ga0442042ffad7f6f7d236c3800f838f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0442042ffad7f6f7d236c3800f838f82">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct___ipl_conv_kernel.html">IplConvKernel</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a structuring element of the specified size and shape for morphological operations. </p>
<dl class="section note"><dt>Note</dt><dd>the created structuring element IplConvKernel* element must be released in the end using <code>cvReleaseStructuringElement(&amp;element)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cols</td><td>Width of the structuring element </td></tr>
    <tr><td class="paramname">rows</td><td>Height of the structuring element </td></tr>
    <tr><td class="paramname">anchor_x</td><td>x-coordinate of the anchor </td></tr>
    <tr><td class="paramname">anchor_y</td><td>y-coordinate of the anchor </td></tr>
    <tr><td class="paramname">shape</td><td>element shape that could be one of the cv::MorphShapes_c </td></tr>
    <tr><td class="paramname">values</td><td>integer array of cols*rows elements that specifies the custom shape of the structuring element, when shape=CV_SHAPE_CUSTOM.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::getStructuringElement </dd></dl>

</div>
</div>
<a id="gac287d5e2dafc42c35cd87987c3d927e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac287d5e2dafc42c35cd87987c3d927e2">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve spatial moments. </p>
<p>Applies fixed-level threshold to grayscale image.</p>
<p>Checks whether the point is inside polygon, outside, on an edge (at a vertex).</p>
<p>Compares two contours by matching their moments.</p>
<p>Calculates area of a contour or contour segment.</p>
<p>Calculates perimeter of a contour or length of a part of contour.</p>
<p>Retrieve normalized central moments.</p>
<p>Retrieve central moments.</p>
<dl class="section see"><dt>See also</dt><dd>cv::arcLength</dd>
<dd>
cv::contourArea</dd>
<dd>
cv::matchShapes</dd></dl>
<p>Returns positive, negative or zero value, correspondingly. Optionally, measures a signed distance between the point and the nearest polygon edge (measure_dist=1) </p><dl class="section see"><dt>See also</dt><dd>cv::pointPolygonTest</dd></dl>
<p>Compares two histogram</p>
<p>This is a basic operation applied before retrieving contours </p><dl class="section see"><dt>See also</dt><dd>cv::threshold </dd></dl>

</div>
</div>
<a id="gad555d588024aee765c372989bb171070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad555d588024aee765c372989bb171070">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches pixels that belong to the specified line segment and stores them to the buffer. </p>
<p>Returns the polygon points which make up the given ellipse.</p>
<p>Initializes line iterator.</p>
<p>Clips the line segment connecting *pt1 and *pt2 by the rectangular window.</p>
<p>Checks whether the contour is convex or not (returns 1 if convex, 0 if not)</p>
<p>Finds minimum enclosing circle for a set of points.</p>
<p>Retrieves outer and optionally inner boundaries of white (non-zero) connected components in the black (zero) background.</p>
<p>Returns the number of retrieved points. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcv_1_1_line_segment_detector.html" title="Line segment detector class. ">cv::LineSegmentDetector</a></dd>
<dd>
cv::findContours, cvStartFindContours, cvFindNextContour, cvSubstituteContour, cvEndFindContours</dd>
<dd>
cv::minEnclosingCircle</dd>
<dd>
cv::isContourConvex</dd></dl>
<p>(0&lt;=x&lt;img_size.width, 0&lt;=y&lt;img_size.height). </p><dl class="section see"><dt>See also</dt><dd>cv::clipLine</dd></dl>
<p>Initially, line_iterator-&gt;ptr will point to pt1 (or pt2, see left_to_right description) location in the image. Returns the number of pixels on the line between the ending points. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcv_1_1_line_iterator.html" title="Line iterator. ">cv::LineIterator</a></dd></dl>
<p>The ellipse is define by the box of size 'axes' rotated 'angle' around the 'center'. A partial sweep of the ellipse arc can be done by spcifying arc_start and arc_end to be something other than 0 and 360, respectively. The input array 'pts' must be large enough to hold the result. The total number of points stored into 'pts' is returned by this function. </p><dl class="section see"><dt>See also</dt><dd>cv::ellipse2Poly </dd></dl>

</div>
</div>
<a id="gaee1da947bf9b837289044138e7d3e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1da947bf9b837289044138e7d3e987">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes earth mover distance between two weighted point sets (called signatures) </p>
<dl class="section see"><dt>See also</dt><dd>cv::EMD </dd></dl>

</div>
</div>
<a id="gaa7d53c44495eec732e4234ff6c5520c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7d53c44495eec732e4234ff6c5520c5">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">CvContourScanner&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes contour retrieving process. </p>
<p>Calls cvStartFindContours. Calls cvFindNextContour until null pointer is returned or some other condition becomes true. Calls cvEndFindContours at the end. </p><dl class="section see"><dt>See also</dt><dd>cvFindContours </dd></dl>

</div>
</div>
<a id="gaf3a507106d740ffc41fffe687f5425a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a507106d740ffc41fffe687f5425a9">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_seq.html">CvSeq</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves next contour. </p>
<p>Finds circles in the image.</p>
<p>Finds lines on binary image using one of several methods.</p>
<p>Initializes sequence header for a matrix (column or row vector) of points.</p>
<p>Finds convexity defects for the contour.</p>
<p>Calculates exact convex hull of 2d point set.</p>
<p>Approximates a single polygonal curve (contour) or a tree of polygonal curves (contours)</p>
<p>Approximates Freeman chain(s) with a polygonal curve.</p>
<p>Releases contour scanner and returns pointer to the first outer contour.</p>
<dl class="section see"><dt>See also</dt><dd>cvFindContours</dd></dl>
<p>This is a standalone contour approximation routine, not represented in the new interface. When cvFindContours retrieves contours as Freeman chains, it calls the function to get approximated contours, represented as polygons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_seq</td><td>Pointer to the approximated Freeman chain that can refer to other chains. </td></tr>
    <tr><td class="paramname">storage</td><td>Storage location for the resulting polylines. </td></tr>
    <tr><td class="paramname">method</td><td>Approximation method (see the description of the function :ocvFindContours ). </td></tr>
    <tr><td class="paramname">parameter</td><td>Method parameter (not used now). </td></tr>
    <tr><td class="paramname">minimal_perimeter</td><td>Approximates only those contours whose perimeters are not less than minimal_perimeter . Other chains are removed from the resulting structure. </td></tr>
    <tr><td class="paramname">recursive</td><td>Recursion flag. If it is non-zero, the function approximates all chains that can be obtained from chain by using the h_next or v_next links. Otherwise, the single input chain is approximated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvStartReadChainPoints, cvReadChainPoint</dd>
<dd>
cv::approxPolyDP</dd>
<dd>
cv::convexHull</dd>
<dd>
cv::convexityDefects</dd></dl>
<p>a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!)</p>
<p>line_storage is either memory storage or 1 x <em>max number of lines</em> <a class="el" href="struct_cv_mat.html">CvMat</a>, its number of columns is changed by the function. method is one of CV_HOUGH_*; rho, theta and threshold are used for each of those methods; param1 ~ line length, param2 ~ line gap - for probabilistic, param1 ~ srn, param2 ~ stn - for multi-scale </p><dl class="section see"><dt>See also</dt><dd>cv::HoughLines</dd>
<dd>
cv::HoughCircles </dd></dl>

</div>
</div>
<a id="ga9c416bbc47675aeb7899785b68d40f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c416bbc47675aeb7899785b68d40f41">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the next chain point. </p>
<dl class="section see"><dt>See also</dt><dd>cvApproxChains </dd></dl>

</div>
</div>
<a id="ga33b978364ca82684500a76cb94fa4858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33b978364ca82684500a76cb94fa4858">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_rect.html">CvRect</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates contour bounding rectangle (update=1) or just retrieves pre-calculated rectangle (update=0) </p>
<p>Finds minimum rectangle containing two given rectangles.</p>
<dl class="section see"><dt>See also</dt><dd>cv::boundingRect </dd></dl>

</div>
</div>
<a id="ga8df99dca7ee28666131ae7f179902402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8df99dca7ee28666131ae7f179902402">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_box2_d.html">CvBox2D</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds minimum area rotated rectangle bounding a set of points. </p>
<p>Fits ellipse into a set of 2d points.</p>
<dl class="section see"><dt>See also</dt><dd>cv::minAreaRect</dd>
<dd>
cv::fitEllipse </dd></dl>

</div>
</div>
<a id="ga350083876719f90933fb55a534cf8abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga350083876719f90933fb55a534cf8abd">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_histogram.html">CvHistogram</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a histogram. </p>
<p>Makes a histogram out of an array.</p>
<p>The function creates a histogram of the specified size and returns a pointer to the created histogram. If the array ranges is 0, the histogram bin ranges must be specified later via the function cvSetHistBinRanges. Though cvCalcHist and cvCalcBackProject may process 8-bit images without setting bin ranges, they assume they are equally spaced in 0 to 255 bins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Number of histogram dimensions. </td></tr>
    <tr><td class="paramname">sizes</td><td>Array of the histogram dimension sizes. </td></tr>
    <tr><td class="paramname">type</td><td>Histogram representation format. CV_HIST_ARRAY means that the histogram data is represented as a multi-dimensional dense array <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a>. CV_HIST_SPARSE means that histogram data is represented as a multi-dimensional sparse array <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a>. </td></tr>
    <tr><td class="paramname">ranges</td><td>Array of ranges for the histogram bins. Its meaning depends on the uniform parameter value. The ranges are used when the histogram is calculated or backprojected to determine which histogram bin corresponds to which value/tuple of values from the input image(s). </td></tr>
    <tr><td class="paramname">uniform</td><td>Uniformity flag. If not zero, the histogram has evenly spaced bins and for every <img class="formulaInl" alt="$0&lt;=i&lt;cDims$" src="form_340.png"/> ranges[i] is an array of two numbers: lower and upper boundaries for the i-th histogram dimension. The whole range [lower,upper] is then split into dims[i] equal parts to determine the i-th input tuple value ranges for every histogram bin. And if uniform=0 , then the i-th element of the ranges array contains dims[i]+1 elements: <img class="formulaInl" alt="$\texttt{lower}_0, \texttt{upper}_0, \texttt{lower}_1, \texttt{upper}_1 = \texttt{lower}_2, ... \texttt{upper}_{dims[i]-1}$" src="form_341.png"/> where <img class="formulaInl" alt="$\texttt{lower}_j$" src="form_342.png"/> and <img class="formulaInl" alt="$\texttt{upper}_j$" src="form_343.png"/> are lower and upper boundaries of the i-th input tuple value for the j-th bin, respectively. In either case, the input values that are beyond the specified range for a histogram bin are not counted by cvCalcHist and filled with 0 by cvCalcBackProject.</td></tr>
  </table>
  </dd>
</dl>
<p>The function initializes the histogram, whose header and bins are allocated by the user. cvReleaseHist does not need to be called afterwards. Only dense histograms can be initialized this way. The function returns hist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dims</td><td>Number of the histogram dimensions. </td></tr>
    <tr><td class="paramname">sizes</td><td>Array of the histogram dimension sizes. </td></tr>
    <tr><td class="paramname">hist</td><td>Histogram header initialized by the function. </td></tr>
    <tr><td class="paramname">data</td><td>Array used to store histogram bins. </td></tr>
    <tr><td class="paramname">ranges</td><td>Histogram bin ranges. See cvCreateHist for details. </td></tr>
    <tr><td class="paramname">uniform</td><td>Uniformity flag. See cvCreateHist for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85d2831a6803431357d3b9236ba9da7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85d2831a6803431357d3b9236ba9da7e">&#9670;&nbsp;</a></span>CVAPI() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cv_scalar.html">CvScalar</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks color value. </p>
<p>if arrtype is CV_8UC?, <em>color</em> is treated as packed color value, otherwise the first channels (depending on arrtype) of destination scalar are set to the same value = <em>color</em> </p>

</div>
</div>
<a id="ga6074ca64cb8410c90cf045a13a6f5d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6074ca64cb8410c90cf045a13a6f5d96">&#9670;&nbsp;</a></span>cvCalcHist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_INLINE void cvCalcHist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__c.html#ga249298f383f3b430b476542076320c57">IplImage</a> **&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_cv_histogram.html">CvHistogram</a> *&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int accumulate &#160;</td>
          <td class="paramname"><em>CV_DEFAULT</em>0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *mask &#160;</td>
          <td class="paramname"><em>CV_DEFAULT</em>NULL&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga1730af55940e59d9c9a51c689e58fdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1730af55940e59d9c9a51c689e58fdfb">&#9670;&nbsp;</a></span>cvContourPerimeter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_INLINE double cvContourPerimeter </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>contour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as cvArcLength for closed contour </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
