<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2018-inseason: OpenGL interoperability</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">2018-inseason
   </div>
   <div id="projectbrief">The Greybots&#39; 2018 Power Up code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenGL interoperability<div class="ingroups"><a class="el" href="group__core.html">Core functionality</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__cuda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cuda.html">CUDA-accelerated Computer Vision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1ogl_1_1_buffer.html">cv::ogl::Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for OpenGL buffer object with reference counting.  <a href="classcv_1_1ogl_1_1_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1ogl_1_1_texture2_d.html">cv::ogl::Texture2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer for OpenGL 2D texture memory with reference counting.  <a href="classcv_1_1ogl_1_1_texture2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1ogl_1_1_arrays.html">cv::ogl::Arrays</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for OpenGL Client-Side Vertex arrays.  <a href="classcv_1_1ogl_1_1_arrays.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga830568a629457171cb07918537ec66be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">cv::ogl::Buffer::Target</a> { <a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">cv::ogl::Buffer::ARRAY_BUFFER</a> = 0x8892, 
<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66beae86acf739ab6ec3ccdc40db15366f672">cv::ogl::Buffer::ELEMENT_ARRAY_BUFFER</a> = 0x8893, 
<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea04aec232cc3ac3070953ba669bee3a3a">cv::ogl::Buffer::PIXEL_PACK_BUFFER</a> = 0x88EB, 
<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea882899bdc22e1c13618c294343d4d9dc">cv::ogl::Buffer::PIXEL_UNPACK_BUFFER</a> = 0x88EC
 }</td></tr>
<tr class="memdesc:ga830568a629457171cb07918537ec66be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target defines how you intend to use the buffer object.  <a href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">More...</a><br /></td></tr>
<tr class="separator:ga830568a629457171cb07918537ec66be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2a295dc840db8b6728db2f3a439d6e"><td class="memItemLeft" align="right" valign="top"><a id="ga6b2a295dc840db8b6728db2f3a439d6e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Access</b> { <b>READ_ONLY</b> = 0x88B8, 
<b>WRITE_ONLY</b> = 0x88B9, 
<b>READ_WRITE</b> = 0x88BA
 }</td></tr>
<tr class="separator:ga6b2a295dc840db8b6728db2f3a439d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1838399ee67c0957c0ae42cabfa99033"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">cv::ogl::Texture2D::Format</a> { <b>NONE</b> = 0, 
<a class="el" href="group__core__opengl.html#gga1838399ee67c0957c0ae42cabfa99033ad97d2f204bb7e38b03b74ea3a8129cdb">cv::ogl::Texture2D::DEPTH_COMPONENT</a> = 0x1902, 
<a class="el" href="group__core__opengl.html#gga1838399ee67c0957c0ae42cabfa99033a1c819f641291e88d67ab432f67023a17">cv::ogl::Texture2D::RGB</a> = 0x1907, 
<a class="el" href="group__core__opengl.html#gga1838399ee67c0957c0ae42cabfa99033ab30fb919ec618eaa81c28235e568ef20">cv::ogl::Texture2D::RGBA</a> = 0x1908
 }</td></tr>
<tr class="memdesc:ga1838399ee67c0957c0ae42cabfa99033"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Image Format describes the way that the images in Textures store their data.  <a href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">More...</a><br /></td></tr>
<tr class="separator:ga1838399ee67c0957c0ae42cabfa99033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53526c205a92260f356fe6589460aab"><td class="memItemLeft" align="right" valign="top"><a id="gaf53526c205a92260f356fe6589460aab"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaf53526c205a92260f356fe6589460aab">cv::ogl::RenderModes</a> { <br />
&#160;&#160;<b>POINTS</b> = 0x0000, 
<b>LINES</b> = 0x0001, 
<b>LINE_LOOP</b> = 0x0002, 
<b>LINE_STRIP</b> = 0x0003, 
<br />
&#160;&#160;<b>TRIANGLES</b> = 0x0004, 
<b>TRIANGLE_STRIP</b> = 0x0005, 
<b>TRIANGLE_FAN</b> = 0x0006, 
<b>QUADS</b> = 0x0007, 
<br />
&#160;&#160;<b>QUAD_STRIP</b> = 0x0008, 
<b>POLYGON</b> = 0x0009
<br />
 }</td></tr>
<tr class="memdesc:gaf53526c205a92260f356fe6589460aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">render mode <br /></td></tr>
<tr class="separator:gaf53526c205a92260f356fe6589460aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf53dfd844f101cc0ba752bf6791890ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaf53dfd844f101cc0ba752bf6791890ac">cv::ogl::Buffer::Buffer</a> ()</td></tr>
<tr class="memdesc:gaf53dfd844f101cc0ba752bf6791890ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructors.  <a href="#gaf53dfd844f101cc0ba752bf6791890ac">More...</a><br /></td></tr>
<tr class="separator:gaf53dfd844f101cc0ba752bf6791890ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a62127a1690d9d2244463c88b0c200"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga94a62127a1690d9d2244463c88b0c200">cv::ogl::Buffer::Buffer</a> (int arows, int acols, int atype, unsigned int abufId, bool autoRelease=false)</td></tr>
<tr class="separator:ga94a62127a1690d9d2244463c88b0c200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1598ae7fd0b6f35dee834b8cc6b0e73e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga1598ae7fd0b6f35dee834b8cc6b0e73e">cv::ogl::Buffer::Buffer</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> asize, int atype, unsigned int abufId, bool autoRelease=false)</td></tr>
<tr class="separator:ga1598ae7fd0b6f35dee834b8cc6b0e73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb20e60d0a89372f7403c04fcb5444ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gafb20e60d0a89372f7403c04fcb5444ba">cv::ogl::Buffer::Buffer</a> (int arows, int acols, int atype, <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false)</td></tr>
<tr class="separator:gafb20e60d0a89372f7403c04fcb5444ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf981734a0b35b9bebf48b1edb65291b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaf981734a0b35b9bebf48b1edb65291b8">cv::ogl::Buffer::Buffer</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> asize, int atype, <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false)</td></tr>
<tr class="separator:gaf981734a0b35b9bebf48b1edb65291b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fce522179bc8984c50a3c8b3de3554c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga7fce522179bc8984c50a3c8b3de3554c">cv::ogl::Buffer::Buffer</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> arr, <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false)</td></tr>
<tr class="separator:ga7fce522179bc8984c50a3c8b3de3554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b9eb33a14f929c8554b4444198a1550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga1b9eb33a14f929c8554b4444198a1550">cv::ogl::Buffer::create</a> (int arows, int acols, int atype, <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false)</td></tr>
<tr class="memdesc:ga1b9eb33a14f929c8554b4444198a1550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> object.  <a href="#ga1b9eb33a14f929c8554b4444198a1550">More...</a><br /></td></tr>
<tr class="separator:ga1b9eb33a14f929c8554b4444198a1550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff29b1f3609d41cc350e5d407ddb9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga1ff29b1f3609d41cc350e5d407ddb9b1">cv::ogl::Buffer::create</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> asize, int atype, <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false)</td></tr>
<tr class="separator:ga1ff29b1f3609d41cc350e5d407ddb9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae8efb43bb0ece5deffc68308bb70b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaae8efb43bb0ece5deffc68308bb70b53">cv::ogl::Buffer::release</a> ()</td></tr>
<tr class="memdesc:gaae8efb43bb0ece5deffc68308bb70b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference counter and destroys the buffer object if needed.  <a href="#gaae8efb43bb0ece5deffc68308bb70b53">More...</a><br /></td></tr>
<tr class="separator:gaae8efb43bb0ece5deffc68308bb70b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff9abd9111dfb14686a788eaaa94770a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaff9abd9111dfb14686a788eaaa94770a">cv::ogl::Buffer::setAutoRelease</a> (bool flag)</td></tr>
<tr class="memdesc:gaff9abd9111dfb14686a788eaaa94770a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets auto release mode.  <a href="#gaff9abd9111dfb14686a788eaaa94770a">More...</a><br /></td></tr>
<tr class="separator:gaff9abd9111dfb14686a788eaaa94770a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac4c20b821703eba30e68e3bba511a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gadac4c20b821703eba30e68e3bba511a4">cv::ogl::Buffer::copyFrom</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> arr, <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false)</td></tr>
<tr class="memdesc:gadac4c20b821703eba30e68e3bba511a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from host/device memory to OpenGL buffer.  <a href="#gadac4c20b821703eba30e68e3bba511a4">More...</a><br /></td></tr>
<tr class="separator:gadac4c20b821703eba30e68e3bba511a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a8b9910ae4f914faa7ad740e3d084f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gae9a8b9910ae4f914faa7ad740e3d084f">cv::ogl::Buffer::copyFrom</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> arr, <a class="el" href="classcv_1_1cuda_1_1_stream.html">cuda::Stream</a> &amp;stream, <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false)</td></tr>
<tr class="separator:gae9a8b9910ae4f914faa7ad740e3d084f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aab3acc565ead059f4da0efb943db0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga3aab3acc565ead059f4da0efb943db0a">cv::ogl::Buffer::copyTo</a> (<a class="el" href="classcv_1_1___output_array.html">OutputArray</a> arr) const</td></tr>
<tr class="memdesc:ga3aab3acc565ead059f4da0efb943db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from OpenGL buffer to host/device memory or another OpenGL buffer object.  <a href="#ga3aab3acc565ead059f4da0efb943db0a">More...</a><br /></td></tr>
<tr class="separator:ga3aab3acc565ead059f4da0efb943db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563a63b77bd1c01b1bed7ea7740391c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga563a63b77bd1c01b1bed7ea7740391c1">cv::ogl::Buffer::copyTo</a> (<a class="el" href="classcv_1_1___output_array.html">OutputArray</a> arr, <a class="el" href="classcv_1_1cuda_1_1_stream.html">cuda::Stream</a> &amp;stream) const</td></tr>
<tr class="separator:ga563a63b77bd1c01b1bed7ea7740391c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c8b81f03de2d386bce302ccd9bd431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1ogl_1_1_buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaa0c8b81f03de2d386bce302ccd9bd431">cv::ogl::Buffer::clone</a> (<a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target=<a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a>, bool autoRelease=false) const</td></tr>
<tr class="memdesc:gaa0c8b81f03de2d386bce302ccd9bd431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a full copy of the buffer object and the underlying data.  <a href="#gaa0c8b81f03de2d386bce302ccd9bd431">More...</a><br /></td></tr>
<tr class="separator:gaa0c8b81f03de2d386bce302ccd9bd431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40fd03c02f051f780f518acb6cd9b407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga40fd03c02f051f780f518acb6cd9b407">cv::ogl::Buffer::bind</a> (<a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target) const</td></tr>
<tr class="memdesc:ga40fd03c02f051f780f518acb6cd9b407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds OpenGL buffer to the specified buffer binding point.  <a href="#ga40fd03c02f051f780f518acb6cd9b407">More...</a><br /></td></tr>
<tr class="separator:ga40fd03c02f051f780f518acb6cd9b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b3599430d2e7938997a8911b1d9408"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga89b3599430d2e7938997a8911b1d9408">cv::ogl::Buffer::unbind</a> (<a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a> target)</td></tr>
<tr class="memdesc:ga89b3599430d2e7938997a8911b1d9408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind any buffers from the specified binding point.  <a href="#ga89b3599430d2e7938997a8911b1d9408">More...</a><br /></td></tr>
<tr class="separator:ga89b3599430d2e7938997a8911b1d9408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e14b8b56c501c5c90c79aca9c744d18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga3e14b8b56c501c5c90c79aca9c744d18">cv::ogl::Buffer::mapHost</a> (Access access)</td></tr>
<tr class="memdesc:ga3e14b8b56c501c5c90c79aca9c744d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps OpenGL buffer to host memory.  <a href="#ga3e14b8b56c501c5c90c79aca9c744d18">More...</a><br /></td></tr>
<tr class="separator:ga3e14b8b56c501c5c90c79aca9c744d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c5bdbf910b69d20773ac1228c2daf9"><td class="memItemLeft" align="right" valign="top"><a id="ga86c5bdbf910b69d20773ac1228c2daf9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga86c5bdbf910b69d20773ac1228c2daf9">cv::ogl::Buffer::unmapHost</a> ()</td></tr>
<tr class="memdesc:ga86c5bdbf910b69d20773ac1228c2daf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps OpenGL buffer. <br /></td></tr>
<tr class="separator:ga86c5bdbf910b69d20773ac1228c2daf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57864bec2d9dbef4edf25ea018db71d9"><td class="memItemLeft" align="right" valign="top"><a id="ga57864bec2d9dbef4edf25ea018db71d9"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">cuda::GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga57864bec2d9dbef4edf25ea018db71d9">cv::ogl::Buffer::mapDevice</a> ()</td></tr>
<tr class="memdesc:ga57864bec2d9dbef4edf25ea018db71d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">map to device memory (blocking) <br /></td></tr>
<tr class="separator:ga57864bec2d9dbef4edf25ea018db71d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf37f57379ac901a5dd661c47f074bb"><td class="memItemLeft" align="right" valign="top"><a id="ga8cf37f57379ac901a5dd661c47f074bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::unmapDevice</b> ()</td></tr>
<tr class="separator:ga8cf37f57379ac901a5dd661c47f074bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde1b6c518abefeee7cf878b066c65fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">cuda::GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gabde1b6c518abefeee7cf878b066c65fb">cv::ogl::Buffer::mapDevice</a> (<a class="el" href="classcv_1_1cuda_1_1_stream.html">cuda::Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:gabde1b6c518abefeee7cf878b066c65fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps OpenGL buffer to CUDA device memory.  <a href="#gabde1b6c518abefeee7cf878b066c65fb">More...</a><br /></td></tr>
<tr class="separator:gabde1b6c518abefeee7cf878b066c65fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f6eaf46283eed7e6e9d780419b772d"><td class="memItemLeft" align="right" valign="top"><a id="ga34f6eaf46283eed7e6e9d780419b772d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga34f6eaf46283eed7e6e9d780419b772d">cv::ogl::Buffer::unmapDevice</a> (<a class="el" href="classcv_1_1cuda_1_1_stream.html">cuda::Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:ga34f6eaf46283eed7e6e9d780419b772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps OpenGL buffer. <br /></td></tr>
<tr class="separator:ga34f6eaf46283eed7e6e9d780419b772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4545b1d1ae73330ea6c84d42cf8b459"><td class="memItemLeft" align="right" valign="top"><a id="gaa4545b1d1ae73330ea6c84d42cf8b459"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::rows</b> () const</td></tr>
<tr class="separator:gaa4545b1d1ae73330ea6c84d42cf8b459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fc0bec98329378bdc5303654da5238"><td class="memItemLeft" align="right" valign="top"><a id="ga66fc0bec98329378bdc5303654da5238"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::cols</b> () const</td></tr>
<tr class="separator:ga66fc0bec98329378bdc5303654da5238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf627f6025672dcd3f054667da63f6ae1"><td class="memItemLeft" align="right" valign="top"><a id="gaf627f6025672dcd3f054667da63f6ae1"></a>
<a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::size</b> () const</td></tr>
<tr class="separator:gaf627f6025672dcd3f054667da63f6ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72643c086e437ab3b9f45483ab9efb1d"><td class="memItemLeft" align="right" valign="top"><a id="ga72643c086e437ab3b9f45483ab9efb1d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::empty</b> () const</td></tr>
<tr class="separator:ga72643c086e437ab3b9f45483ab9efb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdbc4c711bfbf0c8be705398e4ca583e"><td class="memItemLeft" align="right" valign="top"><a id="gacdbc4c711bfbf0c8be705398e4ca583e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::type</b> () const</td></tr>
<tr class="separator:gacdbc4c711bfbf0c8be705398e4ca583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9be9d9d7a99d1c12d1469ab7c35eee"><td class="memItemLeft" align="right" valign="top"><a id="ga4e9be9d9d7a99d1c12d1469ab7c35eee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::depth</b> () const</td></tr>
<tr class="separator:ga4e9be9d9d7a99d1c12d1469ab7c35eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad124040681b94e05fc9030b087f49ab1"><td class="memItemLeft" align="right" valign="top"><a id="gad124040681b94e05fc9030b087f49ab1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::channels</b> () const</td></tr>
<tr class="separator:gad124040681b94e05fc9030b087f49ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7865fed445e49726896502f25d77ca6c"><td class="memItemLeft" align="right" valign="top"><a id="ga7865fed445e49726896502f25d77ca6c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::elemSize</b> () const</td></tr>
<tr class="separator:ga7865fed445e49726896502f25d77ca6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e4454b2b0d3e1b4f29c958ab90f28d"><td class="memItemLeft" align="right" valign="top"><a id="ga71e4454b2b0d3e1b4f29c958ab90f28d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Buffer::elemSize1</b> () const</td></tr>
<tr class="separator:ga71e4454b2b0d3e1b4f29c958ab90f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade340daf96dbd0649ae55d75d2572b01"><td class="memItemLeft" align="right" valign="top"><a id="gade340daf96dbd0649ae55d75d2572b01"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gade340daf96dbd0649ae55d75d2572b01">cv::ogl::Buffer::bufId</a> () const</td></tr>
<tr class="memdesc:gade340daf96dbd0649ae55d75d2572b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">get OpenGL opject id <br /></td></tr>
<tr class="separator:gade340daf96dbd0649ae55d75d2572b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e559b20ea593302282f98bcd1cf784d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga5e559b20ea593302282f98bcd1cf784d">cv::ogl::Texture2D::Texture2D</a> ()</td></tr>
<tr class="memdesc:ga5e559b20ea593302282f98bcd1cf784d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructors.  <a href="#ga5e559b20ea593302282f98bcd1cf784d">More...</a><br /></td></tr>
<tr class="separator:ga5e559b20ea593302282f98bcd1cf784d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f15a77aed589e236041f8da8beb73a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga01f15a77aed589e236041f8da8beb73a">cv::ogl::Texture2D::Texture2D</a> (int arows, int acols, <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a> aformat, unsigned int atexId, bool autoRelease=false)</td></tr>
<tr class="separator:ga01f15a77aed589e236041f8da8beb73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a07435a33f245f7b2592a86e162490"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga43a07435a33f245f7b2592a86e162490">cv::ogl::Texture2D::Texture2D</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> asize, <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a> aformat, unsigned int atexId, bool autoRelease=false)</td></tr>
<tr class="separator:ga43a07435a33f245f7b2592a86e162490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d68da272ef5e37ca21cf7f7d23c9e5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga1d68da272ef5e37ca21cf7f7d23c9e5f">cv::ogl::Texture2D::Texture2D</a> (int arows, int acols, <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a> aformat, bool autoRelease=false)</td></tr>
<tr class="separator:ga1d68da272ef5e37ca21cf7f7d23c9e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8da810e19d71c0b2151e3f46a32068"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga3c8da810e19d71c0b2151e3f46a32068">cv::ogl::Texture2D::Texture2D</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> asize, <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a> aformat, bool autoRelease=false)</td></tr>
<tr class="separator:ga3c8da810e19d71c0b2151e3f46a32068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58cbe6f80d2c8eb52505fad86abf1422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga58cbe6f80d2c8eb52505fad86abf1422">cv::ogl::Texture2D::Texture2D</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> arr, bool autoRelease=false)</td></tr>
<tr class="separator:ga58cbe6f80d2c8eb52505fad86abf1422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44434d109746820cd8b3b14364dedd31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga44434d109746820cd8b3b14364dedd31">cv::ogl::Texture2D::create</a> (int arows, int acols, <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a> aformat, bool autoRelease=false)</td></tr>
<tr class="memdesc:ga44434d109746820cd8b3b14364dedd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">ogl::Texture2D</a> object.  <a href="#ga44434d109746820cd8b3b14364dedd31">More...</a><br /></td></tr>
<tr class="separator:ga44434d109746820cd8b3b14364dedd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9270d0d351251d3006a6e6a8dd01964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaf9270d0d351251d3006a6e6a8dd01964">cv::ogl::Texture2D::create</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> asize, <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a> aformat, bool autoRelease=false)</td></tr>
<tr class="separator:gaf9270d0d351251d3006a6e6a8dd01964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91376169e9cf05898fdecc025a8cbb4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga91376169e9cf05898fdecc025a8cbb4c">cv::ogl::Texture2D::release</a> ()</td></tr>
<tr class="memdesc:ga91376169e9cf05898fdecc025a8cbb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference counter and destroys the texture object if needed.  <a href="#ga91376169e9cf05898fdecc025a8cbb4c">More...</a><br /></td></tr>
<tr class="separator:ga91376169e9cf05898fdecc025a8cbb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1fa264dc4a294bc26d2d074217cb4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gace1fa264dc4a294bc26d2d074217cb4d">cv::ogl::Texture2D::setAutoRelease</a> (bool flag)</td></tr>
<tr class="memdesc:gace1fa264dc4a294bc26d2d074217cb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets auto release mode.  <a href="#gace1fa264dc4a294bc26d2d074217cb4d">More...</a><br /></td></tr>
<tr class="separator:gace1fa264dc4a294bc26d2d074217cb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab245ff921eb30efd321afc65e12960ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gab245ff921eb30efd321afc65e12960ec">cv::ogl::Texture2D::copyFrom</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> arr, bool autoRelease=false)</td></tr>
<tr class="memdesc:gab245ff921eb30efd321afc65e12960ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from host/device memory to OpenGL texture.  <a href="#gab245ff921eb30efd321afc65e12960ec">More...</a><br /></td></tr>
<tr class="separator:gab245ff921eb30efd321afc65e12960ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbf47dc67b22fccbef45c20caba947e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga1fbf47dc67b22fccbef45c20caba947e">cv::ogl::Texture2D::copyTo</a> (<a class="el" href="classcv_1_1___output_array.html">OutputArray</a> arr, int ddepth=CV_32F, bool autoRelease=false) const</td></tr>
<tr class="memdesc:ga1fbf47dc67b22fccbef45c20caba947e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from OpenGL texture to host/device memory or another OpenGL texture object.  <a href="#ga1fbf47dc67b22fccbef45c20caba947e">More...</a><br /></td></tr>
<tr class="separator:ga1fbf47dc67b22fccbef45c20caba947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9834b1c4ed0211408f006896e05da05c"><td class="memItemLeft" align="right" valign="top"><a id="ga9834b1c4ed0211408f006896e05da05c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga9834b1c4ed0211408f006896e05da05c">cv::ogl::Texture2D::bind</a> () const</td></tr>
<tr class="memdesc:ga9834b1c4ed0211408f006896e05da05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds texture to current active texture unit for GL_TEXTURE_2D target. <br /></td></tr>
<tr class="separator:ga9834b1c4ed0211408f006896e05da05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60d7d5fbccd9a946b741ac8c4a4d00f"><td class="memItemLeft" align="right" valign="top"><a id="gae60d7d5fbccd9a946b741ac8c4a4d00f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Texture2D::rows</b> () const</td></tr>
<tr class="separator:gae60d7d5fbccd9a946b741ac8c4a4d00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125aad6e3dfbc590e12b21c856282003"><td class="memItemLeft" align="right" valign="top"><a id="ga125aad6e3dfbc590e12b21c856282003"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Texture2D::cols</b> () const</td></tr>
<tr class="separator:ga125aad6e3dfbc590e12b21c856282003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f84b8b7f310fa80d6ca0e1e80be492"><td class="memItemLeft" align="right" valign="top"><a id="ga65f84b8b7f310fa80d6ca0e1e80be492"></a>
<a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Texture2D::size</b> () const</td></tr>
<tr class="separator:ga65f84b8b7f310fa80d6ca0e1e80be492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ce3d2a82f71ddf351c0d96b7e7e679"><td class="memItemLeft" align="right" valign="top"><a id="gac8ce3d2a82f71ddf351c0d96b7e7e679"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Texture2D::empty</b> () const</td></tr>
<tr class="separator:gac8ce3d2a82f71ddf351c0d96b7e7e679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d34ec6c0656c850cb8ed2280453879"><td class="memItemLeft" align="right" valign="top"><a id="ga99d34ec6c0656c850cb8ed2280453879"></a>
<a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Texture2D::format</b> () const</td></tr>
<tr class="separator:ga99d34ec6c0656c850cb8ed2280453879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad13d3a0569c7df67afdbaf6d0f9c11da"><td class="memItemLeft" align="right" valign="top"><a id="gad13d3a0569c7df67afdbaf6d0f9c11da"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gad13d3a0569c7df67afdbaf6d0f9c11da">cv::ogl::Texture2D::texId</a> () const</td></tr>
<tr class="memdesc:gad13d3a0569c7df67afdbaf6d0f9c11da"><td class="mdescLeft">&#160;</td><td class="mdescRight">get OpenGL opject id <br /></td></tr>
<tr class="separator:gad13d3a0569c7df67afdbaf6d0f9c11da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7084cc4c4d8f6a6b381480088fea7e7"><td class="memItemLeft" align="right" valign="top"><a id="gad7084cc4c4d8f6a6b381480088fea7e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gad7084cc4c4d8f6a6b381480088fea7e7">cv::ogl::Arrays::Arrays</a> ()</td></tr>
<tr class="memdesc:gad7084cc4c4d8f6a6b381480088fea7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:gad7084cc4c4d8f6a6b381480088fea7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56b47850185699e7b248ac16b25dd75a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga56b47850185699e7b248ac16b25dd75a">cv::ogl::Arrays::setVertexArray</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> vertex)</td></tr>
<tr class="memdesc:ga56b47850185699e7b248ac16b25dd75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an array of vertex coordinates.  <a href="#ga56b47850185699e7b248ac16b25dd75a">More...</a><br /></td></tr>
<tr class="separator:ga56b47850185699e7b248ac16b25dd75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bae2d1d0a047f4f2b14fb229ccba87c"><td class="memItemLeft" align="right" valign="top"><a id="ga3bae2d1d0a047f4f2b14fb229ccba87c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga3bae2d1d0a047f4f2b14fb229ccba87c">cv::ogl::Arrays::resetVertexArray</a> ()</td></tr>
<tr class="memdesc:ga3bae2d1d0a047f4f2b14fb229ccba87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets vertex coordinates. <br /></td></tr>
<tr class="separator:ga3bae2d1d0a047f4f2b14fb229ccba87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ac4dcf3a6a09e0e1c30f6da1bc87ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gad1ac4dcf3a6a09e0e1c30f6da1bc87ad">cv::ogl::Arrays::setColorArray</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> color)</td></tr>
<tr class="memdesc:gad1ac4dcf3a6a09e0e1c30f6da1bc87ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an array of vertex colors.  <a href="#gad1ac4dcf3a6a09e0e1c30f6da1bc87ad">More...</a><br /></td></tr>
<tr class="separator:gad1ac4dcf3a6a09e0e1c30f6da1bc87ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312b67d3fea28ee6fdcfbf2184bfee1b"><td class="memItemLeft" align="right" valign="top"><a id="ga312b67d3fea28ee6fdcfbf2184bfee1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga312b67d3fea28ee6fdcfbf2184bfee1b">cv::ogl::Arrays::resetColorArray</a> ()</td></tr>
<tr class="memdesc:ga312b67d3fea28ee6fdcfbf2184bfee1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets vertex colors. <br /></td></tr>
<tr class="separator:ga312b67d3fea28ee6fdcfbf2184bfee1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ea6c9483ac94e8fb6588d94c6c4e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga99ea6c9483ac94e8fb6588d94c6c4e1c">cv::ogl::Arrays::setNormalArray</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> normal)</td></tr>
<tr class="memdesc:ga99ea6c9483ac94e8fb6588d94c6c4e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an array of vertex normals.  <a href="#ga99ea6c9483ac94e8fb6588d94c6c4e1c">More...</a><br /></td></tr>
<tr class="separator:ga99ea6c9483ac94e8fb6588d94c6c4e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26cd068ff065960cd3fc7d99bcf005b7"><td class="memItemLeft" align="right" valign="top"><a id="ga26cd068ff065960cd3fc7d99bcf005b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga26cd068ff065960cd3fc7d99bcf005b7">cv::ogl::Arrays::resetNormalArray</a> ()</td></tr>
<tr class="memdesc:ga26cd068ff065960cd3fc7d99bcf005b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets vertex normals. <br /></td></tr>
<tr class="separator:ga26cd068ff065960cd3fc7d99bcf005b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bdfb171222d5e7802de3a7c29984fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga3bdfb171222d5e7802de3a7c29984fd5">cv::ogl::Arrays::setTexCoordArray</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> texCoord)</td></tr>
<tr class="memdesc:ga3bdfb171222d5e7802de3a7c29984fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an array of vertex texture coordinates.  <a href="#ga3bdfb171222d5e7802de3a7c29984fd5">More...</a><br /></td></tr>
<tr class="separator:ga3bdfb171222d5e7802de3a7c29984fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cbc94c7a8e9c4dbbe0ad2699a51638"><td class="memItemLeft" align="right" valign="top"><a id="ga30cbc94c7a8e9c4dbbe0ad2699a51638"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga30cbc94c7a8e9c4dbbe0ad2699a51638">cv::ogl::Arrays::resetTexCoordArray</a> ()</td></tr>
<tr class="memdesc:ga30cbc94c7a8e9c4dbbe0ad2699a51638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets vertex texture coordinates. <br /></td></tr>
<tr class="separator:ga30cbc94c7a8e9c4dbbe0ad2699a51638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c5d9d13d6f234b507ab98c4a8e23f4"><td class="memItemLeft" align="right" valign="top"><a id="ga19c5d9d13d6f234b507ab98c4a8e23f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga19c5d9d13d6f234b507ab98c4a8e23f4">cv::ogl::Arrays::release</a> ()</td></tr>
<tr class="memdesc:ga19c5d9d13d6f234b507ab98c4a8e23f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all inner buffers. <br /></td></tr>
<tr class="separator:ga19c5d9d13d6f234b507ab98c4a8e23f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45854282c3f6dc58a12b82cd53e50845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga45854282c3f6dc58a12b82cd53e50845">cv::ogl::Arrays::setAutoRelease</a> (bool flag)</td></tr>
<tr class="memdesc:ga45854282c3f6dc58a12b82cd53e50845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets auto release mode all inner buffers.  <a href="#ga45854282c3f6dc58a12b82cd53e50845">More...</a><br /></td></tr>
<tr class="separator:ga45854282c3f6dc58a12b82cd53e50845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132712bbb091e8042734521f7db7da68"><td class="memItemLeft" align="right" valign="top"><a id="ga132712bbb091e8042734521f7db7da68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga132712bbb091e8042734521f7db7da68">cv::ogl::Arrays::bind</a> () const</td></tr>
<tr class="memdesc:ga132712bbb091e8042734521f7db7da68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds all vertex arrays. <br /></td></tr>
<tr class="separator:ga132712bbb091e8042734521f7db7da68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9bc2bcf2fed70c4a6b49f62b7b01bd"><td class="memItemLeft" align="right" valign="top"><a id="ga6f9bc2bcf2fed70c4a6b49f62b7b01bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga6f9bc2bcf2fed70c4a6b49f62b7b01bd">cv::ogl::Arrays::size</a> () const</td></tr>
<tr class="memdesc:ga6f9bc2bcf2fed70c4a6b49f62b7b01bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex count. <br /></td></tr>
<tr class="separator:ga6f9bc2bcf2fed70c4a6b49f62b7b01bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6061bd502601ad12f3c7454c1b68f894"><td class="memItemLeft" align="right" valign="top"><a id="ga6061bd502601ad12f3c7454c1b68f894"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cv::ogl::Arrays::empty</b> () const</td></tr>
<tr class="separator:ga6061bd502601ad12f3c7454c1b68f894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ffbefefb211a8fc37c22f9493ef0ef"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga63ffbefefb211a8fc37c22f9493ef0ef">cv::ogl::render</a> (const <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html">Texture2D</a> &amp;tex, <a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt; double &gt; wndRect=<a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt; double &gt;(0.0, 0.0, 1.0, 1.0), <a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt; double &gt; texRect=<a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt; double &gt;(0.0, 0.0, 1.0, 1.0))</td></tr>
<tr class="memdesc:ga63ffbefefb211a8fc37c22f9493ef0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render OpenGL texture or primitives.  <a href="group__core__opengl.html#ga63ffbefefb211a8fc37c22f9493ef0ef">More...</a><br /></td></tr>
<tr class="separator:ga63ffbefefb211a8fc37c22f9493ef0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae899c0266461d15d478e039956b31a5e"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gae899c0266461d15d478e039956b31a5e">cv::ogl::render</a> (const <a class="el" href="classcv_1_1ogl_1_1_arrays.html">Arrays</a> &amp;arr, int mode=POINTS, <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> color=<a class="el" href="classcv_1_1_scalar__.html#ac1509a4b8454fe7fe29db069e13a2e6f">Scalar::all</a>(255))</td></tr>
<tr class="separator:gae899c0266461d15d478e039956b31a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674e6156dc3491c9d9eb0266dcf5b61e"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga674e6156dc3491c9d9eb0266dcf5b61e">cv::ogl::render</a> (const <a class="el" href="classcv_1_1ogl_1_1_arrays.html">Arrays</a> &amp;arr, <a class="el" href="classcv_1_1___input_array.html">InputArray</a> indices, int mode=POINTS, <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> color=<a class="el" href="classcv_1_1_scalar__.html#ac1509a4b8454fe7fe29db069e13a2e6f">Scalar::all</a>(255))</td></tr>
<tr class="separator:ga674e6156dc3491c9d9eb0266dcf5b61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade145daccf7efe98a782d343a0b44c78"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS <a class="el" href="classcv_1_1ocl_1_1_context.html">Context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gade145daccf7efe98a782d343a0b44c78">cv::ogl::ocl::initializeContextFromGL</a> ()</td></tr>
<tr class="memdesc:gade145daccf7efe98a782d343a0b44c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates OpenCL context from GL.  <a href="group__core__opengl.html#gade145daccf7efe98a782d343a0b44c78">More...</a><br /></td></tr>
<tr class="separator:gade145daccf7efe98a782d343a0b44c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ec91edd6fdc809f5168d88b0faa8b2"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gaa3ec91edd6fdc809f5168d88b0faa8b2">cv::ogl::convertToGLTexture2D</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> src, <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html">Texture2D</a> &amp;texture)</td></tr>
<tr class="memdesc:gaa3ec91edd6fdc809f5168d88b0faa8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts InputArray to <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">Texture2D</a> object.  <a href="group__core__opengl.html#gaa3ec91edd6fdc809f5168d88b0faa8b2">More...</a><br /></td></tr>
<tr class="separator:gaa3ec91edd6fdc809f5168d88b0faa8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f701a2b121ffe9ca7bc057a7643854b"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga5f701a2b121ffe9ca7bc057a7643854b">cv::ogl::convertFromGLTexture2D</a> (const <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html">Texture2D</a> &amp;texture, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst)</td></tr>
<tr class="memdesc:ga5f701a2b121ffe9ca7bc057a7643854b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">Texture2D</a> object to OutputArray.  <a href="group__core__opengl.html#ga5f701a2b121ffe9ca7bc057a7643854b">More...</a><br /></td></tr>
<tr class="separator:ga5f701a2b121ffe9ca7bc057a7643854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70720b3650df81c65608a4c561c9bf06"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS <a class="el" href="classcv_1_1_u_mat.html">UMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#ga70720b3650df81c65608a4c561c9bf06">cv::ogl::mapGLBuffer</a> (const <a class="el" href="classcv_1_1ogl_1_1_buffer.html">Buffer</a> &amp;buffer, int accessFlags=ACCESS_READ|ACCESS_WRITE)</td></tr>
<tr class="memdesc:ga70720b3650df81c65608a4c561c9bf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> object to process on CL side (convert to <a class="el" href="classcv_1_1_u_mat.html">UMat</a>).  <a href="group__core__opengl.html#ga70720b3650df81c65608a4c561c9bf06">More...</a><br /></td></tr>
<tr class="separator:ga70720b3650df81c65608a4c561c9bf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe053abbf2cc81692a9380bfbf4e632"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gafbe053abbf2cc81692a9380bfbf4e632">cv::ogl::unmapGLBuffer</a> (<a class="el" href="classcv_1_1_u_mat.html">UMat</a> &amp;u)</td></tr>
<tr class="memdesc:gafbe053abbf2cc81692a9380bfbf4e632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> object (releases <a class="el" href="classcv_1_1_u_mat.html">UMat</a>, previously mapped from <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a>).  <a href="group__core__opengl.html#gafbe053abbf2cc81692a9380bfbf4e632">More...</a><br /></td></tr>
<tr class="separator:gafbe053abbf2cc81692a9380bfbf4e632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47b2e332c6884b534bac935b8cd577b"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__opengl.html#gac47b2e332c6884b534bac935b8cd577b">cv::cuda::setGlDevice</a> (int device=0)</td></tr>
<tr class="memdesc:gac47b2e332c6884b534bac935b8cd577b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a CUDA device and initializes it for the current thread with OpenGL interoperability.  <a href="group__core__opengl.html#gac47b2e332c6884b534bac935b8cd577b">More...</a><br /></td></tr>
<tr class="separator:gac47b2e332c6884b534bac935b8cd577b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This section describes OpenGL interoperability.</p>
<p>To enable OpenGL support, configure OpenCV using CMake with WITH_OPENGL=ON . Currently OpenGL is supported only with WIN32, GTK and Qt backends on Windows and Linux (MacOS and Android are not supported). For GTK backend gtkglext-1.0 library is required.</p>
<p>To use OpenGL functionality you should first create OpenGL context (window or frame buffer). You can do this with namedWindow function or with other OpenGL toolkit (GLUT, for example). </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1838399ee67c0957c0ae42cabfa99033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1838399ee67c0957c0ae42cabfa99033">&#9670;&nbsp;</a></span>Format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">cv::ogl::Texture2D::Format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Image Format describes the way that the images in Textures store their data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1838399ee67c0957c0ae42cabfa99033ad97d2f204bb7e38b03b74ea3a8129cdb"></a>DEPTH_COMPONENT&#160;</td><td class="fielddoc"><p>Depth. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1838399ee67c0957c0ae42cabfa99033a1c819f641291e88d67ab432f67023a17"></a>RGB&#160;</td><td class="fielddoc"><p>Red, Green, Blue. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1838399ee67c0957c0ae42cabfa99033ab30fb919ec618eaa81c28235e568ef20"></a>RGBA&#160;</td><td class="fielddoc"><p>Red, Green, Blue, Alpha. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga830568a629457171cb07918537ec66be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga830568a629457171cb07918537ec66be">&#9670;&nbsp;</a></span>Target</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">cv::ogl::Buffer::Target</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The target defines how you intend to use the buffer object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a"></a>ARRAY_BUFFER&#160;</td><td class="fielddoc"><p>The buffer will be used as a source for vertex data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830568a629457171cb07918537ec66beae86acf739ab6ec3ccdc40db15366f672"></a>ELEMENT_ARRAY_BUFFER&#160;</td><td class="fielddoc"><p>The buffer will be used for indices (in glDrawElements, for example) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830568a629457171cb07918537ec66bea04aec232cc3ac3070953ba669bee3a3a"></a>PIXEL_PACK_BUFFER&#160;</td><td class="fielddoc"><p>The buffer will be used for reading from OpenGL textures. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga830568a629457171cb07918537ec66bea882899bdc22e1c13618c294343d4d9dc"></a>PIXEL_UNPACK_BUFFER&#160;</td><td class="fielddoc"><p>The buffer will be used for writing to OpenGL textures. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga40fd03c02f051f780f518acb6cd9b407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40fd03c02f051f780f518acb6cd9b407">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds OpenGL buffer to the specified buffer binding point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Binding point. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf53dfd844f101cc0ba752bf6791890ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf53dfd844f101cc0ba752bf6791890ac">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Buffer::Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructors. </p>
<p>Creates empty <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> object, creates <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> object from existed buffer ( abufId parameter), allocates memory for <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> object or copies from host/device memory. </p>

</div>
</div>
<a id="ga94a62127a1690d9d2244463c88b0c200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94a62127a1690d9d2244463c88b0c200">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Buffer::Buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>abufId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">acols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">atype</td><td>Array type ( CV_8UC1, ..., CV_64FC4 ). See <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> for details. </td></tr>
    <tr><td class="paramname">abufId</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> object name. </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1598ae7fd0b6f35dee834b8cc6b0e73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1598ae7fd0b6f35dee834b8cc6b0e73e">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Buffer::Buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>asize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>abufId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asize</td><td>2D array size. </td></tr>
    <tr><td class="paramname">atype</td><td>Array type ( CV_8UC1, ..., CV_64FC4 ). See <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> for details. </td></tr>
    <tr><td class="paramname">abufId</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> object name. </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb20e60d0a89372f7403c04fcb5444ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb20e60d0a89372f7403c04fcb5444ba">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Buffer::Buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">acols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">atype</td><td>Array type ( CV_8UC1, ..., CV_64FC4 ). See <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> for details. </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> usage. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf981734a0b35b9bebf48b1edb65291b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf981734a0b35b9bebf48b1edb65291b8">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Buffer::Buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>asize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asize</td><td>2D array size. </td></tr>
    <tr><td class="paramname">atype</td><td>Array type ( CV_8UC1, ..., CV_64FC4 ). See <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> for details. </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> usage. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fce522179bc8984c50a3c8b3de3554c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fce522179bc8984c50a3c8b3de3554c">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Buffer::Buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array (host or device memory, it can be <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> , <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting. ">cuda::GpuMat</a> or std::vector ). </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> usage. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0c8b81f03de2d386bce302ccd9bd431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c8b81f03de2d386bce302ccd9bd431">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1ogl_1_1_buffer.html">Buffer</a> cv::ogl::Buffer::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a full copy of the buffer object and the underlying data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> usage for destination buffer. </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode for destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f701a2b121ffe9ca7bc057a7643854b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f701a2b121ffe9ca7bc057a7643854b">&#9670;&nbsp;</a></span>convertFromGLTexture2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::ogl::convertFromGLTexture2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html">Texture2D</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">Texture2D</a> object to OutputArray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>- source <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">Texture2D</a> object. </td></tr>
    <tr><td class="paramname">dst</td><td>- destination OutputArray. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3ec91edd6fdc809f5168d88b0faa8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3ec91edd6fdc809f5168d88b0faa8b2">&#9670;&nbsp;</a></span>convertToGLTexture2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::ogl::convertToGLTexture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1ogl_1_1_texture2_d.html">Texture2D</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts InputArray to <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">Texture2D</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>- source InputArray. </td></tr>
    <tr><td class="paramname">texture</td><td>- destination <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">Texture2D</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadac4c20b821703eba30e68e3bba511a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadac4c20b821703eba30e68e3bba511a4">&#9670;&nbsp;</a></span>copyFrom() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::copyFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from host/device memory to OpenGL buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array (host or device memory, it can be <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> , <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting. ">cuda::GpuMat</a> or std::vector ). </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> usage. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9a8b9910ae4f914faa7ad740e3d084f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a8b9910ae4f914faa7ad740e3d084f">&#9670;&nbsp;</a></span>copyFrom() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::copyFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1cuda_1_1_stream.html">cuda::Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gab245ff921eb30efd321afc65e12960ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab245ff921eb30efd321afc65e12960ec">&#9670;&nbsp;</a></span>copyFrom() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Texture2D::copyFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from host/device memory to OpenGL texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array (host or device memory, it can be <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> , <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting. ">cuda::GpuMat</a> or <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> ). </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3aab3acc565ead059f4da0efb943db0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aab3acc565ead059f4da0efb943db0a">&#9670;&nbsp;</a></span>copyTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from OpenGL buffer to host/device memory or another OpenGL buffer object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Destination array (host or device memory, can be <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> , <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting. ">cuda::GpuMat</a> , std::vector or <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> ). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga563a63b77bd1c01b1bed7ea7740391c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga563a63b77bd1c01b1bed7ea7740391c1">&#9670;&nbsp;</a></span>copyTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1cuda_1_1_stream.html">cuda::Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga1fbf47dc67b22fccbef45c20caba947e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbf47dc67b22fccbef45c20caba947e">&#9670;&nbsp;</a></span>copyTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Texture2D::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddepth</em> = <code>CV_32F</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from OpenGL texture to host/device memory or another OpenGL texture object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Destination array (host or device memory, can be <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> , <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting. ">cuda::GpuMat</a> , <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> or <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">ogl::Texture2D</a> ). </td></tr>
    <tr><td class="paramname">ddepth</td><td>Destination depth. </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode for destination buffer (if arr is OpenGL buffer or texture). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b9eb33a14f929c8554b4444198a1550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b9eb33a14f929c8554b4444198a1550">&#9670;&nbsp;</a></span>create() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arows</td><td>Number of rows in a 2D array. </td></tr>
    <tr><td class="paramname">acols</td><td>Number of columns in a 2D array. </td></tr>
    <tr><td class="paramname">atype</td><td>Array type ( CV_8UC1, ..., CV_64FC4 ). See <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> for details. </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> usage. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ff29b1f3609d41cc350e5d407ddb9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ff29b1f3609d41cc350e5d407ddb9b1">&#9670;&nbsp;</a></span>create() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>asize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>atype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="group__core__opengl.html#gga830568a629457171cb07918537ec66bea62a4126c42da95e41facc4f84475f44a">ARRAY_BUFFER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asize</td><td>2D array size. </td></tr>
    <tr><td class="paramname">atype</td><td>Array type ( CV_8UC1, ..., CV_64FC4 ). See <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> for details. </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> usage. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44434d109746820cd8b3b14364dedd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44434d109746820cd8b3b14364dedd31">&#9670;&nbsp;</a></span>create() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Texture2D::create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a>&#160;</td>
          <td class="paramname"><em>aformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">ogl::Texture2D</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arows</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">acols</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">aformat</td><td>Image format. See <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033" title="An Image Format describes the way that the images in Textures store their data. ">cv::ogl::Texture2D::Format</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9270d0d351251d3006a6e6a8dd01964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9270d0d351251d3006a6e6a8dd01964">&#9670;&nbsp;</a></span>create() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Texture2D::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>asize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a>&#160;</td>
          <td class="paramname"><em>aformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asize</td><td>2D array size. </td></tr>
    <tr><td class="paramname">aformat</td><td>Image format. See <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033" title="An Image Format describes the way that the images in Textures store their data. ">cv::ogl::Texture2D::Format</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade145daccf7efe98a782d343a0b44c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade145daccf7efe98a782d343a0b44c78">&#9670;&nbsp;</a></span>initializeContextFromGL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS <a class="el" href="classcv_1_1ocl_1_1_context.html">Context</a>&amp; cv::ogl::ocl::initializeContextFromGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates OpenCL context from GL. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns reference to OpenCL Context </dd></dl>

</div>
</div>
<a id="gabde1b6c518abefeee7cf878b066c65fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabde1b6c518abefeee7cf878b066c65fb">&#9670;&nbsp;</a></span>mapDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">cuda::GpuMat</a> cv::ogl::Buffer::mapDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1cuda_1_1_stream.html">cuda::Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps OpenGL buffer to CUDA device memory. </p>
<p>This operatation doesn't copy data. Several buffer objects can be mapped to CUDA memory at a time.</p>
<p>A mapped data store must be unmapped with ogl::Buffer::unmapDevice before its buffer object is used. </p>

</div>
</div>
<a id="ga70720b3650df81c65608a4c561c9bf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70720b3650df81c65608a4c561c9bf06">&#9670;&nbsp;</a></span>mapGLBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS <a class="el" href="classcv_1_1_u_mat.html">UMat</a> cv::ogl::mapGLBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1ogl_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>accessFlags</em> = <code>ACCESS_READ|ACCESS_WRITE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> object to process on CL side (convert to <a class="el" href="classcv_1_1_u_mat.html">UMat</a>). </p>
<p>Function creates CL buffer from GL one, and then constructs <a class="el" href="classcv_1_1_u_mat.html">UMat</a> that can be used to process buffer data with OpenCV functions. Note that in current implementation <a class="el" href="classcv_1_1_u_mat.html">UMat</a> constructed this way doesn't own corresponding GL buffer object, so it is the user responsibility to close down CL/GL buffers relationships by explicitly calling <a class="el" href="group__core__opengl.html#gafbe053abbf2cc81692a9380bfbf4e632" title="Unmaps Buffer object (releases UMat, previously mapped from Buffer). ">unmapGLBuffer()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>- source <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> object. </td></tr>
    <tr><td class="paramname">accessFlags</td><td>- data access flags (ACCESS_READ|ACCESS_WRITE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="classcv_1_1_u_mat.html">UMat</a> object </dd></dl>

</div>
</div>
<a id="ga3e14b8b56c501c5c90c79aca9c744d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e14b8b56c501c5c90c79aca9c744d18">&#9670;&nbsp;</a></span>mapHost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::ogl::Buffer::mapHost </td>
          <td>(</td>
          <td class="paramtype">Access&#160;</td>
          <td class="paramname"><em>access</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps OpenGL buffer to host memory. </p>
<p>mapHost maps to the client's address space the entire data store of the buffer object. The data can then be directly read and/or written relative to the returned pointer, depending on the specified access policy.</p>
<p>A mapped data store must be unmapped with <a class="el" href="group__core__opengl.html#ga86c5bdbf910b69d20773ac1228c2daf9" title="Unmaps OpenGL buffer. ">ogl::Buffer::unmapHost</a> before its buffer object is used.</p>
<p>This operation can lead to memory transfers between host and device.</p>
<p>Only one buffer object can be mapped at a time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">access</td><td>Access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be ogl::Buffer::READ_ONLY , ogl::Buffer::WRITE_ONLY or ogl::Buffer::READ_WRITE . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae8efb43bb0ece5deffc68308bb70b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae8efb43bb0ece5deffc68308bb70b53">&#9670;&nbsp;</a></span>release() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the reference counter and destroys the buffer object if needed. </p>
<p>The function will call setAutoRelease(true) . </p>

</div>
</div>
<a id="ga91376169e9cf05898fdecc025a8cbb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91376169e9cf05898fdecc025a8cbb4c">&#9670;&nbsp;</a></span>release() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Texture2D::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the reference counter and destroys the texture object if needed. </p>
<p>The function will call setAutoRelease(true) . </p>

</div>
</div>
<a id="ga63ffbefefb211a8fc37c22f9493ef0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63ffbefefb211a8fc37c22f9493ef0ef">&#9670;&nbsp;</a></span>render() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::ogl::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html">Texture2D</a> &amp;&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>wndRect</em> = <code><a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt;&#160;double&#160;&gt;(0.0,&#160;0.0,&#160;1.0,&#160;1.0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>texRect</em> = <code><a class="el" href="classcv_1_1_rect__.html">Rect_</a>&lt;&#160;double&#160;&gt;(0.0,&#160;0.0,&#160;1.0,&#160;1.0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render OpenGL texture or primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tex</td><td>Texture to draw. </td></tr>
    <tr><td class="paramname">wndRect</td><td>Region of window, where to draw a texture (normalized coordinates). </td></tr>
    <tr><td class="paramname">texRect</td><td>Region of texture to draw (normalized coordinates). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae899c0266461d15d478e039956b31a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae899c0266461d15d478e039956b31a5e">&#9670;&nbsp;</a></span>render() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::ogl::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1ogl_1_1_arrays.html">Arrays</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>POINTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_scalar__.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classcv_1_1_scalar__.html#ac1509a4b8454fe7fe29db069e13a2e6f">Scalar::all</a>(255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array of privitives vertices. </td></tr>
    <tr><td class="paramname">mode</td><td>Render mode. One of cv::ogl::RenderModes </td></tr>
    <tr><td class="paramname">color</td><td>Color for all vertices. Will be used if arr doesn't contain color array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga674e6156dc3491c9d9eb0266dcf5b61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga674e6156dc3491c9d9eb0266dcf5b61e">&#9670;&nbsp;</a></span>render() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::ogl::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1ogl_1_1_arrays.html">Arrays</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em> = <code>POINTS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_scalar__.html">Scalar</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classcv_1_1_scalar__.html#ac1509a4b8454fe7fe29db069e13a2e6f">Scalar::all</a>(255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array of privitives vertices. </td></tr>
    <tr><td class="paramname">indices</td><td>Array of vertices indices (host or device memory). </td></tr>
    <tr><td class="paramname">mode</td><td>Render mode. One of cv::ogl::RenderModes </td></tr>
    <tr><td class="paramname">color</td><td>Color for all vertices. Will be used if arr doesn't contain color array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff9abd9111dfb14686a788eaaa94770a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff9abd9111dfb14686a788eaaa94770a">&#9670;&nbsp;</a></span>setAutoRelease() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Buffer::setAutoRelease </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets auto release mode. </p>
<p>The lifetime of the OpenGL object is tied to the lifetime of the context. If OpenGL context was bound to a window it could be released at any time (user can close a window). If object's destructor is called after destruction of the context it will cause an error. Thus <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> doesn't destroy OpenGL object in destructor by default (all OpenGL resources will be released with OpenGL context). This function can force <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> destructor to destroy OpenGL object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace1fa264dc4a294bc26d2d074217cb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace1fa264dc4a294bc26d2d074217cb4d">&#9670;&nbsp;</a></span>setAutoRelease() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Texture2D::setAutoRelease </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets auto release mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Auto release mode (if true, release will be called in object's destructor).</td></tr>
  </table>
  </dd>
</dl>
<p>The lifetime of the OpenGL object is tied to the lifetime of the context. If OpenGL context was bound to a window it could be released at any time (user can close a window). If object's destructor is called after destruction of the context it will cause an error. Thus <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">ogl::Texture2D</a> doesn't destroy OpenGL object in destructor by default (all OpenGL resources will be released with OpenGL context). This function can force <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">ogl::Texture2D</a> destructor to destroy OpenGL object. </p>

</div>
</div>
<a id="ga45854282c3f6dc58a12b82cd53e50845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45854282c3f6dc58a12b82cd53e50845">&#9670;&nbsp;</a></span>setAutoRelease() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Arrays::setAutoRelease </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets auto release mode all inner buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Auto release mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1ac4dcf3a6a09e0e1c30f6da1bc87ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ac4dcf3a6a09e0e1c30f6da1bc87ad">&#9670;&nbsp;</a></span>setColorArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Arrays::setColorArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an array of vertex colors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>array with vertex colors, can be both host and device memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac47b2e332c6884b534bac935b8cd577b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac47b2e332c6884b534bac935b8cd577b">&#9670;&nbsp;</a></span>setGlDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::cuda::setGlDevice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a CUDA device and initializes it for the current thread with OpenGL interoperability. </p>
<p>This function should be explicitly called after OpenGL context creation and before any CUDA calls. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>System index of a CUDA device starting with 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99ea6c9483ac94e8fb6588d94c6c4e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ea6c9483ac94e8fb6588d94c6c4e1c">&#9670;&nbsp;</a></span>setNormalArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Arrays::setNormalArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>normal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an array of vertex normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal</td><td>array with vertex normals, can be both host and device memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bdfb171222d5e7802de3a7c29984fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bdfb171222d5e7802de3a7c29984fd5">&#9670;&nbsp;</a></span>setTexCoordArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Arrays::setTexCoordArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>texCoord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an array of vertex texture coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texCoord</td><td>array with vertex texture coordinates, can be both host and device memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56b47850185699e7b248ac16b25dd75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56b47850185699e7b248ac16b25dd75a">&#9670;&nbsp;</a></span>setVertexArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::ogl::Arrays::setVertexArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an array of vertex coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>array with vertex coordinates, can be both host and device memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e559b20ea593302282f98bcd1cf784d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e559b20ea593302282f98bcd1cf784d">&#9670;&nbsp;</a></span>Texture2D() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Texture2D::Texture2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The constructors. </p>
<p>Creates empty <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">ogl::Texture2D</a> object, allocates memory for <a class="el" href="classcv_1_1ogl_1_1_texture2_d.html" title="Smart pointer for OpenGL 2D texture memory with reference counting. ">ogl::Texture2D</a> object or copies from host/device memory. </p>

</div>
</div>
<a id="ga01f15a77aed589e236041f8da8beb73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f15a77aed589e236041f8da8beb73a">&#9670;&nbsp;</a></span>Texture2D() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Texture2D::Texture2D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a>&#160;</td>
          <td class="paramname"><em>aformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>atexId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga43a07435a33f245f7b2592a86e162490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43a07435a33f245f7b2592a86e162490">&#9670;&nbsp;</a></span>Texture2D() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Texture2D::Texture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>asize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a>&#160;</td>
          <td class="paramname"><em>aformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>atexId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga1d68da272ef5e37ca21cf7f7d23c9e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d68da272ef5e37ca21cf7f7d23c9e5f">&#9670;&nbsp;</a></span>Texture2D() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Texture2D::Texture2D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a>&#160;</td>
          <td class="paramname"><em>aformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arows</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">acols</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">aformat</td><td>Image format. See <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033" title="An Image Format describes the way that the images in Textures store their data. ">cv::ogl::Texture2D::Format</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c8da810e19d71c0b2151e3f46a32068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c8da810e19d71c0b2151e3f46a32068">&#9670;&nbsp;</a></span>Texture2D() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Texture2D::Texture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>asize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033">Format</a>&#160;</td>
          <td class="paramname"><em>aformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asize</td><td>2D array size. </td></tr>
    <tr><td class="paramname">aformat</td><td>Image format. See <a class="el" href="group__core__opengl.html#ga1838399ee67c0957c0ae42cabfa99033" title="An Image Format describes the way that the images in Textures store their data. ">cv::ogl::Texture2D::Format</a> . </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58cbe6f80d2c8eb52505fad86abf1422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58cbe6f80d2c8eb52505fad86abf1422">&#9670;&nbsp;</a></span>Texture2D() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::ogl::Texture2D::Texture2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoRelease</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array (host or device memory, it can be <a class="el" href="classcv_1_1_mat.html" title="n-dimensional dense array class ">Mat</a> , <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting. ">cuda::GpuMat</a> or <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">ogl::Buffer</a> ). </td></tr>
    <tr><td class="paramname">autoRelease</td><td>Auto release mode (if true, release will be called in object's destructor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89b3599430d2e7938997a8911b1d9408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b3599430d2e7938997a8911b1d9408">&#9670;&nbsp;</a></span>unbind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cv::ogl::Buffer::unbind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be">Target</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbind any buffers from the specified binding point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Binding point. See <a class="el" href="group__core__opengl.html#ga830568a629457171cb07918537ec66be" title="The target defines how you intend to use the buffer object. ">cv::ogl::Buffer::Target</a> . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbe053abbf2cc81692a9380bfbf4e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbe053abbf2cc81692a9380bfbf4e632">&#9670;&nbsp;</a></span>unmapGLBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::ogl::unmapGLBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_u_mat.html">UMat</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmaps <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a> object (releases <a class="el" href="classcv_1_1_u_mat.html">UMat</a>, previously mapped from <a class="el" href="classcv_1_1ogl_1_1_buffer.html" title="Smart pointer for OpenGL buffer object with reference counting. ">Buffer</a>). </p>
<p>Function must be called explicitly by the user for each <a class="el" href="classcv_1_1_u_mat.html">UMat</a> previously constructed by the call to <a class="el" href="group__core__opengl.html#ga70720b3650df81c65608a4c561c9bf06" title="Maps Buffer object to process on CL side (convert to UMat). ">mapGLBuffer()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>- source <a class="el" href="classcv_1_1_u_mat.html">UMat</a>, created by <a class="el" href="group__core__opengl.html#ga70720b3650df81c65608a4c561c9bf06" title="Maps Buffer object to process on CL side (convert to UMat). ">mapGLBuffer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
