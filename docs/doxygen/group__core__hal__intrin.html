<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2018-inseason: Universal intrinsics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">2018-inseason
   </div>
   <div id="projectbrief">The Greybots&#39; 2018 Power Up code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Universal intrinsics<div class="ingroups"><a class="el" href="group__core.html">Core functionality</a> &raquo; <a class="el" href="group__core__hal.html">Hardware Acceleration Layer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__core__hal__intrin__impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin__impl.html">Private implementation helpers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1v__reg.html">cv::v_reg&lt; _Tp, n &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad953f90887e4eb9a12657e6a1f86d01b"><td class="memItemLeft" align="right" valign="top"><a id="gad953f90887e4eb9a12657e6a1f86d01b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad953f90887e4eb9a12657e6a1f86d01b">CV_SIMD128</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gad953f90887e4eb9a12657e6a1f86d01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to 1 if current compiler supports vector extensions (NEON or SSE is enabled) <br /></td></tr>
<tr class="separator:gad953f90887e4eb9a12657e6a1f86d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51529fa7aa602e84255f9e68efa5ed01"><td class="memItemLeft" align="right" valign="top"><a id="ga51529fa7aa602e84255f9e68efa5ed01"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga51529fa7aa602e84255f9e68efa5ed01">CV_SIMD128_64F</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga51529fa7aa602e84255f9e68efa5ed01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to 1 if current intrinsics implementation supports 64-bit float vectors. <br /></td></tr>
<tr class="separator:ga51529fa7aa602e84255f9e68efa5ed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga15cd4df600c57ee36d03ccfee5cb9820"><td class="memItemLeft" align="right" valign="top"><a id="ga15cd4df600c57ee36d03ccfee5cb9820"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; uchar, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga15cd4df600c57ee36d03ccfee5cb9820">cv::v_uint8x16</a></td></tr>
<tr class="memdesc:ga15cd4df600c57ee36d03ccfee5cb9820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sixteen 8-bit unsigned integer values. <br /></td></tr>
<tr class="separator:ga15cd4df600c57ee36d03ccfee5cb9820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133cdb895b50ab8825455da083d83ede"><td class="memItemLeft" align="right" valign="top"><a id="ga133cdb895b50ab8825455da083d83ede"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; schar, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga133cdb895b50ab8825455da083d83ede">cv::v_int8x16</a></td></tr>
<tr class="memdesc:ga133cdb895b50ab8825455da083d83ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sixteen 8-bit signed integer values. <br /></td></tr>
<tr class="separator:ga133cdb895b50ab8825455da083d83ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d7ee7873e4a78bcdf0b0beea3e061b"><td class="memItemLeft" align="right" valign="top"><a id="ga33d7ee7873e4a78bcdf0b0beea3e061b"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; ushort, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga33d7ee7873e4a78bcdf0b0beea3e061b">cv::v_uint16x8</a></td></tr>
<tr class="memdesc:ga33d7ee7873e4a78bcdf0b0beea3e061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eight 16-bit unsigned integer values. <br /></td></tr>
<tr class="separator:ga33d7ee7873e4a78bcdf0b0beea3e061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3957262ebae34fbdf7f4b930cb79ce"><td class="memItemLeft" align="right" valign="top"><a id="gafa3957262ebae34fbdf7f4b930cb79ce"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; short, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gafa3957262ebae34fbdf7f4b930cb79ce">cv::v_int16x8</a></td></tr>
<tr class="memdesc:gafa3957262ebae34fbdf7f4b930cb79ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eight 16-bit signed integer values. <br /></td></tr>
<tr class="separator:gafa3957262ebae34fbdf7f4b930cb79ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5859d41d20a075cff6b832f0d64ee042"><td class="memItemLeft" align="right" valign="top"><a id="ga5859d41d20a075cff6b832f0d64ee042"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; unsigned, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga5859d41d20a075cff6b832f0d64ee042">cv::v_uint32x4</a></td></tr>
<tr class="memdesc:ga5859d41d20a075cff6b832f0d64ee042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Four 32-bit unsigned integer values. <br /></td></tr>
<tr class="separator:ga5859d41d20a075cff6b832f0d64ee042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6899623e3f4b0d89737817e7f83ff4"><td class="memItemLeft" align="right" valign="top"><a id="ga4c6899623e3f4b0d89737817e7f83ff4"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4c6899623e3f4b0d89737817e7f83ff4">cv::v_int32x4</a></td></tr>
<tr class="memdesc:ga4c6899623e3f4b0d89737817e7f83ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Four 32-bit signed integer values. <br /></td></tr>
<tr class="separator:ga4c6899623e3f4b0d89737817e7f83ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f972902dd8ee6dd7c2ebeb845728d4"><td class="memItemLeft" align="right" valign="top"><a id="gad1f972902dd8ee6dd7c2ebeb845728d4"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">cv::v_float32x4</a></td></tr>
<tr class="memdesc:gad1f972902dd8ee6dd7c2ebeb845728d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Four 32-bit floating point values (single precision) <br /></td></tr>
<tr class="separator:gad1f972902dd8ee6dd7c2ebeb845728d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc604f432c648ca88335be4fcc4de25d"><td class="memItemLeft" align="right" valign="top"><a id="gafc604f432c648ca88335be4fcc4de25d"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gafc604f432c648ca88335be4fcc4de25d">cv::v_float64x2</a></td></tr>
<tr class="memdesc:gafc604f432c648ca88335be4fcc4de25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two 64-bit floating point values (double precision) <br /></td></tr>
<tr class="separator:gafc604f432c648ca88335be4fcc4de25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32d838ec60649d90504438b02beeb40"><td class="memItemLeft" align="right" valign="top"><a id="gab32d838ec60649d90504438b02beeb40"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; uint64, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab32d838ec60649d90504438b02beeb40">cv::v_uint64x2</a></td></tr>
<tr class="memdesc:gab32d838ec60649d90504438b02beeb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two 64-bit unsigned integer values. <br /></td></tr>
<tr class="separator:gab32d838ec60649d90504438b02beeb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2448f821d0ad63d2f5f1b474e26aa0bc"><td class="memItemLeft" align="right" valign="top"><a id="ga2448f821d0ad63d2f5f1b474e26aa0bc"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int64, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga2448f821d0ad63d2f5f1b474e26aa0bc">cv::v_int64x2</a></td></tr>
<tr class="memdesc:ga2448f821d0ad63d2f5f1b474e26aa0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two 64-bit signed integer values. <br /></td></tr>
<tr class="separator:ga2448f821d0ad63d2f5f1b474e26aa0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6238e30480f4a52f3b30d5c21bbbadb1"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga6238e30480f4a52f3b30d5c21bbbadb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga6238e30480f4a52f3b30d5c21bbbadb1">cv::operator~</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga6238e30480f4a52f3b30d5c21bbbadb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND.  <a href="group__core__hal__intrin.html#ga6238e30480f4a52f3b30d5c21bbbadb1">More...</a><br /></td></tr>
<tr class="separator:ga6238e30480f4a52f3b30d5c21bbbadb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a2a7fa62d0627a6006ff33472e4d26"><td class="memItemLeft" align="right" valign="top"><a id="gaa1a2a7fa62d0627a6006ff33472e4d26"></a>
int n <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::abs_type, n &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cv::v_absdiff</b> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="separator:gaa1a2a7fa62d0627a6006ff33472e4d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1767714db3dcadb809e7186824764796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga1767714db3dcadb809e7186824764796">cv::v_absdiff</a> (const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;b)</td></tr>
<tr class="separator:ga1767714db3dcadb809e7186824764796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcb5a63b95a345d4da1d278b4617547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gafc604f432c648ca88335be4fcc4de25d">v_float64x2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaedcb5a63b95a345d4da1d278b4617547">cv::v_absdiff</a> (const <a class="el" href="group__core__hal__intrin.html#gafc604f432c648ca88335be4fcc4de25d">v_float64x2</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#gafc604f432c648ca88335be4fcc4de25d">v_float64x2</a> &amp;b)</td></tr>
<tr class="separator:gaedcb5a63b95a345d4da1d278b4617547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9fa03f4014a0c0756de5d94f895112"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga0e9fa03f4014a0c0756de5d94f895112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga0e9fa03f4014a0c0756de5d94f895112">cv::v_invsqrt</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga0e9fa03f4014a0c0756de5d94f895112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversed square root.  <a href="group__core__hal__intrin.html#ga0e9fa03f4014a0c0756de5d94f895112">More...</a><br /></td></tr>
<tr class="separator:ga0e9fa03f4014a0c0756de5d94f895112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3a248d8a6078b73be09883bf2a5108"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga3f3a248d8a6078b73be09883bf2a5108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga3f3a248d8a6078b73be09883bf2a5108">cv::v_magnitude</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga3f3a248d8a6078b73be09883bf2a5108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnitude.  <a href="group__core__hal__intrin.html#ga3f3a248d8a6078b73be09883bf2a5108">More...</a><br /></td></tr>
<tr class="separator:ga3f3a248d8a6078b73be09883bf2a5108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51374eab401b0ef5b5efc8c31ea777c6"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga51374eab401b0ef5b5efc8c31ea777c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga51374eab401b0ef5b5efc8c31ea777c6">cv::v_sqr_magnitude</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga51374eab401b0ef5b5efc8c31ea777c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of the magnitude.  <a href="group__core__hal__intrin.html#ga51374eab401b0ef5b5efc8c31ea777c6">More...</a><br /></td></tr>
<tr class="separator:ga51374eab401b0ef5b5efc8c31ea777c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cf2ff062954f9ae2775f42de5ebf76"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga60cf2ff062954f9ae2775f42de5ebf76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga60cf2ff062954f9ae2775f42de5ebf76">cv::v_muladd</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c)</td></tr>
<tr class="memdesc:ga60cf2ff062954f9ae2775f42de5ebf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and add.  <a href="group__core__hal__intrin.html#ga60cf2ff062954f9ae2775f42de5ebf76">More...</a><br /></td></tr>
<tr class="separator:ga60cf2ff062954f9ae2775f42de5ebf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b7cdd3073adba3d9f3e0a2bc986809"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gac6b7cdd3073adba3d9f3e0a2bc986809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gac6b7cdd3073adba3d9f3e0a2bc986809">cv::v_dotprod</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gac6b7cdd3073adba3d9f3e0a2bc986809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of elements.  <a href="group__core__hal__intrin.html#gac6b7cdd3073adba3d9f3e0a2bc986809">More...</a><br /></td></tr>
<tr class="separator:gac6b7cdd3073adba3d9f3e0a2bc986809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb510213a964865860cccf6b1ee42bb"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga8bb510213a964865860cccf6b1ee42bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga8bb510213a964865860cccf6b1ee42bb">cv::v_mul_expand</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;c, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;d)</td></tr>
<tr class="memdesc:ga8bb510213a964865860cccf6b1ee42bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and expand.  <a href="group__core__hal__intrin.html#ga8bb510213a964865860cccf6b1ee42bb">More...</a><br /></td></tr>
<tr class="separator:ga8bb510213a964865860cccf6b1ee42bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ffc32658e008a149f259b1637cb0be"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga38ffc32658e008a149f259b1637cb0be"><td class="memTemplItemLeft" align="right" valign="top">V_TypeTraits&lt; _Tp &gt;::sum_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga38ffc32658e008a149f259b1637cb0be">cv::v_reduce_sum</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga38ffc32658e008a149f259b1637cb0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shift left.  <a href="group__core__hal__intrin.html#ga38ffc32658e008a149f259b1637cb0be">More...</a><br /></td></tr>
<tr class="separator:ga38ffc32658e008a149f259b1637cb0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191a888185e95f221c8203884e8d66ec"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga191a888185e95f221c8203884e8d66ec"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga191a888185e95f221c8203884e8d66ec">cv::v_signmask</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga191a888185e95f221c8203884e8d66ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get negative values mask.  <a href="group__core__hal__intrin.html#ga191a888185e95f221c8203884e8d66ec">More...</a><br /></td></tr>
<tr class="separator:ga191a888185e95f221c8203884e8d66ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a93a907f23a3e9028172d09b4822f8"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gad4a93a907f23a3e9028172d09b4822f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad4a93a907f23a3e9028172d09b4822f8">cv::v_check_all</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gad4a93a907f23a3e9028172d09b4822f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all packed values are less than zero.  <a href="group__core__hal__intrin.html#gad4a93a907f23a3e9028172d09b4822f8">More...</a><br /></td></tr>
<tr class="separator:gad4a93a907f23a3e9028172d09b4822f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03282d0b7c46861f1ecc7329a40634b3"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga03282d0b7c46861f1ecc7329a40634b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga03282d0b7c46861f1ecc7329a40634b3">cv::v_check_any</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga03282d0b7c46861f1ecc7329a40634b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of packed values is less than zero.  <a href="group__core__hal__intrin.html#ga03282d0b7c46861f1ecc7329a40634b3">More...</a><br /></td></tr>
<tr class="separator:ga03282d0b7c46861f1ecc7329a40634b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae440a2520e3b796df0be134e2fe6a7b0"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gae440a2520e3b796df0be134e2fe6a7b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gae440a2520e3b796df0be134e2fe6a7b0">cv::v_select</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;mask, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gae440a2520e3b796df0be134e2fe6a7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise select.  <a href="group__core__hal__intrin.html#gae440a2520e3b796df0be134e2fe6a7b0">More...</a><br /></td></tr>
<tr class="separator:gae440a2520e3b796df0be134e2fe6a7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga9eff16d8d73c6ce81122b3cd44a99627">cv::v_expand</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;b0, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;b1)</td></tr>
<tr class="memdesc:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand values to the wider pack type.  <a href="group__core__hal__intrin.html#ga9eff16d8d73c6ce81122b3cd44a99627">More...</a><br /></td></tr>
<tr class="separator:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ef6326f6c132d75c62391cedf7c187"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga19ef6326f6c132d75c62391cedf7c187"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga19ef6326f6c132d75c62391cedf7c187">cv::v_zip</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a0, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a1, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b0, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b1)</td></tr>
<tr class="memdesc:ga19ef6326f6c132d75c62391cedf7c187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave two vectors.  <a href="group__core__hal__intrin.html#ga19ef6326f6c132d75c62391cedf7c187">More...</a><br /></td></tr>
<tr class="separator:ga19ef6326f6c132d75c62391cedf7c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab665a422a89da120e3bd4bb76172437c"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gab665a422a89da120e3bd4bb76172437c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, V_SIMD128Traits&lt; _Tp &gt;::nlanes &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab665a422a89da120e3bd4bb76172437c">cv::v_load</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:gab665a422a89da120e3bd4bb76172437c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory.  <a href="group__core__hal__intrin.html#gab665a422a89da120e3bd4bb76172437c">More...</a><br /></td></tr>
<tr class="separator:gab665a422a89da120e3bd4bb76172437c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155f00bafccd79d36863c5546c786c0e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ga155f00bafccd79d36863c5546c786c0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, V_SIMD128Traits&lt; _Tp &gt;::nlanes &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga155f00bafccd79d36863c5546c786c0e">cv::v_load_aligned</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:ga155f00bafccd79d36863c5546c786c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory (aligned)  <a href="group__core__hal__intrin.html#ga155f00bafccd79d36863c5546c786c0e">More...</a><br /></td></tr>
<tr class="separator:ga155f00bafccd79d36863c5546c786c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e081b8017d09b6e5b31279b0d30a71"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ga01e081b8017d09b6e5b31279b0d30a71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, V_SIMD128Traits&lt; _Tp &gt;::nlanes &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga01e081b8017d09b6e5b31279b0d30a71">cv::v_load_halves</a> (const _Tp *loptr, const _Tp *hiptr)</td></tr>
<tr class="memdesc:ga01e081b8017d09b6e5b31279b0d30a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from two memory blocks.  <a href="group__core__hal__intrin.html#ga01e081b8017d09b6e5b31279b0d30a71">More...</a><br /></td></tr>
<tr class="separator:ga01e081b8017d09b6e5b31279b0d30a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05eb0581c713f32d2b64ffca86cea594"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ga05eb0581c713f32d2b64ffca86cea594"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, V_SIMD128Traits&lt; _Tp &gt;::nlanes/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga05eb0581c713f32d2b64ffca86cea594">cv::v_load_expand</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:ga05eb0581c713f32d2b64ffca86cea594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory with double expand.  <a href="group__core__hal__intrin.html#ga05eb0581c713f32d2b64ffca86cea594">More...</a><br /></td></tr>
<tr class="separator:ga05eb0581c713f32d2b64ffca86cea594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad618a34ccc2f1b3ec9ad4af831cba9ba"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gad618a34ccc2f1b3ec9ad4af831cba9ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::q_type, V_SIMD128Traits&lt; _Tp &gt;::nlanes/4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad618a34ccc2f1b3ec9ad4af831cba9ba">cv::v_load_expand_q</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:gad618a34ccc2f1b3ec9ad4af831cba9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory with quad expand.  <a href="group__core__hal__intrin.html#gad618a34ccc2f1b3ec9ad4af831cba9ba">More...</a><br /></td></tr>
<tr class="separator:gad618a34ccc2f1b3ec9ad4af831cba9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8e859406c66bb5b7d901473265119b"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gafd8e859406c66bb5b7d901473265119b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gafd8e859406c66bb5b7d901473265119b">cv::v_load_deinterleave</a> (const _Tp *ptr, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gafd8e859406c66bb5b7d901473265119b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and deinterleave (2 channels)  <a href="group__core__hal__intrin.html#gafd8e859406c66bb5b7d901473265119b">More...</a><br /></td></tr>
<tr class="separator:gafd8e859406c66bb5b7d901473265119b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab364b341969494d47e6a1b173fc46658"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gab364b341969494d47e6a1b173fc46658"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab364b341969494d47e6a1b173fc46658">cv::v_load_deinterleave</a> (const _Tp *ptr, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c)</td></tr>
<tr class="memdesc:gab364b341969494d47e6a1b173fc46658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and deinterleave (3 channels)  <a href="group__core__hal__intrin.html#gab364b341969494d47e6a1b173fc46658">More...</a><br /></td></tr>
<tr class="separator:gab364b341969494d47e6a1b173fc46658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga7f1f0d87d6210547bb125fd349a10e5d">cv::v_load_deinterleave</a> (const _Tp *ptr, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;d)</td></tr>
<tr class="memdesc:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and deinterleave (4 channels)  <a href="group__core__hal__intrin.html#ga7f1f0d87d6210547bb125fd349a10e5d">More...</a><br /></td></tr>
<tr class="separator:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990eea5fa77df9a033ef1e21c3c6f16e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga990eea5fa77df9a033ef1e21c3c6f16e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga990eea5fa77df9a033ef1e21c3c6f16e">cv::v_store_interleave</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga990eea5fa77df9a033ef1e21c3c6f16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave and store (2 channels)  <a href="group__core__hal__intrin.html#ga990eea5fa77df9a033ef1e21c3c6f16e">More...</a><br /></td></tr>
<tr class="separator:ga990eea5fa77df9a033ef1e21c3c6f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22d97d35e5e6f8d0f792d01c2dcea7f5"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga22d97d35e5e6f8d0f792d01c2dcea7f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga22d97d35e5e6f8d0f792d01c2dcea7f5">cv::v_store_interleave</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c)</td></tr>
<tr class="memdesc:ga22d97d35e5e6f8d0f792d01c2dcea7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave and store (3 channels)  <a href="group__core__hal__intrin.html#ga22d97d35e5e6f8d0f792d01c2dcea7f5">More...</a><br /></td></tr>
<tr class="separator:ga22d97d35e5e6f8d0f792d01c2dcea7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e803cc8edeef3c7c4e0367274e9ffa3"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga0e803cc8edeef3c7c4e0367274e9ffa3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga0e803cc8edeef3c7c4e0367274e9ffa3">cv::v_store_interleave</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;d)</td></tr>
<tr class="memdesc:ga0e803cc8edeef3c7c4e0367274e9ffa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave and store (4 channels)  <a href="group__core__hal__intrin.html#ga0e803cc8edeef3c7c4e0367274e9ffa3">More...</a><br /></td></tr>
<tr class="separator:ga0e803cc8edeef3c7c4e0367274e9ffa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275dfa9c8935f5e9a1031121cde460f4"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga275dfa9c8935f5e9a1031121cde460f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">cv::v_store</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga275dfa9c8935f5e9a1031121cde460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory.  <a href="group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">More...</a><br /></td></tr>
<tr class="separator:ga275dfa9c8935f5e9a1031121cde460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb662d09e37eae1e73043badee69612"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga3cb662d09e37eae1e73043badee69612"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga3cb662d09e37eae1e73043badee69612">cv::v_store_low</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga3cb662d09e37eae1e73043badee69612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory (lower half)  <a href="group__core__hal__intrin.html#ga3cb662d09e37eae1e73043badee69612">More...</a><br /></td></tr>
<tr class="separator:ga3cb662d09e37eae1e73043badee69612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1665beb52f3824499d3b6b1203890ada"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga1665beb52f3824499d3b6b1203890ada"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga1665beb52f3824499d3b6b1203890ada">cv::v_store_high</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga1665beb52f3824499d3b6b1203890ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory (higher half)  <a href="group__core__hal__intrin.html#ga1665beb52f3824499d3b6b1203890ada">More...</a><br /></td></tr>
<tr class="separator:ga1665beb52f3824499d3b6b1203890ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2733377e1bc373657d0e203028c74fc"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gaf2733377e1bc373657d0e203028c74fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaf2733377e1bc373657d0e203028c74fc">cv::v_store_aligned</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gaf2733377e1bc373657d0e203028c74fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory (aligned)  <a href="group__core__hal__intrin.html#gaf2733377e1bc373657d0e203028c74fc">More...</a><br /></td></tr>
<tr class="separator:gaf2733377e1bc373657d0e203028c74fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f131fad2680116c10c35b6ee660b190"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga9f131fad2680116c10c35b6ee660b190"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga9f131fad2680116c10c35b6ee660b190">cv::v_combine_low</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga9f131fad2680116c10c35b6ee660b190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine vector from first elements of two vectors.  <a href="group__core__hal__intrin.html#ga9f131fad2680116c10c35b6ee660b190">More...</a><br /></td></tr>
<tr class="separator:ga9f131fad2680116c10c35b6ee660b190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283fe35828ae5c7f94059f2f559d454f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga283fe35828ae5c7f94059f2f559d454f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga283fe35828ae5c7f94059f2f559d454f">cv::v_combine_high</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga283fe35828ae5c7f94059f2f559d454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine vector from last elements of two vectors.  <a href="group__core__hal__intrin.html#ga283fe35828ae5c7f94059f2f559d454f">More...</a><br /></td></tr>
<tr class="separator:ga283fe35828ae5c7f94059f2f559d454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga75a3cb5bb426fc37d9ed2f10e8706997">cv::v_recombine</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;low, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;high)</td></tr>
<tr class="memdesc:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two vectors from lower and higher parts of two other vectors.  <a href="group__core__hal__intrin.html#ga75a3cb5bb426fc37d9ed2f10e8706997">More...</a><br /></td></tr>
<tr class="separator:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd055cfd7ccb94ebb468a8b79afc819a"><td class="memTemplParams" colspan="2">template&lt;int s, typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gacd055cfd7ccb94ebb468a8b79afc819a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gacd055cfd7ccb94ebb468a8b79afc819a">cv::v_extract</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gacd055cfd7ccb94ebb468a8b79afc819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector extract.  <a href="group__core__hal__intrin.html#gacd055cfd7ccb94ebb468a8b79afc819a">More...</a><br /></td></tr>
<tr class="separator:gacd055cfd7ccb94ebb468a8b79afc819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e8380a09690c5c2de2dafbf1b8e326"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga10e8380a09690c5c2de2dafbf1b8e326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga10e8380a09690c5c2de2dafbf1b8e326">cv::v_round</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga10e8380a09690c5c2de2dafbf1b8e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round.  <a href="group__core__hal__intrin.html#ga10e8380a09690c5c2de2dafbf1b8e326">More...</a><br /></td></tr>
<tr class="separator:ga10e8380a09690c5c2de2dafbf1b8e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c95c494decd17905b43d47028370817"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga6c95c494decd17905b43d47028370817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga6c95c494decd17905b43d47028370817">cv::v_floor</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga6c95c494decd17905b43d47028370817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor.  <a href="group__core__hal__intrin.html#ga6c95c494decd17905b43d47028370817">More...</a><br /></td></tr>
<tr class="separator:ga6c95c494decd17905b43d47028370817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaff4ee2a4fab7233fd421a7236ac5c6"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:gabaff4ee2a4fab7233fd421a7236ac5c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gabaff4ee2a4fab7233fd421a7236ac5c6">cv::v_ceil</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gabaff4ee2a4fab7233fd421a7236ac5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ceil.  <a href="group__core__hal__intrin.html#gabaff4ee2a4fab7233fd421a7236ac5c6">More...</a><br /></td></tr>
<tr class="separator:gabaff4ee2a4fab7233fd421a7236ac5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b773c451fe920bfdf3c773860c9f334"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga4b773c451fe920bfdf3c773860c9f334"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4b773c451fe920bfdf3c773860c9f334">cv::v_trunc</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga4b773c451fe920bfdf3c773860c9f334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trunc.  <a href="group__core__hal__intrin.html#ga4b773c451fe920bfdf3c773860c9f334">More...</a><br /></td></tr>
<tr class="separator:ga4b773c451fe920bfdf3c773860c9f334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97980b3f12acb3028558e51231240a4e"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga97980b3f12acb3028558e51231240a4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga97980b3f12acb3028558e51231240a4e">cv::v_round</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga97980b3f12acb3028558e51231240a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fba933e3c72033673dfcd70cd345f15"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga1fba933e3c72033673dfcd70cd345f15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga1fba933e3c72033673dfcd70cd345f15">cv::v_floor</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga1fba933e3c72033673dfcd70cd345f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39fece1cbdac6895c5494ee2c9c097e9"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga39fece1cbdac6895c5494ee2c9c097e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga39fece1cbdac6895c5494ee2c9c097e9">cv::v_ceil</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga39fece1cbdac6895c5494ee2c9c097e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae347e0d88bcb9168f55043419b1ad6ec"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:gae347e0d88bcb9168f55043419b1ad6ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gae347e0d88bcb9168f55043419b1ad6ec">cv::v_trunc</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:gae347e0d88bcb9168f55043419b1ad6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140593e5fc051e291791899ad50976a6"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga140593e5fc051e291791899ad50976a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga140593e5fc051e291791899ad50976a6">cv::v_cvt_f32</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga140593e5fc051e291791899ad50976a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to float.  <a href="group__core__hal__intrin.html#ga140593e5fc051e291791899ad50976a6">More...</a><br /></td></tr>
<tr class="separator:ga140593e5fc051e291791899ad50976a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141c997ee79d87823fdcbb497ecb24f9"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga141c997ee79d87823fdcbb497ecb24f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga141c997ee79d87823fdcbb497ecb24f9">cv::v_cvt_f64</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; &amp;a)</td></tr>
<tr class="memdesc:ga141c997ee79d87823fdcbb497ecb24f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to double.  <a href="group__core__hal__intrin.html#ga141c997ee79d87823fdcbb497ecb24f9">More...</a><br /></td></tr>
<tr class="separator:ga141c997ee79d87823fdcbb497ecb24f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab419b9546c2d6a95a38b60e2ea32ccc5"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:gab419b9546c2d6a95a38b60e2ea32ccc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab419b9546c2d6a95a38b60e2ea32ccc5">cv::v_cvt_f64</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n *2 &gt; &amp;a)</td></tr>
<tr class="memdesc:gab419b9546c2d6a95a38b60e2ea32ccc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to double.  <a href="group__core__hal__intrin.html#gab419b9546c2d6a95a38b60e2ea32ccc5">More...</a><br /></td></tr>
<tr class="separator:gab419b9546c2d6a95a38b60e2ea32ccc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaf8bdcd643d22a9fc9c3f0ed202535928">cv::v_transpose4x4</a> (<a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a0, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a1, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a2, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a3, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b0, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b1, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b2, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b3)</td></tr>
<tr class="memdesc:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose 4x4 matrix.  <a href="group__core__hal__intrin.html#gaf8bdcd643d22a9fc9c3f0ed202535928">More...</a><br /></td></tr>
<tr class="separator:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f53754058cbcd76b98db8525cefe869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4f53754058cbcd76b98db8525cefe869">cv::v_matmul</a> (const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;v, const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;m0, const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;m1, const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;m2, const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;m3)</td></tr>
<tr class="memdesc:ga4f53754058cbcd76b98db8525cefe869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication.  <a href="group__core__hal__intrin.html#ga4f53754058cbcd76b98db8525cefe869">More...</a><br /></td></tr>
<tr class="separator:ga4f53754058cbcd76b98db8525cefe869"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>"Universal intrinsics" is a types and functions set intended to simplify vectorization of code on different platforms. Currently there are two supported SIMD extensions: <b>SSE/SSE2</b> on x86 architectures and <b>NEON</b> on ARM architectures, both allow working with 128 bit registers containing packed values of different types. In case when there is no SIMD extension available during compilation, fallback C++ implementation of intrinsics will be chosen and code will work as expected although it could be slower.</p>
<h3>Types</h3>
<p>There are several types representing 128-bit register as a vector of packed values, each type is implemented as a structure based on a one SIMD register.</p>
<ul>
<li>cv::v_uint8x16 and cv::v_int8x16: sixteen 8-bit integer values (unsigned/signed) - char</li>
<li>cv::v_uint16x8 and cv::v_int16x8: eight 16-bit integer values (unsigned/signed) - short</li>
<li>cv::v_uint32x4 and cv::v_int32x4: four 32-bit integer values (unsgined/signed) - int</li>
<li>cv::v_uint64x2 and cv::v_int64x2: two 64-bit integer values (unsigned/signed) - int64</li>
<li>cv::v_float32x4: four 32-bit floating point values (signed) - float</li>
<li>cv::v_float64x2: two 64-bit floating point valies (signed) - double</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>cv::v_float64x2 is not implemented in NEON variant, if you want to use this type, don't forget to check the CV_SIMD128_64F preprocessor definition: <div class="fragment"><div class="line"><span class="preprocessor">#if CV_SIMD128_64F</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></dd></dl>
<h3>Load and store operations</h3>
<p>These operations allow to set contents of the register explicitly or by loading it from some memory block and to save contents of the register to memory block.</p>
<ul>
<li>Constructors: <a class="el" href="structcv_1_1v__reg.html#a9791853618ca6b65cc0868de0f117728">from memory</a>, <a class="el" href="structcv_1_1v__reg.html#adcf59996aa232fa9b65dc3ce295d5183">from two values</a>, ...</li>
<li>Other create methods: v_setall_s8, v_setall_u8, ..., v_setzero_u8, v_setzero_s8, ...</li>
<li>Memory operations: v_load, v_load_aligned, v_load_halves, v_store, v_store_aligned, v_store_high, v_store_low</li>
</ul>
<h3>Value reordering</h3>
<p>These operations allow to reorder or recombine elements in one or multiple vectors.</p>
<ul>
<li>Interleave, deinterleave (2, 3 and 4 channels): v_load_deinterleave, v_store_interleave</li>
<li>Expand: v_load_expand, v_load_expand_q, v_expand</li>
<li>Pack: v_pack, v_pack_u, v_rshr_pack, v_rshr_pack_u, v_pack_store, v_pack_u_store, v_rshr_pack_store, v_rshr_pack_u_store</li>
<li>Recombine: v_zip, v_recombine, v_combine_low, v_combine_high</li>
<li>Extract: v_extract</li>
</ul>
<h3>Arithmetic, bitwise and comparison operations</h3>
<p>Element-wise binary and unary operations.</p>
<ul>
<li>Arithmetics: +, -, *, /, v_mul_expand</li>
<li>Non-saturating arithmetics: v_add_wrap, v_sub_wrap</li>
<li>Bitwise shifts: &lt;&lt;, &gt;&gt;, v_shl, v_shr</li>
<li>Bitwise logic: &amp;, |, ^, ~</li>
<li>Comparison: &gt;, &gt;=, &lt;, &lt;=, ==, !=</li>
<li>min/max: v_min, v_max</li>
</ul>
<h3>Reduce and mask</h3>
<p>Most of these operations return only one value.</p>
<ul>
<li>Reduce: v_reduce_min, v_reduce_max, v_reduce_sum</li>
<li>Mask: v_signmask, v_check_all, v_check_any, v_select</li>
</ul>
<h3>Other math</h3>
<ul>
<li>Some frequent operations: v_sqrt, v_invsqrt, v_magnitude, v_sqr_magnitude</li>
<li>Absolute values: v_abs, v_absdiff</li>
</ul>
<h3>Conversions</h3>
<p>Different type conversions and casts:</p>
<ul>
<li>Rounding: v_round, v_floor, v_ceil, v_trunc,</li>
<li>To float: v_cvt_f32, v_cvt_f64</li>
<li>Reinterpret: v_reinterpret_as_u8, v_reinterpret_as_s8, ...</li>
</ul>
<h3>Matrix operations</h3>
<p>In these operations vectors represent matrix rows/columns: v_dotprod, v_matmul, v_transpose4x4</p>
<h3>Usability</h3>
<p>Most operations are implemented only for some subset of the available types, following matrices shows the applicability of different operations to the types.</p>
<p>Regular integers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations\Types  </th><th class="markdownTableHeadCenter">uint 8x16  </th><th class="markdownTableHeadCenter" colspan="5">int 8x16   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">load, store  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">interleave  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">expand  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">expand_q  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">add, sub  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">add_wrap, sub_wrap  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mul  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">mul_expand  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">compare  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">shift  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dotprod  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">logical  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">min, max  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">absdiff  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reduce  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">mask  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pack  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">pack_u  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unpack  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">extract  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cvt_flt32  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">cvt_flt64  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">transpose4x4  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<p>Big integers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations\Types  </th><th class="markdownTableHeadCenter" colspan="2">uint 6   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">load, store  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">add, sub  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">shift  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">logical  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">extract  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<p>Floating point:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations\Types  </th><th class="markdownTableHeadCenter" colspan="2">float   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">load, store  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">interleave  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">add, sub  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">mul  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">div  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">compare  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">min, max  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">absdiff  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reduce  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">mask  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unpack  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">cvt_flt32  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cvt_flt64  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">sqrt, abs  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float math  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">transpose4x4  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6238e30480f4a52f3b30d5c21bbbadb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6238e30480f4a52f3b30d5c21bbbadb1">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise AND. </p>
<p>Only for integer types. Bitwise OR</p>
<p>Only for integer types. Bitwise XOR</p>
<p>Only for integer types. Bitwise NOT</p>
<p>Only for integer types. </p>

</div>
</div>
<a id="ga1767714db3dcadb809e7186824764796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1767714db3dcadb809e7186824764796">&#9670;&nbsp;</a></span>v_absdiff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> cv::v_absdiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>For 32-bit floating point values </p>

</div>
</div>
<a id="gaedcb5a63b95a345d4da1d278b4617547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcb5a63b95a345d4da1d278b4617547">&#9670;&nbsp;</a></span>v_absdiff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gafc604f432c648ca88335be4fcc4de25d">v_float64x2</a> cv::v_absdiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gafc604f432c648ca88335be4fcc4de25d">v_float64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gafc604f432c648ca88335be4fcc4de25d">v_float64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>For 64-bit floating point values </p>

</div>
</div>
<a id="gabaff4ee2a4fab7233fd421a7236ac5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaff4ee2a4fab7233fd421a7236ac5c6">&#9670;&nbsp;</a></span>v_ceil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n&gt; cv::v_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ceil. </p>
<p>Ceil each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="ga39fece1cbdac6895c5494ee2c9c097e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39fece1cbdac6895c5494ee2c9c097e9">&#9670;&nbsp;</a></span>v_ceil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n*2&gt; cv::v_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad4a93a907f23a3e9028172d09b4822f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4a93a907f23a3e9028172d09b4822f8">&#9670;&nbsp;</a></span>v_check_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cv::v_check_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all packed values are less than zero. </p>
<p>Unsigned values will be casted to signed: <code>uchar 254 =&gt; char -2</code>. For all types except 64-bit. </p>

</div>
</div>
<a id="ga03282d0b7c46861f1ecc7329a40634b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03282d0b7c46861f1ecc7329a40634b3">&#9670;&nbsp;</a></span>v_check_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cv::v_check_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if any of packed values is less than zero. </p>
<p>Unsigned values will be casted to signed: <code>uchar 254 =&gt; char -2</code>. For all types except 64-bit. </p>

</div>
</div>
<a id="ga283fe35828ae5c7f94059f2f559d454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga283fe35828ae5c7f94059f2f559d454f">&#9670;&nbsp;</a></span>v_combine_high()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_combine_high </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine vector from last elements of two vectors. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">---------------</div><div class="line">  {A3 A4 B3 B4}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga9f131fad2680116c10c35b6ee660b190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f131fad2680116c10c35b6ee660b190">&#9670;&nbsp;</a></span>v_combine_low()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_combine_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine vector from first elements of two vectors. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">---------------</div><div class="line">  {A1 A2 B1 B2}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga140593e5fc051e291791899ad50976a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140593e5fc051e291791899ad50976a6">&#9670;&nbsp;</a></span>v_cvt_f32()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;float, n&gt; cv::v_cvt_f32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to float. </p>
<p>Supported input type is cv::v_int32x4. </p>

</div>
</div>
<a id="ga141c997ee79d87823fdcbb497ecb24f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga141c997ee79d87823fdcbb497ecb24f9">&#9670;&nbsp;</a></span>v_cvt_f64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;double, n&gt; cv::v_cvt_f64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to double. </p>
<p>Supported input type is cv::v_int32x4. </p>

</div>
</div>
<a id="gab419b9546c2d6a95a38b60e2ea32ccc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab419b9546c2d6a95a38b60e2ea32ccc5">&#9670;&nbsp;</a></span>v_cvt_f64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;double, n&gt; cv::v_cvt_f64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n *2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to double. </p>
<p>Supported input type is cv::v_float32x4. </p>

</div>
</div>
<a id="gac6b7cdd3073adba3d9f3e0a2bc986809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b7cdd3073adba3d9f3e0a2bc986809">&#9670;&nbsp;</a></span>v_dotprod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;typename V_TypeTraits&lt;_Tp&gt;::w_type, n/2&gt; cv::v_dotprod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product of elements. </p>
<p>Multiply values in two registers and sum adjacent result pairs. Scheme: </p><div class="fragment"><div class="line">  {A1 A2 ...} <span class="comment">// 16-bit</span></div><div class="line">x {B1 B2 ...} <span class="comment">// 16-bit</span></div><div class="line">-------------</div><div class="line">{A1B1+A2B2 ...} <span class="comment">// 32-bit</span></div></div><!-- fragment --><p> Implemented only for 16-bit signed source type (v_int16x8). </p>

</div>
</div>
<a id="ga9eff16d8d73c6ce81122b3cd44a99627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eff16d8d73c6ce81122b3cd44a99627">&#9670;&nbsp;</a></span>v_expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_expand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand values to the wider pack type. </p>
<p>Copy contents of register to two registers with 2x wider pack type. Scheme: </p><div class="fragment"><div class="line"> int32x4     int64x2 int64x2</div><div class="line">{A B C D} ==&gt; {A B} , {C D}</div></div><!-- fragment --> 
</div>
</div>
<a id="gacd055cfd7ccb94ebb468a8b79afc819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd055cfd7ccb94ebb468a8b79afc819a">&#9670;&nbsp;</a></span>v_extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s, typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector extract. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">========================</div><div class="line">shift = 1  {A2 A3 A4 B1}</div><div class="line">shift = 2  {A3 A4 B1 B2}</div><div class="line">shift = 3  {A4 B1 B2 B3}</div></div><!-- fragment --><p> Restriction: 0 &lt;= shift &lt; nlanes</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="group__core__hal__intrin.html#ga4c6899623e3f4b0d89737817e7f83ff4">v_int32x4</a> a, b, c;</div><div class="line">c = v_extract&lt;2&gt;(a, b);</div></div><!-- fragment --><p> For integer types only. </p>

</div>
</div>
<a id="ga6c95c494decd17905b43d47028370817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c95c494decd17905b43d47028370817">&#9670;&nbsp;</a></span>v_floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n&gt; cv::v_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Floor. </p>
<p>Floor each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="ga1fba933e3c72033673dfcd70cd345f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fba933e3c72033673dfcd70cd345f15">&#9670;&nbsp;</a></span>v_floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n*2&gt; cv::v_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga0e9fa03f4014a0c0756de5d94f895112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e9fa03f4014a0c0756de5d94f895112">&#9670;&nbsp;</a></span>v_invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inversed square root. </p>
<p>Returns <img class="formulaInl" alt="$ 1/sqrt(a) $" src="form_168.png"/> For floating point types only. </p>

</div>
</div>
<a id="gab665a422a89da120e3bd4bb76172437c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab665a422a89da120e3bd4bb76172437c">&#9670;&nbsp;</a></span>v_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, V_SIMD128Traits&lt;_Tp&gt;::nlanes&gt; cv::v_load </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load register contents from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to memory block with data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>register object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returned type will be detected from passed pointer type, for example uchar ==&gt; cv::v_uint8x16, int ==&gt; cv::v_int32x4, etc. </dd></dl>

</div>
</div>
<a id="ga155f00bafccd79d36863c5546c786c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga155f00bafccd79d36863c5546c786c0e">&#9670;&nbsp;</a></span>v_load_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, V_SIMD128Traits&lt;_Tp&gt;::nlanes&gt; cv::v_load_aligned </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load register contents from memory (aligned) </p>
<p>similar to cv::v_load, but source memory block should be aligned (to 16-byte boundary) </p>

</div>
</div>
<a id="gafd8e859406c66bb5b7d901473265119b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8e859406c66bb5b7d901473265119b">&#9670;&nbsp;</a></span>v_load_deinterleave() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_load_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load and deinterleave (2 channels) </p>
<p>Load data from memory deinterleave and store to 2 registers. Scheme: </p><div class="fragment"><div class="line">{A1 B1 A2 B2 ...} ==&gt; {A1 A2 ...}, {B1 B2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="gab364b341969494d47e6a1b173fc46658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab364b341969494d47e6a1b173fc46658">&#9670;&nbsp;</a></span>v_load_deinterleave() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_load_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load and deinterleave (3 channels) </p>
<p>Load data from memory deinterleave and store to 3 registers. Scheme: </p><div class="fragment"><div class="line">{A1 B1 C1 A2 B2 C2 ...} ==&gt; {A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga7f1f0d87d6210547bb125fd349a10e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1f0d87d6210547bb125fd349a10e5d">&#9670;&nbsp;</a></span>v_load_deinterleave() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_load_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load and deinterleave (4 channels) </p>
<p>Load data from memory deinterleave and store to 4 registers. Scheme: </p><div class="fragment"><div class="line">{A1 B1 C1 D1 A2 B2 C2 D2 ...} ==&gt; {A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...}, {D1 D2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga05eb0581c713f32d2b64ffca86cea594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05eb0581c713f32d2b64ffca86cea594">&#9670;&nbsp;</a></span>v_load_expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;typename V_TypeTraits&lt;_Tp&gt;::w_type, V_SIMD128Traits&lt;_Tp&gt;::nlanes / 2&gt; cv::v_load_expand </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load register contents from memory with double expand. </p>
<p>Same as cv::v_load, but result pack type will be 2x wider than memory type.</p>
<div class="fragment"><div class="line"><span class="keywordtype">short</span> buf[4] = {1, 2, 3, 4}; <span class="comment">// type is int16</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga4c6899623e3f4b0d89737817e7f83ff4">v_int32x4</a> r = <a class="code" href="group__core__hal__intrin.html#ga05eb0581c713f32d2b64ffca86cea594">v_load_expand</a>(buf); <span class="comment">// r = {1, 2, 3, 4} - type is int32</span></div></div><!-- fragment --><p> For 8-, 16-, 32-bit integer source types. </p>

</div>
</div>
<a id="gad618a34ccc2f1b3ec9ad4af831cba9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad618a34ccc2f1b3ec9ad4af831cba9ba">&#9670;&nbsp;</a></span>v_load_expand_q()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;typename V_TypeTraits&lt;_Tp&gt;::q_type, V_SIMD128Traits&lt;_Tp&gt;::nlanes / 4&gt; cv::v_load_expand_q </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load register contents from memory with quad expand. </p>
<p>Same as cv::v_load_expand, but result type is 4 times wider than source. </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> buf[4] = {1, 2, 3, 4}; <span class="comment">// type is int8</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga4c6899623e3f4b0d89737817e7f83ff4">v_int32x4</a> r = v_load_q(buf); <span class="comment">// r = {1, 2, 3, 4} - type is int32</span></div></div><!-- fragment --><p> For 8-bit integer source types. </p>

</div>
</div>
<a id="ga01e081b8017d09b6e5b31279b0d30a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01e081b8017d09b6e5b31279b0d30a71">&#9670;&nbsp;</a></span>v_load_halves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, V_SIMD128Traits&lt;_Tp&gt;::nlanes&gt; cv::v_load_halves </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>loptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>hiptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load register contents from two memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loptr</td><td>memory block containing data for first half (0..n/2) </td></tr>
    <tr><td class="paramname">hiptr</td><td>memory block containing data for second half (n/2..n)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> lo[2] = { 1, 2 }, hi[2] = { 3, 4 };</div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga4c6899623e3f4b0d89737817e7f83ff4">v_int32x4</a> r = <a class="code" href="group__core__hal__intrin.html#ga01e081b8017d09b6e5b31279b0d30a71">v_load_halves</a>(lo, hi);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3f3a248d8a6078b73be09883bf2a5108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3a248d8a6078b73be09883bf2a5108">&#9670;&nbsp;</a></span>v_magnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Magnitude. </p>
<p>Returns <img class="formulaInl" alt="$ sqrt(a^2 + b^2) $" src="form_169.png"/> For floating point types only. </p>

</div>
</div>
<a id="ga4f53754058cbcd76b98db8525cefe869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f53754058cbcd76b98db8525cefe869">&#9670;&nbsp;</a></span>v_matmul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> cv::v_matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gad1f972902dd8ee6dd7c2ebeb845728d4">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix multiplication. </p>
<p>Scheme: </p><div class="fragment"><div class="line">{A0 A1 A2 A3}   |V0|</div><div class="line">{B0 B1 B2 B3}   |V1|</div><div class="line">{C0 C1 C2 C3}   |V2|</div><div class="line">{D0 D1 D2 D3} x |V3|</div><div class="line">====================</div><div class="line">{R0 R1 R2 R3}, where:</div><div class="line">R0 = A0V0 + A1V1 + A2V2 + A3V3,</div><div class="line">R1 = B0V0 + B1V1 + B2V2 + B3V3</div><div class="line">...</div></div><!-- fragment --> 
</div>
</div>
<a id="ga8bb510213a964865860cccf6b1ee42bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb510213a964865860cccf6b1ee42bb">&#9670;&nbsp;</a></span>v_mul_expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_mul_expand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename V_TypeTraits&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply and expand. </p>
<p>Multiply values two registers and store results in two registers with wider pack type. Scheme: </p><div class="fragment"><div class="line">  {A B C D} <span class="comment">// 32-bit</span></div><div class="line">x {E F G H} <span class="comment">// 32-bit</span></div><div class="line">---------------</div><div class="line">{AE BF}         <span class="comment">// 64-bit</span></div><div class="line">        {CG DH} <span class="comment">// 64-bit</span></div></div><!-- fragment --><p> Example: </p><div class="fragment"><div class="line"><a class="code" href="group__core__hal__intrin.html#ga5859d41d20a075cff6b832f0d64ee042">v_uint32x4</a> a, b; <span class="comment">// {1,2,3,4} and {2,2,2,2}</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#gab32d838ec60649d90504438b02beeb40">v_uint64x2</a> c, d; <span class="comment">// results</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga8bb510213a964865860cccf6b1ee42bb">v_mul_expand</a>(a, b, c, d); <span class="comment">// c, d = {2,4}, {6, 8}</span></div></div><!-- fragment --><p> Implemented only for 16- and unsigned 32-bit source types (v_int16x8, v_uint16x8, v_uint32x4). </p>

</div>
</div>
<a id="ga60cf2ff062954f9ae2775f42de5ebf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60cf2ff062954f9ae2775f42de5ebf76">&#9670;&nbsp;</a></span>v_muladd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_muladd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply and add. </p>
<p>Returns <img class="formulaInl" alt="$ a*b + c $" src="form_171.png"/> For floating point types only. </p>

</div>
</div>
<a id="ga75a3cb5bb426fc37d9ed2f10e8706997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75a3cb5bb426fc37d9ed2f10e8706997">&#9670;&nbsp;</a></span>v_recombine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_recombine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine two vectors from lower and higher parts of two other vectors. </p>
<div class="fragment"><div class="line">low = <a class="code" href="group__core__hal__intrin.html#ga9f131fad2680116c10c35b6ee660b190">cv::v_combine_low</a>(a, b);</div><div class="line">high = <a class="code" href="group__core__hal__intrin.html#ga283fe35828ae5c7f94059f2f559d454f">cv::v_combine_high</a>(a, b);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga38ffc32658e008a149f259b1637cb0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ffc32658e008a149f259b1637cb0be">&#9670;&nbsp;</a></span>v_reduce_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V_TypeTraits&lt;_Tp&gt;::sum_type cv::v_reduce_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shift left. </p>
<p>For 16-, 32- and 64-bit integer values. Bitwise shift right</p>
<p>For 16-, 32- and 64-bit integer values. Sum packed values</p>
<p>Scheme: </p><div class="fragment"><div class="line">{A1 A2 A3 ...} =&gt; sum{A1,A2,A3,...}</div></div><!-- fragment --><p> For 32-bit integer and 32-bit floating point types. </p>

</div>
</div>
<a id="ga10e8380a09690c5c2de2dafbf1b8e326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e8380a09690c5c2de2dafbf1b8e326">&#9670;&nbsp;</a></span>v_round() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n&gt; cv::v_round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round. </p>
<p>Rounds each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="ga97980b3f12acb3028558e51231240a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97980b3f12acb3028558e51231240a4e">&#9670;&nbsp;</a></span>v_round() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n*2&gt; cv::v_round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae440a2520e3b796df0be134e2fe6a7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae440a2520e3b796df0be134e2fe6a7b0">&#9670;&nbsp;</a></span>v_select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise select. </p>
<p>Return value will be built by combining values a and b using the following scheme: If the i-th bit in <em>mask</em> is 1 select i-th bit from <em>a</em> else select i-th bit from <em>b</em> </p>

</div>
</div>
<a id="ga191a888185e95f221c8203884e8d66ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga191a888185e95f221c8203884e8d66ec">&#9670;&nbsp;</a></span>v_signmask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cv::v_signmask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get negative values mask. </p>
<p>Returned value is a bit mask with bits set to 1 on places corresponding to negative packed values indexes. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__core__hal__intrin.html#ga4c6899623e3f4b0d89737817e7f83ff4">v_int32x4</a> r; <span class="comment">// set to {-1, -1, 1, 1}</span></div><div class="line"><span class="keywordtype">int</span> mask = <a class="code" href="group__core__hal__intrin.html#ga191a888185e95f221c8203884e8d66ec">v_signmask</a>(r); <span class="comment">// mask = 3 &lt;== 00000000 00000000 00000000 00000011</span></div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga51374eab401b0ef5b5efc8c31ea777c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51374eab401b0ef5b5efc8c31ea777c6">&#9670;&nbsp;</a></span>v_sqr_magnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;_Tp, n&gt; cv::v_sqr_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of the magnitude. </p>
<p>Returns <img class="formulaInl" alt="$ a^2 + b^2 $" src="form_170.png"/> For floating point types only. </p>

</div>
</div>
<a id="ga275dfa9c8935f5e9a1031121cde460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga275dfa9c8935f5e9a1031121cde460f4">&#9670;&nbsp;</a></span>v_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store data to memory. </p>
<p>Store register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {A B C D}</div></div><!-- fragment --><p> Pointer can be unaligned. </p>

</div>
</div>
<a id="gaf2733377e1bc373657d0e203028c74fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2733377e1bc373657d0e203028c74fc">&#9670;&nbsp;</a></span>v_store_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_aligned </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store data to memory (aligned) </p>
<p>Store register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {A B C D}</div></div><!-- fragment --><p> Pointer <b>should</b> be aligned by 16-byte boundary. </p>

</div>
</div>
<a id="ga1665beb52f3824499d3b6b1203890ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1665beb52f3824499d3b6b1203890ada">&#9670;&nbsp;</a></span>v_store_high()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_high </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store data to memory (higher half) </p>
<p>Store higher half of register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {C D}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga990eea5fa77df9a033ef1e21c3c6f16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga990eea5fa77df9a033ef1e21c3c6f16e">&#9670;&nbsp;</a></span>v_store_interleave() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_interleave </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleave and store (2 channels) </p>
<p>Interleave and store data from 2 registers to memory. Scheme: </p><div class="fragment"><div class="line">{A1 A2 ...}, {B1 B2 ...} ==&gt; {A1 B1 A2 B2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga22d97d35e5e6f8d0f792d01c2dcea7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22d97d35e5e6f8d0f792d01c2dcea7f5">&#9670;&nbsp;</a></span>v_store_interleave() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_interleave </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleave and store (3 channels) </p>
<p>Interleave and store data from 3 registers to memory. Scheme: </p><div class="fragment"><div class="line">{A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...} ==&gt; {A1 B1 C1 A2 B2 C2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga0e803cc8edeef3c7c4e0367274e9ffa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e803cc8edeef3c7c4e0367274e9ffa3">&#9670;&nbsp;</a></span>v_store_interleave() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_interleave </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleave and store (4 channels) </p>
<p>Interleave and store data from 4 registers to memory. Scheme: </p><div class="fragment"><div class="line">{A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...}, {D1 D2 ...} ==&gt; {A1 B1 C1 D1 A2 B2 C2 D2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga3cb662d09e37eae1e73043badee69612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb662d09e37eae1e73043badee69612">&#9670;&nbsp;</a></span>v_store_low()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_low </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store data to memory (lower half) </p>
<p>Store lower half of register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {A B}</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf8bdcd643d22a9fc9c3f0ed202535928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8bdcd643d22a9fc9c3f0ed202535928">&#9670;&nbsp;</a></span>v_transpose4x4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_transpose4x4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose 4x4 matrix. </p>
<p>Scheme: </p><div class="fragment"><div class="line">a0  {A1 A2 A3 A4}</div><div class="line">a1  {B1 B2 B3 B4}</div><div class="line">a2  {C1 C2 C3 C4}</div><div class="line">a3  {D1 D2 D3 D4}</div><div class="line">===============</div><div class="line">b0  {A1 B1 C1 D1}</div><div class="line">b1  {A2 B2 C2 D2}</div><div class="line">b2  {A3 B3 C3 D3}</div><div class="line">b3  {A4 B4 C4 D4}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga4b773c451fe920bfdf3c773860c9f334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b773c451fe920bfdf3c773860c9f334">&#9670;&nbsp;</a></span>v_trunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n&gt; cv::v_trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trunc. </p>
<p>Truncate each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="gae347e0d88bcb9168f55043419b1ad6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae347e0d88bcb9168f55043419b1ad6ec">&#9670;&nbsp;</a></span>v_trunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt;int, n*2&gt; cv::v_trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga19ef6326f6c132d75c62391cedf7c187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19ef6326f6c132d75c62391cedf7c187">&#9670;&nbsp;</a></span>v_zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_zip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interleave two vectors. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">---------------</div><div class="line">  {A1 B1 A2 B2} and {A3 B3 A4 B4}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
