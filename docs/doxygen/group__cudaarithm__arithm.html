<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2018-inseason: Arithm Operations on Matrices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">2018-inseason
   </div>
   <div id="projectbrief">The Greybots&#39; 2018 Power Up code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Arithm Operations on Matrices<div class="ingroups"><a class="el" href="group__core.html">Core functionality</a> &raquo; <a class="el" href="group__core__opengl.html">OpenGL interoperability</a> &raquo; <a class="el" href="group__cuda.html">CUDA-accelerated Computer Vision</a> &raquo; <a class="el" href="group__cudaarithm.html">Operations on Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_convolution.html">cv::cuda::Convolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for convolution (or cross-correlation) operator. :  <a href="classcv_1_1cuda_1_1_convolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga85da42c86ead745f4533dba92ec4d70b"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudaarithm__arithm.html#ga85da42c86ead745f4533dba92ec4d70b">cv::cuda::gemm</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> src1, <a class="el" href="classcv_1_1___input_array.html">InputArray</a> src2, double alpha, <a class="el" href="classcv_1_1___input_array.html">InputArray</a> src3, double beta, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, int flags=0, <a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream=<a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>())</td></tr>
<tr class="memdesc:ga85da42c86ead745f4533dba92ec4d70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs generalized matrix multiplication.  <a href="group__cudaarithm__arithm.html#ga85da42c86ead745f4533dba92ec4d70b">More...</a><br /></td></tr>
<tr class="separator:ga85da42c86ead745f4533dba92ec4d70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ce4319fb3eaecb6e8cbdb26b8e0829"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudaarithm__arithm.html#ga10ce4319fb3eaecb6e8cbdb26b8e0829">cv::cuda::mulSpectrums</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> src1, <a class="el" href="classcv_1_1___input_array.html">InputArray</a> src2, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, int flags, bool conjB=false, <a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream=<a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>())</td></tr>
<tr class="memdesc:ga10ce4319fb3eaecb6e8cbdb26b8e0829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a per-element multiplication of two Fourier spectrums.  <a href="group__cudaarithm__arithm.html#ga10ce4319fb3eaecb6e8cbdb26b8e0829">More...</a><br /></td></tr>
<tr class="separator:ga10ce4319fb3eaecb6e8cbdb26b8e0829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbdc870ff112ebb0e148a09d7199a8b7"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudaarithm__arithm.html#gacbdc870ff112ebb0e148a09d7199a8b7">cv::cuda::mulAndScaleSpectrums</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> src1, <a class="el" href="classcv_1_1___input_array.html">InputArray</a> src2, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, int flags, float scale, bool conjB=false, <a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream=<a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>())</td></tr>
<tr class="memdesc:gacbdc870ff112ebb0e148a09d7199a8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a per-element multiplication of two Fourier spectrums and scales the result.  <a href="group__cudaarithm__arithm.html#gacbdc870ff112ebb0e148a09d7199a8b7">More...</a><br /></td></tr>
<tr class="separator:gacbdc870ff112ebb0e148a09d7199a8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab34c6d3177a4cec8670bd30576c2b9"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudaarithm__arithm.html#ga5ab34c6d3177a4cec8670bd30576c2b9">cv::cuda::dft</a> (<a class="el" href="classcv_1_1___input_array.html">InputArray</a> src, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, <a class="el" href="classcv_1_1_size__.html">Size</a> dft_size, int flags=0, <a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream=<a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>())</td></tr>
<tr class="memdesc:ga5ab34c6d3177a4cec8670bd30576c2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a forward or inverse discrete Fourier transform (1D or 2D) of the floating point matrix.  <a href="group__cudaarithm__arithm.html#ga5ab34c6d3177a4cec8670bd30576c2b9">More...</a><br /></td></tr>
<tr class="separator:ga5ab34c6d3177a4cec8670bd30576c2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bae38f949d50930e22f0e39bc58372c"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS <a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1cuda_1_1_convolution.html">Convolution</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudaarithm__arithm.html#ga1bae38f949d50930e22f0e39bc58372c">cv::cuda::createConvolution</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> user_block_size=<a class="el" href="classcv_1_1_size__.html">Size</a>())</td></tr>
<tr class="memdesc:ga1bae38f949d50930e22f0e39bc58372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates implementation for <a class="el" href="classcv_1_1cuda_1_1_convolution.html" title="Base class for convolution (or cross-correlation) operator. : ">cuda::Convolution</a> .  <a href="group__cudaarithm__arithm.html#ga1bae38f949d50930e22f0e39bc58372c">More...</a><br /></td></tr>
<tr class="separator:ga1bae38f949d50930e22f0e39bc58372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1bae38f949d50930e22f0e39bc58372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bae38f949d50930e22f0e39bc58372c">&#9670;&nbsp;</a></span>createConvolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS <a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt;<a class="el" href="classcv_1_1cuda_1_1_convolution.html">Convolution</a>&gt; cv::cuda::createConvolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>user_block_size</em> = <code><a class="el" href="classcv_1_1_size__.html">Size</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates implementation for <a class="el" href="classcv_1_1cuda_1_1_convolution.html" title="Base class for convolution (or cross-correlation) operator. : ">cuda::Convolution</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_block_size</td><td>Block size. If you leave default value Size(0,0) then automatic estimation of block size will be used (which is optimized for speed). By varying user_block_size you can reduce memory requirements at the cost of speed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ab34c6d3177a4cec8670bd30576c2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ab34c6d3177a4cec8670bd30576c2b9">&#9670;&nbsp;</a></span>dft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::cuda::dft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>dft_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a forward or inverse discrete Fourier transform (1D or 2D) of the floating point matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source matrix (real or complex). </td></tr>
    <tr><td class="paramname">dst</td><td>Destination matrix (real or complex). </td></tr>
    <tr><td class="paramname">dft_size</td><td>Size of a discrete Fourier transform. </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags:<ul>
<li><b>DFT_ROWS</b> transforms each individual row of the source matrix.</li>
<li><b>DFT_SCALE</b> scales the result: divide it by the number of elements in the transform (obtained from dft_size ).</li>
<li><b>DFT_INVERSE</b> inverts DFT. Use for complex-complex cases (real-complex and complex-real cases are always forward and inverse, respectively).</li>
<li><b>DFT_REAL_OUTPUT</b> specifies the output as real. The source matrix is the result of real-complex transform, so the destination matrix must be real. </li>
</ul>
</td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="classcv_1_1cuda_1_1_stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>Use to handle real matrices ( CV32FC1 ) and complex matrices in the interleaved format ( CV32FC2 ).</p>
<p>The source matrix should be continuous, otherwise reallocation and data copying is performed. The function chooses an operation mode depending on the flags, size, and channel count of the source matrix:</p>
<ul>
<li>If the source matrix is complex and the output is not specified as real, the destination matrix is complex and has the dft_size size and CV_32FC2 type. The destination matrix contains a full result of the DFT (forward or inverse).</li>
<li>If the source matrix is complex and the output is specified as real, the function assumes that its input is the result of the forward transform (see the next item). The destination matrix has the dft_size size and CV_32FC1 type. It contains the result of the inverse DFT.</li>
<li>If the source matrix is real (its type is CV_32FC1 ), forward DFT is performed. The result of the DFT is packed into complex ( CV_32FC2 ) matrix. So, the width of the destination matrix is dft_size.width / 2 + 1 . But if the source is a single column, the height is reduced instead of the width.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>dft </dd></dl>

</div>
</div>
<a id="ga85da42c86ead745f4533dba92ec4d70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85da42c86ead745f4533dba92ec4d70b">&#9670;&nbsp;</a></span>gemm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::cuda::gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs generalized matrix multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>First multiplied input matrix that should have CV_32FC1 , CV_64FC1 , CV_32FC2 , or CV_64FC2 type. </td></tr>
    <tr><td class="paramname">src2</td><td>Second multiplied input matrix of the same type as src1 . </td></tr>
    <tr><td class="paramname">alpha</td><td>Weight of the matrix product. </td></tr>
    <tr><td class="paramname">src3</td><td>Third optional delta matrix added to the matrix product. It should have the same type as src1 and src2 . </td></tr>
    <tr><td class="paramname">beta</td><td>Weight of src3 . </td></tr>
    <tr><td class="paramname">dst</td><td>Destination matrix. It has the proper size and the same type as input matrices. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags:<ul>
<li><b>GEMM_1_T</b> transpose src1</li>
<li><b>GEMM_2_T</b> transpose src2</li>
<li><b>GEMM_3_T</b> transpose src3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="classcv_1_1cuda_1_1_stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs generalized matrix multiplication similar to the gemm functions in BLAS level</p><ol type="1">
<li><p class="startli">For example, gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) corresponds to</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} = \texttt{alpha} \cdot \texttt{src1} ^T \cdot \texttt{src2} + \texttt{beta} \cdot \texttt{src3} ^T\]" src="form_261.png"/>
</p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Transposition operation doesn't support CV_64FC2 input type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>gemm </dd></dl>

</div>
</div>
<a id="gacbdc870ff112ebb0e148a09d7199a8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbdc870ff112ebb0e148a09d7199a8b7">&#9670;&nbsp;</a></span>mulAndScaleSpectrums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::cuda::mulAndScaleSpectrums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjB</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a per-element multiplication of two Fourier spectrums and scales the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>First spectrum. </td></tr>
    <tr><td class="paramname">src2</td><td>Second spectrum with the same size and type as a . </td></tr>
    <tr><td class="paramname">dst</td><td>Destination spectrum. </td></tr>
    <tr><td class="paramname">flags</td><td>Mock parameter used for CPU/CUDA interfaces similarity, simply add a <code>0</code> value. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale constant. </td></tr>
    <tr><td class="paramname">conjB</td><td>Optional flag to specify if the second spectrum needs to be conjugated before the multiplication. </td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="classcv_1_1cuda_1_1_stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>Only full (not packed) CV_32FC2 complex spectrums in the interleaved format are supported for now.</p>
<dl class="section see"><dt>See also</dt><dd>mulSpectrums </dd></dl>

</div>
</div>
<a id="ga10ce4319fb3eaecb6e8cbdb26b8e0829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ce4319fb3eaecb6e8cbdb26b8e0829">&#9670;&nbsp;</a></span>mulSpectrums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS void cv::cuda::mulSpectrums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_array.html">InputArray</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjB</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="classcv_1_1cuda_1_1_stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a per-element multiplication of two Fourier spectrums. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>First spectrum. </td></tr>
    <tr><td class="paramname">src2</td><td>Second spectrum with the same size and type as a . </td></tr>
    <tr><td class="paramname">dst</td><td>Destination spectrum. </td></tr>
    <tr><td class="paramname">flags</td><td>Mock parameter used for CPU/CUDA interfaces similarity. </td></tr>
    <tr><td class="paramname">conjB</td><td>Optional flag to specify if the second spectrum needs to be conjugated before the multiplication. </td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="classcv_1_1cuda_1_1_stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>Only full (not packed) CV_32FC2 complex spectrums in the interleaved format are supported for now.</p>
<dl class="section see"><dt>See also</dt><dd>mulSpectrums </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
