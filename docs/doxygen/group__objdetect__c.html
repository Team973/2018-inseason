<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2018-inseason: C API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">2018-inseason
   </div>
   <div id="projectbrief">The Greybots&#39; 2018 Power Up code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">C API<div class="ingroups"><a class="el" href="group__objdetect.html">Object Detection</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_feature.html">CvHaarFeature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_classifier.html">CvHaarClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_stage_classifier.html">CvHaarStageClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cv_avg_comp.html">CvAvgComp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacd8ee8b3cdc5253a300a3b786ff762b0"><td class="memItemLeft" align="right" valign="top"><a id="gacd8ee8b3cdc5253a300a3b786ff762b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_MAGIC_VAL</b>&#160;&#160;&#160;0x42500000</td></tr>
<tr class="separator:gacd8ee8b3cdc5253a300a3b786ff762b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895619ab5b7eb5cd3e4a27a7f2dffc67"><td class="memItemLeft" align="right" valign="top"><a id="ga895619ab5b7eb5cd3e4a27a7f2dffc67"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_TYPE_NAME_HAAR</b>&#160;&#160;&#160;&quot;opencv-haar-classifier&quot;</td></tr>
<tr class="separator:ga895619ab5b7eb5cd3e4a27a7f2dffc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7f2403319efc32466187eaedec6ce7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_IS_HAAR_CLASSIFIER</b>(haar)</td></tr>
<tr class="separator:ga1d7f2403319efc32466187eaedec6ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54d742542c40513ae056b7eca665bd25"><td class="memItemLeft" align="right" valign="top"><a id="ga54d742542c40513ae056b7eca665bd25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_FEATURE_MAX</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga54d742542c40513ae056b7eca665bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb074ea5afa72bbb137bc77ce921e3a7"><td class="memItemLeft" align="right" valign="top"><a id="gabb074ea5afa72bbb137bc77ce921e3a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_DO_CANNY_PRUNING</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gabb074ea5afa72bbb137bc77ce921e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812f46d031349fa2ee78a5e7240f5016"><td class="memItemLeft" align="right" valign="top"><a id="ga812f46d031349fa2ee78a5e7240f5016"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_SCALE_IMAGE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga812f46d031349fa2ee78a5e7240f5016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1734494723ac7a1c009e3d820804099"><td class="memItemLeft" align="right" valign="top"><a id="gab1734494723ac7a1c009e3d820804099"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_FIND_BIGGEST_OBJECT</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gab1734494723ac7a1c009e3d820804099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4c504e5da7edeed3642ce05e0db15d"><td class="memItemLeft" align="right" valign="top"><a id="gaaf4c504e5da7edeed3642ce05e0db15d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CV_HAAR_DO_ROUGH_SEARCH</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gaaf4c504e5da7edeed3642ce05e0db15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad5e81c319a6e1149afa225ef5c7be763"><td class="memItemLeft" align="right" valign="top"><a id="gad5e81c319a6e1149afa225ef5c7be763"></a>
typedef struct <a class="el" href="struct_cv_haar_feature.html">CvHaarFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarFeature</b></td></tr>
<tr class="separator:gad5e81c319a6e1149afa225ef5c7be763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3441f11a0d1e4150b836fc19f8b2ad"><td class="memItemLeft" align="right" valign="top"><a id="ga2f3441f11a0d1e4150b836fc19f8b2ad"></a>
typedef struct <a class="el" href="struct_cv_haar_classifier.html">CvHaarClassifier</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarClassifier</b></td></tr>
<tr class="separator:ga2f3441f11a0d1e4150b836fc19f8b2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2dae27c78a17c074cb3a7dfba0b15e6"><td class="memItemLeft" align="right" valign="top"><a id="gad2dae27c78a17c074cb3a7dfba0b15e6"></a>
typedef struct <a class="el" href="struct_cv_haar_stage_classifier.html">CvHaarStageClassifier</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarStageClassifier</b></td></tr>
<tr class="separator:gad2dae27c78a17c074cb3a7dfba0b15e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cff51069a20252ece5d11554c178be"><td class="memItemLeft" align="right" valign="top"><a id="gaa2cff51069a20252ece5d11554c178be"></a>
typedef struct CvHidHaarClassifierCascade&#160;</td><td class="memItemRight" valign="bottom"><b>CvHidHaarClassifierCascade</b></td></tr>
<tr class="separator:gaa2cff51069a20252ece5d11554c178be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb162bdfcd7fa12aa22638c1f10796e7"><td class="memItemLeft" align="right" valign="top"><a id="gacb162bdfcd7fa12aa22638c1f10796e7"></a>
typedef struct <a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvHaarClassifierCascade</b></td></tr>
<tr class="separator:gacb162bdfcd7fa12aa22638c1f10796e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1d51406f5fef50bdc6198d02e4a0a4"><td class="memItemLeft" align="right" valign="top"><a id="ga8e1d51406f5fef50bdc6198d02e4a0a4"></a>
typedef struct <a class="el" href="struct_cv_avg_comp.html">CvAvgComp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CvAvgComp</b></td></tr>
<tr class="separator:ga8e1d51406f5fef50bdc6198d02e4a0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabece53e393ac6203569b3b3298050d2b"><td class="memItemLeft" align="right" valign="top"><a id="gabece53e393ac6203569b3b3298050d2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CVAPI</b> (<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> *) cvLoadHaarClassifierCascade(const char *directory</td></tr>
<tr class="separator:gabece53e393ac6203569b3b3298050d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1398da9662b305db874b661bc468161a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__objdetect__c.html#ga1398da9662b305db874b661bc468161a">CVAPI</a> (void) cvReleaseHaarClassifierCascade(<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> **cascade)</td></tr>
<tr class="memdesc:ga1398da9662b305db874b661bc468161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop capturing/reading and free resources  <a href="#ga1398da9662b305db874b661bc468161a">More...</a><br /></td></tr>
<tr class="separator:ga1398da9662b305db874b661bc468161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df70d3fa96db26bfbfd1aeb64183064"><td class="memItemLeft" align="right" valign="top"><a id="ga6df70d3fa96db26bfbfd1aeb64183064"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CVAPI</b> (<a class="el" href="struct_cv_seq.html">CvSeq</a> *) cvHaarDetectObjects(const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *image</td></tr>
<tr class="separator:ga6df70d3fa96db26bfbfd1aeb64183064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6c5085461f40a6df1588c01a9c1f96"><td class="memItemLeft" align="right" valign="top"><a id="ga6c6c5085461f40a6df1588c01a9c1f96"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (1.1)</td></tr>
<tr class="separator:ga6c6c5085461f40a6df1588c01a9c1f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9d8dd9fa72e86f5ca60daefa3e28c0"><td class="memItemLeft" align="right" valign="top"><a id="gadc9d8dd9fa72e86f5ca60daefa3e28c0"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor int min_neighbors&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (3)</td></tr>
<tr class="separator:gadc9d8dd9fa72e86f5ca60daefa3e28c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga386121b8b2e1df107a7e782836d639be"><td class="memItemLeft" align="right" valign="top"><a id="ga386121b8b2e1df107a7e782836d639be"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor int min_neighbors int flags&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (0)</td></tr>
<tr class="separator:ga386121b8b2e1df107a7e782836d639be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92aa626be160dd4009fa431db467738"><td class="memItemLeft" align="right" valign="top"><a id="gad92aa626be160dd4009fa431db467738"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> double scale_factor int min_neighbors int flags <a class="el" href="struct_cv_size.html">CvSize</a> min_size&#160;</td><td class="memItemRight" valign="bottom"><b>CV_DEFAULT</b> (<a class="el" href="group__core__c.html#gad25ce7ac18665d5c9b062283ff0204ed">cvSize</a>(0, 0))</td></tr>
<tr class="separator:gad92aa626be160dd4009fa431db467738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1586fcd671e0c4cd369a0840595680ef"><td class="memItemLeft" align="right" valign="top"><a id="ga1586fcd671e0c4cd369a0840595680ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CVAPI</b> (int) cvRunHaarClassifierCascade(const <a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> *cascade</td></tr>
<tr class="separator:ga1586fcd671e0c4cd369a0840595680ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaa572c1e2ae02ed538a1db299f9663a95"><td class="memItemLeft" align="right" valign="top"><a id="gaa572c1e2ae02ed538a1db299f9663a95"></a>
<a class="el" href="struct_cv_size.html">CvSize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>orig_window_size</b></td></tr>
<tr class="separator:gaa572c1e2ae02ed538a1db299f9663a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88f88d4666ea59e5132cedd33f75016"><td class="memItemLeft" align="right" valign="top"><a id="gac88f88d4666ea59e5132cedd33f75016"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>cascade</b></td></tr>
<tr class="separator:gac88f88d4666ea59e5132cedd33f75016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5066b4406a7648e61c69bd407d589ddc"><td class="memItemLeft" align="right" valign="top"><a id="ga5066b4406a7648e61c69bd407d589ddc"></a>
<a class="el" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a> <a class="el" href="struct_cv_mem_storage.html">CvMemStorage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b></td></tr>
<tr class="separator:ga5066b4406a7648e61c69bd407d589ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1302ba7f918063962cf751adcebad452"><td class="memItemLeft" align="right" valign="top"><a id="ga1302ba7f918063962cf751adcebad452"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b></td></tr>
<tr class="separator:ga1302ba7f918063962cf751adcebad452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9933dc7f409c9e987d15e1527589d3ae"><td class="memItemLeft" align="right" valign="top"><a id="ga9933dc7f409c9e987d15e1527589d3ae"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sqsum</b></td></tr>
<tr class="separator:ga9933dc7f409c9e987d15e1527589d3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea6e73a4c3d228a0eaa6157bed0c54d"><td class="memItemLeft" align="right" valign="top"><a id="gacea6e73a4c3d228a0eaa6157bed0c54d"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>tilted_sum</b></td></tr>
<tr class="separator:gacea6e73a4c3d228a0eaa6157bed0c54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f622eb9b9e06b30862ca90cdf2c078b"><td class="memItemLeft" align="right" valign="top"><a id="ga1f622eb9b9e06b30862ca90cdf2c078b"></a>
const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> const <a class="el" href="group__core__c.html#gac5046bc0456e9295d80b37774384798c">CvArr</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b></td></tr>
<tr class="separator:ga1f622eb9b9e06b30862ca90cdf2c078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c6090aa56793ec8ef2457bc6d45b45"><td class="memItemLeft" align="right" valign="top"><a id="ga69c6090aa56793ec8ef2457bc6d45b45"></a>
<a class="el" href="struct_cv_point.html">CvPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pt</b></td></tr>
<tr class="separator:ga69c6090aa56793ec8ef2457bc6d45b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1d7f2403319efc32466187eaedec6ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d7f2403319efc32466187eaedec6ce7">&#9670;&nbsp;</a></span>CV_IS_HAAR_CLASSIFIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CV_IS_HAAR_CLASSIFIER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">haar</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((haar) != NULL &amp;&amp;                                                                   \</div><div class="line">    (((<span class="keyword">const</span> <a class="code" href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a>*)(haar))-&gt;flags &amp; CV_MAGIC_MASK)==CV_HAAR_MAGIC_VAL)</div><div class="ttc" id="struct_cv_haar_classifier_cascade_html"><div class="ttname"><a href="struct_cv_haar_classifier_cascade.html">CvHaarClassifierCascade</a></div><div class="ttdef"><b>Definition:</b> objdetect_c.h:106</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1398da9662b305db874b661bc468161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1398da9662b305db874b661bc468161a">&#9670;&nbsp;</a></span>CVAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVAPI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stop capturing/reading and free resources </p>
<p>close video file writer</p>
<p>stop capturing/reading and free resources</p>
<p>close video file writer</p>
<p>Draws contour outlines or filled interiors on the image.</p>
<p>Calculates bounding box of text stroke (useful for alignment)</p>
<p>Renders text stroke with specified font and color at specified location. <a class="el" href="struct_cv_font.html">CvFont</a> should be initialized with cvInitFont.</p>
<p>Initializes font structure (OpenCV 1.x API).</p>
<p>Draws one or more polygonal curves.</p>
<p>Fills an area bounded by one or more arbitrary polygons.</p>
<p>Fills convex or monotonous polygon.</p>
<p>Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector.</p>
<p>Draws a circle with specified center and radius.</p>
<p>Draws a rectangle specified by a <a class="el" href="struct_cv_rect.html">CvRect</a> structure.</p>
<p>Draws a rectangle given two opposite corners of the rectangle (pt1 &amp; pt2)</p>
<p>Draws 4-connected, 8-connected or antialiased line segment connecting two points.</p>
<p>Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)</p>
<p>Finds a sparse set of points within the selected region that seem to be easy to track.</p>
<p>Adjust corner position using some sort of gradient search.</p>
<p>Harris corner detector:</p>
<p>Calculates minimal eigenvalue for 2x2 gradient covariation matrix at every image pixel.</p>
<p>Calculates eigen values and vectors of 2x2 gradient covariation matrix at every image pixel.</p>
<p>Calculates constraint image for corner detection.</p>
<p>Runs canny edge detector.</p>
<p>Fills the connected component until the color difference gets large enough.</p>
<p>Applies adaptive threshold to grayscale image.</p>
<p>Applies distance transform to binary image.</p>
<p>equalizes histogram of 8-bit single-channel image</p>
<p>Divides one histogram by another.</p>
<p>Locates a template within an image by using a histogram comparison.</p>
<p>Calculates back project.</p>
<p>Calculates array histogram.</p>
<p>Calculates bayesian probabilistic histograms (each or src and dst is an array of <em>number</em> histograms.</p>
<p>Copies a histogram.</p>
<p>Thresholds the histogram.</p>
<p>Normalizes the histogram.</p>
<p>Finds the minimum and maximum histogram bins.</p>
<p>Clears the histogram.</p>
<p>Releases the histogram.</p>
<p>Sets the bounds of the histogram bins.</p>
<p>Finds coordinates of the box vertices.</p>
<p>Initializes Freeman chain reader.</p>
<p>Substitutes the last retrieved contour with the new one.</p>
<p>Measures similarity between template and overlapped windows in the source image and fills the resultant image with the measurements.</p>
<p>Retrieves quadrangle from the input array.</p>
<p>Retrieves the rectangular image region with specified center from the input array.</p>
<p>Calculates 7 Hu's invariants from precalculated spatial and central moments.</p>
<p>Calculates all spatial and central moments up to the 3rd order.</p>
<p>Performs complex morphological transformation.</p>
<p>dilates input image (applies maximum filter) one or more times.</p>
<p>erodes input image (applies minimum filter) one or more times. If element pointer is NULL, 3x3 rectangular element is used</p>
<p>releases structuring element</p>
<p>Computes the original (undistorted) feature coordinates from the observed (distorted) coordinates.</p>
<p>Computes undistortion+rectification map for a head of stereo camera.</p>
<p>Computes transformation map from intrinsic camera parameters that can used by cvRemap.</p>
<p>Transforms the input image to compensate lens distortion.</p>
<p>Performs forward or inverse log-polar image transform.</p>
<p>Converts mapx &amp; mapy from floating-point to integer formats for cvRemap.</p>
<p>Performs generic geometric transformation using the specified coordinate maps.</p>
<p>Warps image with perspective (projective) transform.</p>
<p>Warps image with affine transform.</p>
<p>Resizes image (input array is resized to fit the destination array)</p>
<p>Converts input array pixels from one color space to another.</p>
<p>Calculates the image Laplacian: (d2/dx + d2/dy)I.</p>
<p>Calculates an image derivative using generalized Sobel.</p>
<p>Segments image using seed "markers".</p>
<p>Filters image using meanshift algorithm.</p>
<p>Releases pyramid.</p>
<p>Up-samples image and smoothes the result with gaussian kernel.</p>
<p>Smoothes the input image with gaussian kernel and then down-samples it.</p>
<p>Finds integral image: SUM(X,Y) = sum(x&lt;X,y&lt;Y)I(x,y)</p>
<p>Convolves an image with the kernel.</p>
<p>Smooths the image in one of several ways.</p>
<p>Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha.</p>
<p>Adds a product of two images to accumulator.</p>
<p>Adds squared image to accumulator.</p>
<p>Saves an object to a file.</p>
<p>Releases an object.</p>
<p>Unregisters the type.</p>
<p>Registers a new type.</p>
<p>Writes a file node to another file storage.</p>
<p>Reads multiple numbers.</p>
<p>Initializes file node sequence reader.</p>
<p>Initializes the file node sequence reader.</p>
<p>Writes multiple numbers in Base64.</p>
<p>Writes multiple numbers.</p>
<p>Starts the next stream.</p>
<p>Writes an object to file storage.</p>
<p>Writes a comment.</p>
<p>Writes a text string.</p>
<p>Writes a floating-point value.</p>
<p>Writes an integer value.</p>
<p>Finishes writing to a file node collection.</p>
<p>Starts writing a new structure.</p>
<p>Releases file storage.</p>
<p>Makes OpenCV use IPL functions for allocating IplImage and IplROI structures.</p>
<p>Calculates the cross product of two 3D vectors.</p>
<p>Fills an array with random numbers and updates the RNG state.</p>
<p>Converts one array to another with optional linear transformation.</p>
<p>Clears the array.</p>
<p>Sets every element of an array to a given value.</p>
<p>Copies one array to another.</p>
<p>Retrieves low-level information about the array.</p>
<p>Assigns user data to the array header.</p>
<p>Releases array data.</p>
<p>Allocates array data.</p>
<p>Change a specific array element.</p>
<p>Change the particular array element.</p>
<p>Deallocates sparse array.</p>
<p>Deallocates a matrix.</p>
<p>Resets the image ROI to include the entire image and releases the ROI structure.</p>
<p>Sets an image Region Of Interest (ROI) for a given rectangle.</p>
<p>Sets the channel of interest in an IplImage.</p>
<p>Deallocates the image header and the image data.</p>
<p>This call is an analogue of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(image )</div><div class="line">{</div><div class="line">    iplDeallocate(*image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI);</div><div class="line">    *image = 0;</div><div class="line">}</div></div><!-- fragment --><p> but it does not use IPL functions by default (see the CV_TURN_ON_IPL_COMPATIBILITY macro). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>This call is a shortened form of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*image )</div><div class="line">{</div><div class="line">    cvReleaseData(*image);</div><div class="line">    cvReleaseImageHeader(image);</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>If the ROI is set to NULL and the coi is <em>not</em> 0, the ROI is allocated. Most OpenCV functions do not* support the COI setting, so to process an individual image/matrix channel one may copy (via cvCopy or cvSplit) the channel to a separate image/matrix, process it and then copy the result back (via cvCopy or cvMerge) if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">coi</td><td>The channel of interest. 0 - all channels are selected, 1 - first channel is selected, etc. Note that the channel indices become 1-based.</td></tr>
  </table>
  </dd>
</dl>
<p>If the original image ROI was NULL and the rect is not the whole image, the ROI structure is allocated.</p>
<p>Most OpenCV functions support the use of ROI and treat the image rectangle as a separate image. For example, all of the pixel coordinates are counted from the top-left (or bottom-left) corner of the ROI, not the original image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">rect</td><td>The ROI rectangle</td></tr>
  </table>
  </dd>
</dl>
<p>This produces a similar result to the following, but in addition it releases the ROI structure. : </p><div class="fragment"><div class="line">cvSetImageROI(image, <a class="code" href="group__core__c.html#gafaffdb9052823163862a88209f379921">cvRect</a>(0, 0, image-&gt;width, image-&gt;height ));</div><div class="line">cvSetImageCOI(image, 0);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>The function decrements the matrix data reference counter and deallocates matrix header. If the data reference counter is 0, it also deallocates the data. : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*mat )</div><div class="line">    <a class="code" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85">cvDecRefData</a>(*mat);</div><div class="line">cvFree((<span class="keywordtype">void</span>**)mat);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the matrix</td></tr>
  </table>
  </dd>
</dl>
<p>low-level scalar &lt;-&gt; raw data conversion functions</p>
<p>The function releases the sparse array and clears the array pointer upon exit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the array</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign the new value to a particular array element. In the case of a sparse array the functions create the node if it does not exist yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx</td><td>Array of the element indices </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign a new value to a specific element of a single-channel array. If the array has multiple channels, a runtime error is raised. Note that the Set*D function can be used safely for both single-channel and multiple-channel arrays, though they are a bit slower.</p>
<p>In the case of a sparse array the functions create the node if it does not yet exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>clears element of ND dense array, in case of sparse arrays it deletes the specified node</p>
<p>Repeats source 2d array several times in both horizontal and vertical direction to fill destination array</p>
<p>The function allocates image, matrix or multi-dimensional dense array data. Note that in the case of matrix types OpenCV allocation functions are used. In the case of IplImage they are used unless CV_TURN_ON_IPL_COMPATIBILITY() has been called before. In the latter case IPL functions are used to allocate the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function releases the array data. In the case of <a class="el" href="struct_cv_mat.html">CvMat</a> or <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> it simply calls <a class="el" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85" title="Decrements an array data reference counter. ">cvDecRefData()</a>, that is the function can not deallocate external data. See also the note to cvCreateData . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function assigns user data to the array header. Header should be initialized before using cvCreateMatHeader, cvCreateImageHeader, cvCreateMatNDHeader, cvInitMatHeader, cvInitImageHeader or cvInitMatNDHeader. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>User data </td></tr>
    <tr><td class="paramname">step</td><td>Full row length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function fills output variables with low-level information about the array data. All output</p>
<p>parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, the parameters of ROI are returned.</p>
<p>The following example shows how to get access to array elements. It computes absolute values of the array elements : </p><div class="fragment"><div class="line"><span class="keywordtype">float</span>* data;</div><div class="line"><span class="keywordtype">int</span> step;</div><div class="line"><a class="code" href="struct_cv_size.html">CvSize</a> size;</div><div class="line"></div><div class="line">cvGetRawData(array, (uchar**)&amp;data, &amp;step, &amp;size);</div><div class="line">step /= <span class="keyword">sizeof</span>(data[0]);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = 0; y &lt; size.height; y++, data += step )</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x = 0; x &lt; size.width; x++ )</div><div class="line">        data[x] = (<span class="keywordtype">float</span>)fabs(data[x]);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>Output pointer to the whole image origin or ROI origin if ROI is set </td></tr>
    <tr><td class="paramname">step</td><td>Output full row length in bytes </td></tr>
    <tr><td class="paramname">roi_size</td><td>Output ROI size</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies selected elements from an input array to an output array:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} (I)= \texttt{src} (I) \quad \text{if} \quad \texttt{mask} (I) \ne 0.\]" src="form_158.png"/>
</p>
<p>If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions, and the same size. The function can also copy sparse arrays (mask is not supported in this case). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source array </td></tr>
    <tr><td class="paramname">dst</td><td>The destination array </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies the scalar value to every selected element of the destination array: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{arr} (I)= \texttt{value} \quad \text{if} \quad \texttt{mask} (I) \ne 0\]" src="form_159.png"/>
</p>
<p> If array arr is of IplImage type, then is ROI used, but COI must not be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">value</td><td>Fill value </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears the array. In the case of dense arrays (<a class="el" href="struct_cv_mat.html">CvMat</a>, <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> or IplImage), cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0). In the case of sparse arrays all the elements are removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to be cleared</td></tr>
  </table>
  </dd>
</dl>
<p>Splits a multi-channel array into the set of single-channel arrays or extracts particular [color] plane</p>
<p>Merges a set of single-channel arrays into the single multi-channel array or inserts one particular [color] plane to the array</p>
<p>Copies several channels from input arrays to certain channels of output arrays</p>
<p>The function has several different purposes, and thus has several different names. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} (I) = \texttt{scale} \texttt{src} (I) + ( \texttt{shift} _0, \texttt{shift} _1,...)\]" src="form_160.png"/>
</p>
<p>All the channels of multi-channel arrays are processed independently.</p>
<p>The type of conversion is done with rounding and saturation, that is if the result of scaling + conversion can not be represented exactly by a value of the destination array element type, it is set to the nearest representable value on the real axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source array </td></tr>
    <tr><td class="paramname">dst</td><td>Destination array </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor </td></tr>
    <tr><td class="paramname">shift</td><td>Value added to the scaled source array elements</td></tr>
  </table>
  </dd>
</dl>
<p>Performs linear transformation on every source array element, stores absolute value of the result: dst(x,y,c) = abs(scale*src(x,y,c)+shift). destination array must have 8u type. In other cases one may use cvConvertScale + cvAbsDiffS</p>
<p>dst(mask) = src1(mask) + src2(mask)</p>
<p>dst(mask) = src(mask) + value</p>
<p>dst(mask) = src1(mask) - src2(mask)</p>
<p>dst(mask) = value - src(mask)</p>
<p>dst(idx) = src1(idx) * src2(idx) * scale (scaled element-wise multiplication of 2 arrays)</p>
<p>element-wise division/inversion with scaling: dst(idx) = src1(idx) * scale / src2(idx) or dst(idx) = scale / src2(idx) if src1 == 0</p>
<p>dst = src1 * scale + src2</p>
<p>dst = src1 * alpha + src2 * beta + gamma</p>
<p>dst(idx) = src1(idx) &amp; src2(idx)</p>
<p>dst(idx) = src(idx) &amp; value</p>
<p>dst(idx) = src1(idx) | src2(idx)</p>
<p>dst(idx) = src(idx) | value</p>
<p>dst(idx) = src1(idx) ^ src2(idx)</p>
<p>dst(idx) = src(idx) ^ value</p>
<p>dst(idx) = ~src(idx)</p>
<p>dst(idx) = lower(idx) &lt;= src(idx) &lt; upper(idx)</p>
<p>dst(idx) = lower &lt;= src(idx) &lt; upper</p>
<p>The comparison operation support single-channel arrays only. Destination image should be 8uC1 or 8sC1 dst(idx) = src1(idx) <em>cmp_op</em> src2(idx)</p>
<p>dst(idx) = src1(idx) <em>cmp_op</em> value</p>
<p>dst(idx) = min(src1(idx),src2(idx))</p>
<p>dst(idx) = max(src1(idx),src2(idx))</p>
<p>dst(idx) = min(src(idx),value)</p>
<p>dst(idx) = max(src(idx),value)</p>
<p>dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))</p>
<p>dst(x,y,c) = abs(src(x,y,c) - value(c))</p>
<p>Does cartesian-&gt;polar coordinates conversion. Either of output components (magnitude or angle) is optional</p>
<p>Does polar-&gt;cartesian coordinates conversion. Either of output components (magnitude or angle) is optional. If magnitude is missing it is assumed to be all 1's</p>
<p>Does powering: dst(idx) = src(idx)^power</p>
<p>Does exponention: dst(idx) = exp(src(idx)). Overflow is not handled yet. Underflow is handled. Maximal relative error is ~7e-6 for single-precision input</p>
<p>Calculates natural logarithms: dst(idx) = log(abs(src(idx))). Logarithm of 0 gives large negative number(~-700) Maximal relative error is ~3e-7 for single-precision output</p>
<p>The function fills the destination array with uniformly or normally distributed random numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>CvRNG state initialized by cvRNG </td></tr>
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">dist_type</td><td>Distribution type <blockquote class="doxtable">
<ul>
<li><b>CV_RAND_UNI</b> uniform distribution</li>
<li><b>CV_RAND_NORMAL</b> normal or Gaussian distribution </li>
</ul>
</blockquote>
</td></tr>
    <tr><td class="paramname">param1</td><td>The first parameter of the distribution. In the case of a uniform distribution it is the inclusive lower boundary of the random numbers range. In the case of a normal distribution it is the mean value of the random numbers. </td></tr>
    <tr><td class="paramname">param2</td><td>The second parameter of the distribution. In the case of a uniform distribution it is the exclusive upper boundary of the random numbers range. In the case of a normal distribution it is the standard deviation of the random numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>randu, randn, RNG::fill.</dd></dl>
<p>Finds all real and complex roots of a polynomial equation</p>
<p>The function calculates the cross product of two 3D vectors: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} = \texttt{src1} \times \texttt{src2}\]" src="form_163.png"/>
</p>
<p> or: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\begin{array}{l} \texttt{dst} _1 = \texttt{src1} _2 \texttt{src2} _3 - \texttt{src1} _3 \texttt{src2} _2 \\ \texttt{dst} _2 = \texttt{src1} _3 \texttt{src2} _1 - \texttt{src1} _1 \texttt{src2} _3 \\ \texttt{dst} _3 = \texttt{src1} _1 \texttt{src2} _2 - \texttt{src1} _2 \texttt{src2} _1 \end{array}\]" src="form_164.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>The first source vector </td></tr>
    <tr><td class="paramname">src2</td><td>The second source vector </td></tr>
    <tr><td class="paramname">dst</td><td>The destination vector</td></tr>
  </table>
  </dd>
</dl>
<p>Extended matrix transform: dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T</p>
<p>Transforms each element of source array and stores resultant vectors in destination array</p>
<p>Does perspective transform on every element of input array</p>
<p>Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)</p>
<p>Tranposes matrix. Square matrices can be transposed in-place</p>
<p>Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part</p>
<p>Mirror array data around horizontal (flip=0), vertical (flip=1) or both(flip=-1) axises: cvFlip(src) flips images vertically and sequences horizontally (inplace)</p>
<p>Performs Singular Value Decomposition of a matrix</p>
<p>Performs Singular Value Back Substitution (solves A*X = B): flags must be the same as in cvSVD</p>
<p>Finds eigen values and vectors of a symmetric matrix</p>
<ul>
<li><p class="startli">Finds selected eigen values and vectors of a symmetric matrix */ Makes an identity matrix (mat_ij = i == j)</p>
<p class="startli">Calculates covariation matrix for a set of vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__c.html#core_c_CovarFlags">flags</a></dd></dl>
<p>Calculates mean and standard deviation of pixel values</p>
</li>
</ul>
<p>Finds global minimum, maximum and their positions</p>
<dl class="section see"><dt>See also</dt><dd>ref core_c_NormFlags "flags"</dd>
<dd>
<a class="el" href="group__core__c.html#core_c_ReduceFlags">flags</a></dd></dl>
<p>Discrete Fourier Transform: complex-&gt;complex, real-&gt;ccs (forward), ccs-&gt;real (inverse) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y)) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Discrete Cosine Transform </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Releases memory storage. All the children of a parent must be released before the parent. A child storage returns all the blocks to parent when it is released</p>
<p>Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos) to reuse memory allocated for the storage - cvClearSeq,cvClearSet ... do not free any memory. A child storage returns all the blocks to the parent when it is cleared</p>
<p>Remember a storage "free memory" position</p>
<p>Restore a storage "free memory" position</p>
<p>Changes default size (granularity) of sequence blocks. The default size is ~1Kbyte</p>
<p>Removes the last element from sequence and optionally saves it</p>
<p>Removes the first element from sequence and optioanally saves it</p>
<p>Adds several new elements to the end of sequence</p>
<p>Removes several elements from the end of sequence and optionally saves them</p>
<p>Removes specified sequence element</p>
<p>Removes all the elements from the sequence. The freed memory can be reused later only by the same sequence unless cvClearMemStorage or cvRestoreMemStoragePos is called</p>
<p>Initializes sequence writer. The new elements will be added to the end of sequence</p>
<p>Combination of cvCreateSeq and cvStartAppendToSeq</p>
<p>Updates sequence header. May be useful to get access to some of previously written elements via cvGetSeqElem or sequence reader</p>
<p>Initializes sequence reader. The sequence can be read in forward or backward direction</p>
<p>Changes sequence reader position. It may seek to an absolute or to relative to the current position</p>
<p>Removes sequence slice</p>
<p>Inserts a sequence or array into another sequence</p>
<p>Sorts sequence in-place given element comparison function</p>
<p>Reverses order of sequence elements in-place</p>
<p>Removes element from the set by its index</p>
<p>Removes all the elements from the set</p>
<p>Remove edge connecting two vertices</p>
<p>Remove all vertices and edges from the graph</p>
<p>Releases graph scanner.</p>
<p>Does look-up transformation. Elements of the source array (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table</p>
<p>Inserts sequence into tree with specified "parent" sequence. If parent is equal to frame (e.g. the most external contour), then added contour will have null pointer to parent.</p>
<p>Removes contour from tree (together with the contour children).</p>
<p>Normally, the function is not called directly. Instead, a simple macro CV_TURN_ON_IPL_COMPATIBILITY() is used that calls cvSetIPLAllocators and passes there pointers to IPL allocation functions. : </p><div class="fragment"><div class="line">...</div><div class="line">CV_TURN_ON_IPL_COMPATIBILITY()</div><div class="line">...</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_header</td><td>pointer to a function, creating IPL image header. </td></tr>
    <tr><td class="paramname">allocate_data</td><td>pointer to a function, allocating IPL image data. </td></tr>
    <tr><td class="paramname">deallocate</td><td>pointer to a function, deallocating IPL image. </td></tr>
    <tr><td class="paramname">create_roi</td><td>pointer to a function, creating IPL image ROI (i.e. Region of Interest). </td></tr>
    <tr><td class="paramname">clone_image</td><td>pointer to a function, cloning an IPL image.</td></tr>
  </table>
  </dd>
</dl>
<p>The function closes the file associated with the storage and releases all the temporary structures. It must be called after all I/O operations with the storage are finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Double pointer to the released file storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function starts writing a compound structure (collection) that can be a sequence or a map. After all the structure fields, which can be scalars or structures, are written, cvEndWriteStruct should be called. The function can be used to group some objects or to implement the write function for a some user object (see <a class="el" href="struct_cv_type_info.html" title="Type information. ">CvTypeInfo</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written structure. The structure can be accessed by this name when the storage is read. </td></tr>
    <tr><td class="paramname">struct_flags</td><td>A combination one of the following values:<ul>
<li><b>CV_NODE_SEQ</b> the written structure is a sequence (see discussion of CvFileStorage ), that is, its elements do not have a name.</li>
<li><b>CV_NODE_MAP</b> the written structure is a map (see discussion of CvFileStorage ), that is, all its elements have names. One and only one of the two above flags must be specified</li>
<li><b>CV_NODE_FLOW</b> the optional flag that makes sense only for YAML streams. It means that the structure is written as a flow (not as a block), which is more compact. It is recommended to use this flag for structures or arrays whose elements are all scalars. </li>
</ul>
</td></tr>
    <tr><td class="paramname">type_name</td><td>Optional parameter - the object type name. In case of XML it is written as a type_id attribute of the structure opening tag. In the case of YAML it is written after a colon following the structure name (see the example in CvFileStorage description). In case of JSON it is written as a name/value pair. Mainly it is used with user objects. When the storage is read, the encoded type name is used to determine the object type (see <a class="el" href="struct_cv_type_info.html" title="Type information. ">CvTypeInfo</a> and cvFindType ). </td></tr>
    <tr><td class="paramname">attributes</td><td>This parameter is not used in the current implementation</td></tr>
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvStartWriteStruct.</dd></dl>
<p>The function writes a single integer value (with or without a name) to the file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a single floating-point value (with or without a name) to file storage. Special values are encoded as follows: NaN (Not A Number) as .NaN, infinity as +.Inf or -.Inf.</p>
<p>The following example shows how to use the low-level writing functions to store custom structures, such as termination criteria, without registering a new type. : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> write_termcriteria( <a class="code" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs, <span class="keyword">const</span> <span class="keywordtype">char</span>* struct_name,</div><div class="line">                         <a class="code" href="struct_cv_term_criteria.html">CvTermCriteria</a>* termcrit )</div><div class="line">{</div><div class="line">    cvStartWriteStruct( fs, struct_name, CV_NODE_MAP, NULL, <a class="code" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0));</div><div class="line">    cvWriteComment( fs, <span class="stringliteral">&quot;termination criteria&quot;</span>, 1 ); <span class="comment">// just a description</span></div><div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_ITER )</div><div class="line">        cvWriteInteger( fs, <span class="stringliteral">&quot;max_iterations&quot;</span>, termcrit-&gt;max_iter );</div><div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_EPS )</div><div class="line">        cvWriteReal( fs, <span class="stringliteral">&quot;accuracy&quot;</span>, termcrit-&gt;epsilon );</div><div class="line">    cvEndWriteStruct( fs );</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a text string to file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written string . Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">str</td><td>The written text string </td></tr>
    <tr><td class="paramname">quote</td><td>If non-zero, the written string is put in quotes, regardless of whether they are required. Otherwise, if the flag is zero, quotes are used only when they are required (e.g. when the string starts with a digit or contains spaces).</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a comment into file storage. The comments are skipped when the storage is read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">comment</td><td>The written comment, single-line or multi-line </td></tr>
    <tr><td class="paramname">eol_comment</td><td>If non-zero, the function tries to put the comment at the end of current line. If the flag is zero, if the comment is multi-line, or if it does not fit at the end of the current line, the comment starts a new line.</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an object to file storage. First, the appropriate type info is found using cvTypeOf. Then, the write method associated with the type info is called.</p>
<p>Attributes are used to customize the writing procedure. The standard types support the following attributes (all the dt attributes have the same format as in cvWriteRawData):</p>
<ol type="1">
<li><a class="el" href="struct_cv_seq.html">CvSeq</a><ul>
<li><b>header_dt</b> description of user fields of the sequence header that follow <a class="el" href="struct_cv_seq.html">CvSeq</a>, or <a class="el" href="struct_cv_chain.html">CvChain</a> (if the sequence is a Freeman chain) or <a class="el" href="struct_cv_contour.html">CvContour</a> (if the sequence is a contour or point sequence)</li>
<li><b>dt</b> description of the sequence elements.</li>
<li><b>recursive</b> if the attribute is present and is not equal to "0" or "false", the whole tree of sequences (contours) is stored.</li>
</ul>
</li>
<li><a class="el" href="struct_cv_graph.html">CvGraph</a><ul>
<li><b>header_dt</b> description of user fields of the graph header that follows <a class="el" href="struct_cv_graph.html">CvGraph</a>;</li>
<li><b>vertex_dt</b> description of user fields of graph vertices</li>
<li><b>edge_dt</b> description of user fields of graph edges (note that the edge weight is always written, so there is no need to specify it explicitly)</li>
</ul>
</li>
</ol>
<p>Below is the code that creates the YAML file shown in the CvFileStorage description: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cxcore.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div><div class="line">{</div><div class="line">    <a class="code" href="struct_cv_mat.html">CvMat</a>* mat = cvCreateMat( 3, 3, CV_32F );</div><div class="line">    <a class="code" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs = cvOpenFileStorage( <span class="stringliteral">&quot;example.yml&quot;</span>, 0, CV_STORAGE_WRITE );</div><div class="line"></div><div class="line">    cvSetIdentity( mat );</div><div class="line">    cvWrite( fs, <span class="stringliteral">&quot;A&quot;</span>, mat, <a class="code" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0) );</div><div class="line"></div><div class="line">    cvReleaseFileStorage( &amp;fs );</div><div class="line">    cvReleaseMat( &amp;mat );</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written object. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the object </td></tr>
    <tr><td class="paramname">attributes</td><td>The attributes of the object. They are specific for each particular type (see the discussion below).</td></tr>
  </table>
  </dd>
</dl>
<p>The function finishes the currently written stream and starts the next stream. In the case of XML the file with multiple streams looks like this: </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line"><span class="comment">&lt;!-- stream #1 data --&gt;</span></div><div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line"><span class="comment">&lt;!-- stream #2 data --&gt;</span></div><div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line">...</div></div><!-- fragment --><p> The YAML file will look like this: </p><div class="fragment"><div class="line">%YAML 1.0</div><div class="line"># stream #1 data</div><div class="line">...</div><div class="line">---</div><div class="line"># stream #2 data</div></div><!-- fragment --><p> This is useful for concatenating files or for resuming the writing process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an array, whose elements consist of single or multiple numbers. The function call can be replaced with a loop containing a few cvWriteInt and cvWriteReal calls, but a single call is more efficient. Note that because none of the elements have a name, they should be written to a sequence rather than a map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the written array </td></tr>
    <tr><td class="paramname">len</td><td>Number of the array elements to write </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element, see <a class="el" href="group__core__xml.html#format_spec">format specification</a></td></tr>
  </table>
  </dd>
</dl>
<p>If either CV_STORAGE_WRITE_BASE64 or <a class="el" href="classcv_1_1_file_storage.html#a973e41cb75ef6230412a567723b7482da74cdcbdb96c29f19e3ccc2ba4ab81614" title="flag, enable both WRITE and BASE64 ">cv::FileStorage::WRITE_BASE64</a> is used, this function will be the same as cvWriteRawData. If neither, the main difference is that it outputs a sequence in Base64 encoding rather than in plain text.</p>
<p>This function can only be used to write a sequence with a type "binary".</p>
<p>Consider the following two examples where their output is the same: </p><div class="fragment"></div><!-- fragment --><p>and </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the written array </td></tr>
    <tr><td class="paramname">len</td><td>Number of the array elements to write </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element, see <a class="el" href="group__core__xml.html#format_spec">format specification</a></td></tr>
  </table>
  </dd>
</dl>
<p>The function initializes the sequence reader to read data from a file node. The initialized reader can be then passed to cvReadRawDataSlice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">reader</td><td>Pointer to the sequence reader</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads one or more elements from the file node, representing a sequence, to a user-specified array. The total number of read sequence elements is a product of total and the number of components in each array element. For example, if dt=2if, the function will read total*3 sequence elements. As with any sequence, some parts of the file node sequence can be skipped or read repeatedly by repositioning the reader using cvSetSeqReaderPos. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">reader</td><td>The sequence reader. Initialize it with cvStartReadRawData . </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to read </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads elements from a file node that represents a sequence of scalars. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a copy of a file node to file storage. Possible applications of the function are merging several file storages into one and conversion between XML, YAML and JSON formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Destination file storage </td></tr>
    <tr><td class="paramname">new_node_name</td><td>New name of the file node in the destination file storage. To keep the existing name, use cvcvGetFileNodeName </td></tr>
    <tr><td class="paramname">node</td><td>The written node </td></tr>
    <tr><td class="paramname">embed</td><td>If the written node is a collection and this parameter is not zero, no extra level of hierarchy is created. Instead, all the elements of node are written into the currently written structure. Of course, map elements can only be embedded into another map, and sequence elements can only be embedded into another sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>The function registers a new type, which is described by info . The function creates a copy of the structure, so the user should delete it after calling the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Type info structure</td></tr>
  </table>
  </dd>
</dl>
<p>The function unregisters a type with a specified name. If the name is unknown, it is possible to locate the type info by an instance of the type using cvTypeOf or by iterating the type list, starting from cvFirstType, and then calling cvUnregisterType(info-&gt;typeName). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>Name of an unregistered type</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds the type of a given object and calls release with the double pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_ptr</td><td>Double pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<p>The function saves an object to a file. It provides a simple interface to cvWrite . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File name </td></tr>
    <tr><td class="paramname">struct_ptr</td><td>Object to save </td></tr>
    <tr><td class="paramname">name</td><td>Optional object name. If it is NULL, the name will be formed from filename . </td></tr>
    <tr><td class="paramname">comment</td><td>Optional comment to put in the beginning of the file </td></tr>
    <tr><td class="paramname">attributes</td><td>Optional attributes passed to cvWrite</td></tr>
  </table>
  </dd>
</dl>
<p>Sets error status silently</p>
<p>Sets error status and performs some additonal actions (displaying message box, writing message to stderr, terminating application etc.) depending on the current error mode</p>
<dl class="section see"><dt>See also</dt><dd>cv::accumulateSquare</dd>
<dd>
cv::accumulateProduct</dd>
<dd>
cv::accumulateWeighted</dd></dl>
<p>Copies source 2D array inside of the larger destination array and makes a border of the specified type (IPL_BORDER_*) around the copied area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source image </td></tr>
    <tr><td class="paramname">dst</td><td>The destination image </td></tr>
    <tr><td class="paramname">smoothtype</td><td>Type of the smoothing, see SmoothMethod_c </td></tr>
    <tr><td class="paramname">size1</td><td>The first parameter of the smoothing operation, the aperture width. Must be a positive odd number (1, 3, 5, ...) </td></tr>
    <tr><td class="paramname">size2</td><td>The second parameter of the smoothing operation, the aperture height. Ignored by CV_MEDIAN and CV_BILATERAL methods. In the case of simple scaled/non-scaled and Gaussian blur if size2 is zero, it is set to size1. Otherwise it must be a positive odd number. </td></tr>
    <tr><td class="paramname">sigma1</td><td>In the case of a Gaussian parameter this parameter may specify Gaussian <img class="formulaInl" alt="$\sigma$" src="form_336.png"/> (standard deviation). If it is zero, it is calculated from the kernel size: <p class="formulaDsp">
<img class="formulaDsp" alt="\[\sigma = 0.3 (n/2 - 1) + 0.8 \quad \text{where} \quad n= \begin{array}{l l} \mbox{\texttt{size1} for horizontal kernel} \\ \mbox{\texttt{size2} for vertical kernel} \end{array}\]" src="form_337.png"/>
</p>
 Using standard sigma for small kernels ( <img class="formulaInl" alt="$3\times 3$" src="form_338.png"/> to <img class="formulaInl" alt="$7\times 7$" src="form_339.png"/> ) gives better speed. If sigma1 is not zero, while size1 and size2 are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation). </td></tr>
    <tr><td class="paramname">sigma2</td><td>additional parameter for bilateral filtering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::GaussianBlur, cv::blur, cv::medianBlur, cv::bilateralFilter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input image. </td></tr>
    <tr><td class="paramname">dst</td><td>output image of the same size and the same number of channels as src. </td></tr>
    <tr><td class="paramname">kernel</td><td>convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. </td></tr>
    <tr><td class="paramname">anchor</td><td>anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::filter2D</dd>
<dd>
cv::integral</dd></dl>
<p>dst_width = floor(src_width/2)[+1], dst_height = floor(src_height/2)[+1] </p><dl class="section see"><dt>See also</dt><dd>cv::pyrDown</dd></dl>
<p>dst_width = src_width*2, dst_height = src_height*2 </p><dl class="section see"><dt>See also</dt><dd>cv::pyrUp</dd>
<dd>
cv::pyrMeanShiftFiltering</dd>
<dd>
cv::watershed</dd></dl>
<p>(aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator. Scharr can be used only for the first dx or dy derivative </p><dl class="section see"><dt>See also</dt><dd>cv::Sobel</dd>
<dd>
cv::Laplacian</dd>
<dd>
cv::cvtColor</dd>
<dd>
cv::resize</dd></dl>
<dl class="section note"><dt>Note</dt><dd>::cvGetQuadrangleSubPix is similar to ::cvWarpAffine, but the outliers are extrapolated using replication border mode. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>cv::warpAffine</dd>
<dd>
cv::warpPerspective</dd>
<dd>
cv::remap</dd>
<dd>
cv::convertMaps</dd>
<dd>
cv::logPolar</dd></dl>
<p>Performs forward or inverse linear-polar image transform </p><dl class="section see"><dt>See also</dt><dd>cv::linearPolar</dd>
<dd>
cv::undistort</dd>
<dd>
cv::initUndistortRectifyMap</dd>
<dd>
cv::undistortPoints</dd>
<dd>
cvCreateStructuringElementEx</dd>
<dd>
cv::erode</dd></dl>
<p>If element pointer is NULL, 3x3 rectangular element is used </p><dl class="section see"><dt>See also</dt><dd>cv::dilate</dd>
<dd>
cv::morphologyEx</dd>
<dd>
cv::moments</dd>
<dd>
cv::HuMoments</dd></dl>
<p>dst(x,y) &lt;- src(x + center.x - dst_width/2, y + center.y - dst_height/2). Values of pixels with fractional coordinates are retrieved using bilinear interpolation </p><dl class="section see"><dt>See also</dt><dd>cv::getRectSubPix</dd></dl>
<p>matrixarr = ( a11 a12 | b1 ) dst(x,y) &lt;- src(A[x y]' + b) ( a21 a22 | b2 ) (bilinear interpolation is used to retrieve pixels with fractional coordinates) </p><dl class="section see"><dt>See also</dt><dd>cvWarpAffine</dd>
<dd>
cv::matchTemplate</dd></dl>
<p>(if the substitutor is null, the last retrieved contour is removed from the tree) </p><dl class="section see"><dt>See also</dt><dd>cvFindContours</dd></dl>
<p>The reader is used to iteratively get coordinates of all the chain points. If the Freeman codes should be read as is, a simple sequence reader should be used </p><dl class="section see"><dt>See also</dt><dd>cvApproxChains</dd></dl>
<p>This is a standalone function for setting bin ranges in the histogram. For a more detailed description of the parameters ranges and uniform, see the :ocvCalcHist function that can initialize the ranges as well. Ranges for the histogram bins must be set before the histogram is calculated or the backproject of the histogram is calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">ranges</td><td>Array of bin ranges arrays. See :ocvCreateHist for details. </td></tr>
    <tr><td class="paramname">uniform</td><td>Uniformity flag. See :ocvCreateHist for details.</td></tr>
  </table>
  </dd>
</dl>
<p>The function releases the histogram (header and the data). The pointer to the histogram is cleared by the function. If *hist pointer is already NULL, the function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Double pointer to the released histogram.</td></tr>
  </table>
  </dd>
</dl>
<p>The function sets all of the histogram bins to 0 in case of a dense histogram and removes all histogram bins in case of a sparse array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram.</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds the minimum and maximum histogram bins and their positions. All of output arguments are optional. Among several extremas with the same value the ones with the minimum index (in the lexicographical order) are returned. In case of several maximums or minimums, the earliest in the lexicographical order (extrema locations) is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">min_value</td><td>Pointer to the minimum value of the histogram. </td></tr>
    <tr><td class="paramname">max_value</td><td>Pointer to the maximum value of the histogram. </td></tr>
    <tr><td class="paramname">min_idx</td><td>Pointer to the array of coordinates for the minimum. </td></tr>
    <tr><td class="paramname">max_idx</td><td>Pointer to the array of coordinates for the maximum.</td></tr>
  </table>
  </dd>
</dl>
<p>The function normalizes the histogram bins by scaling them so that the sum of the bins becomes equal to factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Pointer to the histogram. </td></tr>
    <tr><td class="paramname">factor</td><td>Normalization factor.</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears histogram bins that are below the specified threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>Pointer to the histogram. </td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold level.</td></tr>
  </table>
  </dd>
</dl>
<p>The function makes a copy of the histogram. If the second histogram pointer *dst is NULL, a new histogram of the same size as src is created. Otherwise, both histograms must have equal types and sizes. Then the function copies the bin values of the source histogram to the destination histogram and sets the same bin value ranges as in src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source histogram. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination histogram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::calcHist</dd>
<dd>
cvCalcBackProject, cv::calcBackProject</dd></dl>
<p>The function calculates the back projection by comparing histograms of the source image patches with the given histogram. The function is similar to matchTemplate, but instead of comparing the raster patch with all its possible positions within the search window, the function CalcBackProjectPatch compares histograms. See the algorithm diagram below:</p>
<div class="image">
<img src="pics/backprojectpatch.png" alt="image"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Source images (though, you may pass CvMat** as well). </td></tr>
    <tr><td class="paramname">dst</td><td>Destination image. </td></tr>
    <tr><td class="paramname">range</td><td></td></tr>
    <tr><td class="paramname">hist</td><td>Histogram. </td></tr>
    <tr><td class="paramname">method</td><td>Comparison method passed to cvCompareHist (see the function description). </td></tr>
    <tr><td class="paramname">factor</td><td>Normalization factor for histograms that affects the normalization scale of the destination image. Pass 1 if not sure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvCalcBackProjectPatch</dd></dl>
<p>The function calculates the object probability density from two histograms as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{disthist} (I)= \forkthree{0}{if \(\texttt{hist1}(I)=0\)}{\texttt{scale}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) &gt; \texttt{hist1}(I)\)}{\frac{\texttt{hist2}(I) \cdot \texttt{scale}}{\texttt{hist1}(I)}}{if \(\texttt{hist1}(I) \ne 0\) and \(\texttt{hist2}(I) \le \texttt{hist1}(I)\)}\]" src="form_344.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist1</td><td>First histogram (the divisor). </td></tr>
    <tr><td class="paramname">hist2</td><td>Second histogram. </td></tr>
    <tr><td class="paramname">dst_hist</td><td>Destination histogram. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor for the destination histogram.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::equalizeHist</dd>
<dd>
cv::distanceTransform</dd></dl>
<p>The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and CV_ADAPTIVE_THRESH_GAUSSIAN_C are: neighborhood size (3, 5, 7 etc.), and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...) </p><dl class="section see"><dt>See also</dt><dd>cv::adaptiveThreshold</dd>
<dd>
cv::floodFill</dd>
<dd>
cv::Canny</dd></dl>
<p>Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy. Applying threshold to the result gives coordinates of corners </p><dl class="section see"><dt>See also</dt><dd>cv::preCornerDetect</dd>
<dd>
cv::cornerEigenValsAndVecs</dd>
<dd>
cv::cornerMinEigenVal</dd></dl>
<p>Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel </p><dl class="section see"><dt>See also</dt><dd>cv::cornerHarris</dd>
<dd>
cv::cornerSubPix</dd>
<dd>
cv::goodFeaturesToTrack</dd>
<dd>
cv::fitLine</dd>
<dd>
cv::line</dd></dl>
<p>if thickness&lt;0 (e.g. thickness == CV_FILLED), the filled box is drawn </p><dl class="section see"><dt>See also</dt><dd>cv::rectangle</dd>
<dd>
cv::rectangle</dd></dl>
<p>Thickness works in the same way as with cvRectangle </p><dl class="section see"><dt>See also</dt><dd>cv::circle</dd></dl>
<p>depending on <em>thickness</em>, <em>start_angle</em> and <em>end_angle</em> parameters. The resultant figure is rotated by <em>angle</em>. All the angles are in degrees </p><dl class="section see"><dt>See also</dt><dd>cv::ellipse</dd>
<dd>
cv::fillConvexPoly</dd>
<dd>
cv::fillPoly</dd>
<dd>
cv::polylines</dd></dl>
<p>The function initializes the font structure that can be passed to text rendering functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">font</td><td>Pointer to the font structure initialized by the function </td></tr>
    <tr><td class="paramname">font_face</td><td>Font name identifier. See cv::HersheyFonts and corresponding old CV_* identifiers. </td></tr>
    <tr><td class="paramname">hscale</td><td>Horizontal scale. If equal to 1.0f , the characters have the original width depending on the font type. If equal to 0.5f , the characters are of half the original width. </td></tr>
    <tr><td class="paramname">vscale</td><td>Vertical scale. If equal to 1.0f , the characters have the original height depending on the font type. If equal to 0.5f , the characters are of half the original height. </td></tr>
    <tr><td class="paramname">shear</td><td>Approximate tangent of the character slope relative to the vertical line. A zero value means a non-italic font, 1.0f means about a 45 degree slope, etc. </td></tr>
    <tr><td class="paramname">thickness</td><td>Thickness of the text strokes </td></tr>
    <tr><td class="paramname">line_type</td><td>Type of the strokes, see line description</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvPutText</dd>
<dd>
cvInitFont, cvGetTextSize, cvFont, cv::putText</dd>
<dd>
cv::getTextSize</dd>
<dd>
cv::drawContours</dd></dl>
<p>stop capturing/reading and free resources</p>
<p>Saves an object to a file.</p>
<p>Releases an object.</p>
<p>Unregisters the type.</p>
<p>Registers a new type.</p>
<p>Writes a file node to another file storage.</p>
<p>Reads multiple numbers.</p>
<p>Initializes file node sequence reader.</p>
<p>Initializes the file node sequence reader.</p>
<p>Writes multiple numbers in Base64.</p>
<p>Writes multiple numbers.</p>
<p>Starts the next stream.</p>
<p>Writes an object to file storage.</p>
<p>Writes a comment.</p>
<p>Writes a text string.</p>
<p>Writes a floating-point value.</p>
<p>Writes an integer value.</p>
<p>Finishes writing to a file node collection.</p>
<p>Starts writing a new structure.</p>
<p>Releases file storage.</p>
<p>Makes OpenCV use IPL functions for allocating IplImage and IplROI structures.</p>
<p>Calculates the cross product of two 3D vectors.</p>
<p>Fills an array with random numbers and updates the RNG state.</p>
<p>Converts one array to another with optional linear transformation.</p>
<p>Clears the array.</p>
<p>Sets every element of an array to a given value.</p>
<p>Copies one array to another.</p>
<p>Retrieves low-level information about the array.</p>
<p>Assigns user data to the array header.</p>
<p>Releases array data.</p>
<p>Allocates array data.</p>
<p>Change a specific array element.</p>
<p>Change the particular array element.</p>
<p>Deallocates sparse array.</p>
<p>Deallocates a matrix.</p>
<p>Resets the image ROI to include the entire image and releases the ROI structure.</p>
<p>Sets an image Region Of Interest (ROI) for a given rectangle.</p>
<p>Sets the channel of interest in an IplImage.</p>
<p>Deallocates the image header and the image data.</p>
<p><code>free</code> wrapper. Here and further all the memory releasing functions (that all call cvFree) take double pointer in order to to clear pointer to the data after releasing it. Passing pointer to NULL pointer is Ok: nothing happens in this case</p>
<p>This call is an analogue of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(image )</div><div class="line">{</div><div class="line">    iplDeallocate(*image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI);</div><div class="line">    *image = 0;</div><div class="line">}</div></div><!-- fragment --><p> but it does not use IPL functions by default (see the CV_TURN_ON_IPL_COMPATIBILITY macro). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>This call is a shortened form of : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*image )</div><div class="line">{</div><div class="line">    cvReleaseData(*image);</div><div class="line">    cvReleaseImageHeader(image);</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Double pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>If the ROI is set to NULL and the coi is <em>not</em> 0, the ROI is allocated. Most OpenCV functions do not* support the COI setting, so to process an individual image/matrix channel one may copy (via cvCopy or cvSplit) the channel to a separate image/matrix, process it and then copy the result back (via cvCopy or cvMerge) if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">coi</td><td>The channel of interest. 0 - all channels are selected, 1 - first channel is selected, etc. Note that the channel indices become 1-based.</td></tr>
  </table>
  </dd>
</dl>
<p>If the original image ROI was NULL and the rect is not the whole image, the ROI structure is allocated.</p>
<p>Most OpenCV functions support the use of ROI and treat the image rectangle as a separate image. For example, all of the pixel coordinates are counted from the top-left (or bottom-left) corner of the ROI, not the original image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header </td></tr>
    <tr><td class="paramname">rect</td><td>The ROI rectangle</td></tr>
  </table>
  </dd>
</dl>
<p>This produces a similar result to the following, but in addition it releases the ROI structure. : </p><div class="fragment"><div class="line">cvSetImageROI(image, <a class="code" href="group__core__c.html#gafaffdb9052823163862a88209f379921">cvRect</a>(0, 0, image-&gt;width, image-&gt;height ));</div><div class="line">cvSetImageCOI(image, 0);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>A pointer to the image header</td></tr>
  </table>
  </dd>
</dl>
<p>The function decrements the matrix data reference counter and deallocates matrix header. If the data reference counter is 0, it also deallocates the data. : </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(*mat )</div><div class="line">    <a class="code" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85">cvDecRefData</a>(*mat);</div><div class="line">cvFree((<span class="keywordtype">void</span>**)mat);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the matrix</td></tr>
  </table>
  </dd>
</dl>
<p>low-level scalar &lt;-&gt; raw data conversion functions</p>
<p>The function releases the sparse array and clears the array pointer upon exit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Double pointer to the array</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign the new value to a particular array element. In the case of a sparse array the functions create the node if it does not exist yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx</td><td>Array of the element indices </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>The functions assign a new value to a specific element of a single-channel array. If the array has multiple channels, a runtime error is raised. Note that the Set*D function can be used safely for both single-channel and multiple-channel arrays, though they are a bit slower.</p>
<p>In the case of a sparse array the functions create the node if it does not yet exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array </td></tr>
    <tr><td class="paramname">idx0</td><td>The first zero-based component of the element index </td></tr>
    <tr><td class="paramname">value</td><td>The assigned value</td></tr>
  </table>
  </dd>
</dl>
<p>clears element of ND dense array, in case of sparse arrays it deletes the specified node</p>
<p>Repeats source 2d array several times in both horizontal and vertical direction to fill destination array</p>
<p>The function allocates image, matrix or multi-dimensional dense array data. Note that in the case of matrix types OpenCV allocation functions are used. In the case of IplImage they are used unless CV_TURN_ON_IPL_COMPATIBILITY() has been called before. In the latter case IPL functions are used to allocate the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function releases the array data. In the case of <a class="el" href="struct_cv_mat.html">CvMat</a> or <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> it simply calls <a class="el" href="group__core__c.html#ga67c50b750b763270b8330a18b3172c85" title="Decrements an array data reference counter. ">cvDecRefData()</a>, that is the function can not deallocate external data. See also the note to cvCreateData . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header</td></tr>
  </table>
  </dd>
</dl>
<p>The function assigns user data to the array header. Header should be initialized before using cvCreateMatHeader, cvCreateImageHeader, cvCreateMatNDHeader, cvInitMatHeader, cvInitImageHeader or cvInitMatNDHeader. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>User data </td></tr>
    <tr><td class="paramname">step</td><td>Full row length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The function fills output variables with low-level information about the array data. All output</p>
<p>parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, the parameters of ROI are returned.</p>
<p>The following example shows how to get access to array elements. It computes absolute values of the array elements : </p><div class="fragment"><div class="line"><span class="keywordtype">float</span>* data;</div><div class="line"><span class="keywordtype">int</span> step;</div><div class="line"><a class="code" href="struct_cv_size.html">CvSize</a> size;</div><div class="line"></div><div class="line">cvGetRawData(array, (uchar**)&amp;data, &amp;step, &amp;size);</div><div class="line">step /= <span class="keyword">sizeof</span>(data[0]);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = 0; y &lt; size.height; y++, data += step )</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x = 0; x &lt; size.width; x++ )</div><div class="line">        data[x] = (<span class="keywordtype">float</span>)fabs(data[x]);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array header </td></tr>
    <tr><td class="paramname">data</td><td>Output pointer to the whole image origin or ROI origin if ROI is set </td></tr>
    <tr><td class="paramname">step</td><td>Output full row length in bytes </td></tr>
    <tr><td class="paramname">roi_size</td><td>Output ROI size</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies selected elements from an input array to an output array:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} (I)= \texttt{src} (I) \quad \text{if} \quad \texttt{mask} (I) \ne 0.\]" src="form_158.png"/>
</p>
<p>If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions, and the same size. The function can also copy sparse arrays (mask is not supported in this case). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source array </td></tr>
    <tr><td class="paramname">dst</td><td>The destination array </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function copies the scalar value to every selected element of the destination array: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{arr} (I)= \texttt{value} \quad \text{if} \quad \texttt{mask} (I) \ne 0\]" src="form_159.png"/>
</p>
<p> If array arr is of IplImage type, then is ROI used, but COI must not be set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">value</td><td>Fill value </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, 8-bit single channel array; specifies elements of the destination array to be changed</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears the array. In the case of dense arrays (<a class="el" href="struct_cv_mat.html">CvMat</a>, <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> or IplImage), cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0). In the case of sparse arrays all the elements are removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to be cleared</td></tr>
  </table>
  </dd>
</dl>
<p>Splits a multi-channel array into the set of single-channel arrays or extracts particular [color] plane</p>
<p>Merges a set of single-channel arrays into the single multi-channel array or inserts one particular [color] plane to the array</p>
<p>Copies several channels from input arrays to certain channels of output arrays</p>
<p>The function has several different purposes, and thus has several different names. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} (I) = \texttt{scale} \texttt{src} (I) + ( \texttt{shift} _0, \texttt{shift} _1,...)\]" src="form_160.png"/>
</p>
<p>All the channels of multi-channel arrays are processed independently.</p>
<p>The type of conversion is done with rounding and saturation, that is if the result of scaling + conversion can not be represented exactly by a value of the destination array element type, it is set to the nearest representable value on the real axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source array </td></tr>
    <tr><td class="paramname">dst</td><td>Destination array </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor </td></tr>
    <tr><td class="paramname">shift</td><td>Value added to the scaled source array elements</td></tr>
  </table>
  </dd>
</dl>
<p>Performs linear transformation on every source array element, stores absolute value of the result: dst(x,y,c) = abs(scale*src(x,y,c)+shift). destination array must have 8u type. In other cases one may use cvConvertScale + cvAbsDiffS</p>
<p>dst(mask) = src1(mask) + src2(mask)</p>
<p>dst(mask) = src(mask) + value</p>
<p>dst(mask) = src1(mask) - src2(mask)</p>
<p>dst(mask) = value - src(mask)</p>
<p>dst(idx) = src1(idx) * src2(idx) * scale (scaled element-wise multiplication of 2 arrays)</p>
<p>element-wise division/inversion with scaling: dst(idx) = src1(idx) * scale / src2(idx) or dst(idx) = scale / src2(idx) if src1 == 0</p>
<p>dst = src1 * scale + src2</p>
<p>dst = src1 * alpha + src2 * beta + gamma</p>
<p>dst(idx) = src1(idx) &amp; src2(idx)</p>
<p>dst(idx) = src(idx) &amp; value</p>
<p>dst(idx) = src1(idx) | src2(idx)</p>
<p>dst(idx) = src(idx) | value</p>
<p>dst(idx) = src1(idx) ^ src2(idx)</p>
<p>dst(idx) = src(idx) ^ value</p>
<p>dst(idx) = ~src(idx)</p>
<p>dst(idx) = lower(idx) &lt;= src(idx) &lt; upper(idx)</p>
<p>dst(idx) = lower &lt;= src(idx) &lt; upper</p>
<p>The comparison operation support single-channel arrays only. Destination image should be 8uC1 or 8sC1 dst(idx) = src1(idx) <em>cmp_op</em> src2(idx)</p>
<p>dst(idx) = src1(idx) <em>cmp_op</em> value</p>
<p>dst(idx) = min(src1(idx),src2(idx))</p>
<p>dst(idx) = max(src1(idx),src2(idx))</p>
<p>dst(idx) = min(src(idx),value)</p>
<p>dst(idx) = max(src(idx),value)</p>
<p>dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))</p>
<p>dst(x,y,c) = abs(src(x,y,c) - value(c))</p>
<p>Does cartesian-&gt;polar coordinates conversion. Either of output components (magnitude or angle) is optional</p>
<p>Does polar-&gt;cartesian coordinates conversion. Either of output components (magnitude or angle) is optional. If magnitude is missing it is assumed to be all 1's</p>
<p>Does powering: dst(idx) = src(idx)^power</p>
<p>Does exponention: dst(idx) = exp(src(idx)). Overflow is not handled yet. Underflow is handled. Maximal relative error is ~7e-6 for single-precision input</p>
<p>Calculates natural logarithms: dst(idx) = log(abs(src(idx))). Logarithm of 0 gives large negative number(~-700) Maximal relative error is ~3e-7 for single-precision output</p>
<p>The function fills the destination array with uniformly or normally distributed random numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>CvRNG state initialized by cvRNG </td></tr>
    <tr><td class="paramname">arr</td><td>The destination array </td></tr>
    <tr><td class="paramname">dist_type</td><td>Distribution type <blockquote class="doxtable">
<ul>
<li><b>CV_RAND_UNI</b> uniform distribution</li>
<li><b>CV_RAND_NORMAL</b> normal or Gaussian distribution </li>
</ul>
</blockquote>
</td></tr>
    <tr><td class="paramname">param1</td><td>The first parameter of the distribution. In the case of a uniform distribution it is the inclusive lower boundary of the random numbers range. In the case of a normal distribution it is the mean value of the random numbers. </td></tr>
    <tr><td class="paramname">param2</td><td>The second parameter of the distribution. In the case of a uniform distribution it is the exclusive upper boundary of the random numbers range. In the case of a normal distribution it is the standard deviation of the random numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>randu, randn, RNG::fill.</dd></dl>
<p>Finds all real and complex roots of a polynomial equation</p>
<p>The function calculates the cross product of two 3D vectors: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} = \texttt{src1} \times \texttt{src2}\]" src="form_163.png"/>
</p>
<p> or: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\begin{array}{l} \texttt{dst} _1 = \texttt{src1} _2 \texttt{src2} _3 - \texttt{src1} _3 \texttt{src2} _2 \\ \texttt{dst} _2 = \texttt{src1} _3 \texttt{src2} _1 - \texttt{src1} _1 \texttt{src2} _3 \\ \texttt{dst} _3 = \texttt{src1} _1 \texttt{src2} _2 - \texttt{src1} _2 \texttt{src2} _1 \end{array}\]" src="form_164.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>The first source vector </td></tr>
    <tr><td class="paramname">src2</td><td>The second source vector </td></tr>
    <tr><td class="paramname">dst</td><td>The destination vector</td></tr>
  </table>
  </dd>
</dl>
<p>Extended matrix transform: dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T</p>
<p>Transforms each element of source array and stores resultant vectors in destination array</p>
<p>Does perspective transform on every element of input array</p>
<p>Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)</p>
<p>Tranposes matrix. Square matrices can be transposed in-place</p>
<p>Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part</p>
<p>Mirror array data around horizontal (flip=0), vertical (flip=1) or both(flip=-1) axises: cvFlip(src) flips images vertically and sequences horizontally (inplace)</p>
<p>Performs Singular Value Decomposition of a matrix</p>
<p>Performs Singular Value Back Substitution (solves A*X = B): flags must be the same as in cvSVD</p>
<p>Finds eigen values and vectors of a symmetric matrix</p>
<ul>
<li><p class="startli">Finds selected eigen values and vectors of a symmetric matrix */ Makes an identity matrix (mat_ij = i == j)</p>
<p class="startli">Calculates covariation matrix for a set of vectors </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__c.html#core_c_CovarFlags">flags</a></dd></dl>
<p>Calculates mean and standard deviation of pixel values</p>
</li>
</ul>
<p>Finds global minimum, maximum and their positions</p>
<dl class="section see"><dt>See also</dt><dd>ref core_c_NormFlags "flags"</dd>
<dd>
<a class="el" href="group__core__c.html#core_c_ReduceFlags">flags</a></dd></dl>
<p>Discrete Fourier Transform: complex-&gt;complex, real-&gt;ccs (forward), ccs-&gt;real (inverse) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y)) </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Discrete Cosine Transform </p><dl class="section see"><dt>See also</dt><dd>core_c_DftFlags "flags"</dd></dl>
<p>Releases memory storage. All the children of a parent must be released before the parent. A child storage returns all the blocks to parent when it is released</p>
<p>Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos) to reuse memory allocated for the storage - cvClearSeq,cvClearSet ... do not free any memory. A child storage returns all the blocks to the parent when it is cleared</p>
<p>Remember a storage "free memory" position</p>
<p>Restore a storage "free memory" position</p>
<p>Changes default size (granularity) of sequence blocks. The default size is ~1Kbyte</p>
<p>Removes the last element from sequence and optionally saves it</p>
<p>Removes the first element from sequence and optioanally saves it</p>
<p>Adds several new elements to the end of sequence</p>
<p>Removes several elements from the end of sequence and optionally saves them</p>
<p>Removes specified sequence element</p>
<p>Removes all the elements from the sequence. The freed memory can be reused later only by the same sequence unless cvClearMemStorage or cvRestoreMemStoragePos is called</p>
<p>Initializes sequence writer. The new elements will be added to the end of sequence</p>
<p>Combination of cvCreateSeq and cvStartAppendToSeq</p>
<p>Updates sequence header. May be useful to get access to some of previously written elements via cvGetSeqElem or sequence reader</p>
<p>Initializes sequence reader. The sequence can be read in forward or backward direction</p>
<p>Changes sequence reader position. It may seek to an absolute or to relative to the current position</p>
<p>Removes sequence slice</p>
<p>Inserts a sequence or array into another sequence</p>
<p>Sorts sequence in-place given element comparison function</p>
<p>Reverses order of sequence elements in-place</p>
<p>Removes element from the set by its index</p>
<p>Removes all the elements from the set</p>
<p>Remove edge connecting two vertices</p>
<p>Remove all vertices and edges from the graph</p>
<p>Releases graph scanner.</p>
<p>Does look-up transformation. Elements of the source array (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table</p>
<p>Inserts sequence into tree with specified "parent" sequence. If parent is equal to frame (e.g. the most external contour), then added contour will have null pointer to parent.</p>
<p>Removes contour from tree (together with the contour children).</p>
<p>Normally, the function is not called directly. Instead, a simple macro CV_TURN_ON_IPL_COMPATIBILITY() is used that calls cvSetIPLAllocators and passes there pointers to IPL allocation functions. : </p><div class="fragment"><div class="line">...</div><div class="line">CV_TURN_ON_IPL_COMPATIBILITY()</div><div class="line">...</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_header</td><td>pointer to a function, creating IPL image header. </td></tr>
    <tr><td class="paramname">allocate_data</td><td>pointer to a function, allocating IPL image data. </td></tr>
    <tr><td class="paramname">deallocate</td><td>pointer to a function, deallocating IPL image. </td></tr>
    <tr><td class="paramname">create_roi</td><td>pointer to a function, creating IPL image ROI (i.e. Region of Interest). </td></tr>
    <tr><td class="paramname">clone_image</td><td>pointer to a function, cloning an IPL image.</td></tr>
  </table>
  </dd>
</dl>
<p>The function closes the file associated with the storage and releases all the temporary structures. It must be called after all I/O operations with the storage are finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Double pointer to the released file storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function starts writing a compound structure (collection) that can be a sequence or a map. After all the structure fields, which can be scalars or structures, are written, cvEndWriteStruct should be called. The function can be used to group some objects or to implement the write function for a some user object (see <a class="el" href="struct_cv_type_info.html" title="Type information. ">CvTypeInfo</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written structure. The structure can be accessed by this name when the storage is read. </td></tr>
    <tr><td class="paramname">struct_flags</td><td>A combination one of the following values:<ul>
<li><b>CV_NODE_SEQ</b> the written structure is a sequence (see discussion of CvFileStorage ), that is, its elements do not have a name.</li>
<li><b>CV_NODE_MAP</b> the written structure is a map (see discussion of CvFileStorage ), that is, all its elements have names. One and only one of the two above flags must be specified</li>
<li><b>CV_NODE_FLOW</b> the optional flag that makes sense only for YAML streams. It means that the structure is written as a flow (not as a block), which is more compact. It is recommended to use this flag for structures or arrays whose elements are all scalars. </li>
</ul>
</td></tr>
    <tr><td class="paramname">type_name</td><td>Optional parameter - the object type name. In case of XML it is written as a type_id attribute of the structure opening tag. In the case of YAML it is written after a colon following the structure name (see the example in CvFileStorage description). In case of JSON it is written as a name/value pair. Mainly it is used with user objects. When the storage is read, the encoded type name is used to determine the object type (see <a class="el" href="struct_cv_type_info.html" title="Type information. ">CvTypeInfo</a> and cvFindType ). </td></tr>
    <tr><td class="paramname">attributes</td><td>This parameter is not used in the current implementation</td></tr>
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cvStartWriteStruct.</dd></dl>
<p>The function writes a single integer value (with or without a name) to the file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a single floating-point value (with or without a name) to file storage. Special values are encoded as follows: NaN (Not A Number) as .NaN, infinity as +.Inf or -.Inf.</p>
<p>The following example shows how to use the low-level writing functions to store custom structures, such as termination criteria, without registering a new type. : </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> write_termcriteria( <a class="code" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs, <span class="keyword">const</span> <span class="keywordtype">char</span>* struct_name,</div><div class="line">                         <a class="code" href="struct_cv_term_criteria.html">CvTermCriteria</a>* termcrit )</div><div class="line">{</div><div class="line">    cvStartWriteStruct( fs, struct_name, CV_NODE_MAP, NULL, <a class="code" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0));</div><div class="line">    cvWriteComment( fs, <span class="stringliteral">&quot;termination criteria&quot;</span>, 1 ); <span class="comment">// just a description</span></div><div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_ITER )</div><div class="line">        cvWriteInteger( fs, <span class="stringliteral">&quot;max_iterations&quot;</span>, termcrit-&gt;max_iter );</div><div class="line">    <span class="keywordflow">if</span>( termcrit-&gt;<a class="code" href="struct_cv_term_criteria.html#a78bcb789341fdbd785b794b92555d6e0">type</a> &amp; CV_TERMCRIT_EPS )</div><div class="line">        cvWriteReal( fs, <span class="stringliteral">&quot;accuracy&quot;</span>, termcrit-&gt;epsilon );</div><div class="line">    cvEndWriteStruct( fs );</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written value. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">value</td><td>The written value</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a text string to file storage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written string . Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">str</td><td>The written text string </td></tr>
    <tr><td class="paramname">quote</td><td>If non-zero, the written string is put in quotes, regardless of whether they are required. Otherwise, if the flag is zero, quotes are used only when they are required (e.g. when the string starts with a digit or contains spaces).</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a comment into file storage. The comments are skipped when the storage is read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">comment</td><td>The written comment, single-line or multi-line </td></tr>
    <tr><td class="paramname">eol_comment</td><td>If non-zero, the function tries to put the comment at the end of current line. If the flag is zero, if the comment is multi-line, or if it does not fit at the end of the current line, the comment starts a new line.</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an object to file storage. First, the appropriate type info is found using cvTypeOf. Then, the write method associated with the type info is called.</p>
<p>Attributes are used to customize the writing procedure. The standard types support the following attributes (all the dt attributes have the same format as in cvWriteRawData):</p>
<ol type="1">
<li><a class="el" href="struct_cv_seq.html">CvSeq</a><ul>
<li><b>header_dt</b> description of user fields of the sequence header that follow <a class="el" href="struct_cv_seq.html">CvSeq</a>, or <a class="el" href="struct_cv_chain.html">CvChain</a> (if the sequence is a Freeman chain) or <a class="el" href="struct_cv_contour.html">CvContour</a> (if the sequence is a contour or point sequence)</li>
<li><b>dt</b> description of the sequence elements.</li>
<li><b>recursive</b> if the attribute is present and is not equal to "0" or "false", the whole tree of sequences (contours) is stored.</li>
</ul>
</li>
<li><a class="el" href="struct_cv_graph.html">CvGraph</a><ul>
<li><b>header_dt</b> description of user fields of the graph header that follows <a class="el" href="struct_cv_graph.html">CvGraph</a>;</li>
<li><b>vertex_dt</b> description of user fields of graph vertices</li>
<li><b>edge_dt</b> description of user fields of graph edges (note that the edge weight is always written, so there is no need to specify it explicitly)</li>
</ul>
</li>
</ol>
<p>Below is the code that creates the YAML file shown in the CvFileStorage description: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cxcore.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div><div class="line">{</div><div class="line">    <a class="code" href="struct_cv_mat.html">CvMat</a>* mat = cvCreateMat( 3, 3, CV_32F );</div><div class="line">    <a class="code" href="group__core__c.html#ga84556d1bb6f1b8b02c04c60246747a7e">CvFileStorage</a>* fs = cvOpenFileStorage( <span class="stringliteral">&quot;example.yml&quot;</span>, 0, CV_STORAGE_WRITE );</div><div class="line"></div><div class="line">    cvSetIdentity( mat );</div><div class="line">    cvWrite( fs, <span class="stringliteral">&quot;A&quot;</span>, mat, <a class="code" href="group__core__c.html#ga678df8d29bbf1c3a7555dd82fd3800bd">cvAttrList</a>(0,0) );</div><div class="line"></div><div class="line">    cvReleaseFileStorage( &amp;fs );</div><div class="line">    cvReleaseMat( &amp;mat );</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">name</td><td>Name of the written object. Should be NULL if and only if the parent structure is a sequence. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the object </td></tr>
    <tr><td class="paramname">attributes</td><td>The attributes of the object. They are specific for each particular type (see the discussion below).</td></tr>
  </table>
  </dd>
</dl>
<p>The function finishes the currently written stream and starts the next stream. In the case of XML the file with multiple streams looks like this: </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line"><span class="comment">&lt;!-- stream #1 data --&gt;</span></div><div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line">&lt;<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line"><span class="comment">&lt;!-- stream #2 data --&gt;</span></div><div class="line">&lt;/<span class="keywordtype">opencv_storage</span>&gt;</div><div class="line">...</div></div><!-- fragment --><p> The YAML file will look like this: </p><div class="fragment"><div class="line">%YAML 1.0</div><div class="line"># stream #1 data</div><div class="line">...</div><div class="line">---</div><div class="line"># stream #2 data</div></div><!-- fragment --><p> This is useful for concatenating files or for resuming the writing process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes an array, whose elements consist of single or multiple numbers. The function call can be replaced with a loop containing a few cvWriteInt and cvWriteReal calls, but a single call is more efficient. Note that because none of the elements have a name, they should be written to a sequence rather than a map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the written array </td></tr>
    <tr><td class="paramname">len</td><td>Number of the array elements to write </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element, see <a class="el" href="group__core__xml.html#format_spec">format specification</a></td></tr>
  </table>
  </dd>
</dl>
<p>If either CV_STORAGE_WRITE_BASE64 or <a class="el" href="classcv_1_1_file_storage.html#a973e41cb75ef6230412a567723b7482da74cdcbdb96c29f19e3ccc2ba4ab81614" title="flag, enable both WRITE and BASE64 ">cv::FileStorage::WRITE_BASE64</a> is used, this function will be the same as cvWriteRawData. If neither, the main difference is that it outputs a sequence in Base64 encoding rather than in plain text.</p>
<p>This function can only be used to write a sequence with a type "binary".</p>
<p>Consider the following two examples where their output is the same: </p><div class="fragment"></div><!-- fragment --><p>and </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the written array </td></tr>
    <tr><td class="paramname">len</td><td>Number of the array elements to write </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element, see <a class="el" href="group__core__xml.html#format_spec">format specification</a></td></tr>
  </table>
  </dd>
</dl>
<p>The function initializes the sequence reader to read data from a file node. The initialized reader can be then passed to cvReadRawDataSlice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">reader</td><td>Pointer to the sequence reader</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads one or more elements from the file node, representing a sequence, to a user-specified array. The total number of read sequence elements is a product of total and the number of components in each array element. For example, if dt=2if, the function will read total*3 sequence elements. As with any sequence, some parts of the file node sequence can be skipped or read repeatedly by repositioning the reader using cvSetSeqReaderPos. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">reader</td><td>The sequence reader. Initialize it with cvStartReadRawData . </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to read </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function reads elements from a file node that represents a sequence of scalars. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>File storage </td></tr>
    <tr><td class="paramname">src</td><td>The file node (a sequence) to read numbers from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination array </td></tr>
    <tr><td class="paramname">dt</td><td>Specification of each array element. It has the same format as in cvWriteRawData .</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes a copy of a file node to file storage. Possible applications of the function are merging several file storages into one and conversion between XML, YAML and JSON formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>Destination file storage </td></tr>
    <tr><td class="paramname">new_node_name</td><td>New name of the file node in the destination file storage. To keep the existing name, use cvcvGetFileNodeName </td></tr>
    <tr><td class="paramname">node</td><td>The written node </td></tr>
    <tr><td class="paramname">embed</td><td>If the written node is a collection and this parameter is not zero, no extra level of hierarchy is created. Instead, all the elements of node are written into the currently written structure. Of course, map elements can only be embedded into another map, and sequence elements can only be embedded into another sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>The function registers a new type, which is described by info . The function creates a copy of the structure, so the user should delete it after calling the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Type info structure</td></tr>
  </table>
  </dd>
</dl>
<p>The function unregisters a type with a specified name. If the name is unknown, it is possible to locate the type info by an instance of the type using cvTypeOf or by iterating the type list, starting from cvFirstType, and then calling cvUnregisterType(info-&gt;typeName). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>Name of an unregistered type</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds the type of a given object and calls release with the double pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_ptr</td><td>Double pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<p>The function saves an object to a file. It provides a simple interface to cvWrite . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File name </td></tr>
    <tr><td class="paramname">struct_ptr</td><td>Object to save </td></tr>
    <tr><td class="paramname">name</td><td>Optional object name. If it is NULL, the name will be formed from filename . </td></tr>
    <tr><td class="paramname">comment</td><td>Optional comment to put in the beginning of the file </td></tr>
    <tr><td class="paramname">attributes</td><td>Optional attributes passed to cvWrite</td></tr>
  </table>
  </dd>
</dl>
<p>Sets error status silently</p>
<p>Sets error status and performs some additonal actions (displaying message box, writing message to stderr, terminating application etc.) depending on the current error mode </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
