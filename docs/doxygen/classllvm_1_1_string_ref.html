<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2018-inseason: llvm::StringRef Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">2018-inseason
   </div>
   <div id="projectbrief">The Greybots&#39; 2018 Power Up code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>llvm</b></li><li class="navelem"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classllvm_1_1_string_ref-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">llvm::StringRef Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_string_ref_8h_source.html">StringRef.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7bf566fe5a23be3257375b0cf7f7c101"><td class="memItemLeft" align="right" valign="top"><a id="a7bf566fe5a23be3257375b0cf7f7c101"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a7bf566fe5a23be3257375b0cf7f7c101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b561890c89b3805eb29856ce78f862"><td class="memItemLeft" align="right" valign="top"><a id="a68b561890c89b3805eb29856ce78f862"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a68b561890c89b3805eb29856ce78f862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3a40d51d77f1faf56c40460033d0a9"><td class="memItemLeft" align="right" valign="top"><a id="a0f3a40d51d77f1faf56c40460033d0a9"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a0f3a40d51d77f1faf56c40460033d0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a0f1746161a67c7b6d85e8c6a6cca62cd"><td class="memItemLeft" align="right" valign="top"><a id="a0f1746161a67c7b6d85e8c6a6cca62cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a0f1746161a67c7b6d85e8c6a6cca62cd">StringRef</a> ()</td></tr>
<tr class="memdesc:a0f1746161a67c7b6d85e8c6a6cca62cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty string ref. <br /></td></tr>
<tr class="separator:a0f1746161a67c7b6d85e8c6a6cca62cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17da9958074a0ab57c90c7da4947d78"><td class="memItemLeft" align="right" valign="top"><a id="aa17da9958074a0ab57c90c7da4947d78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#aa17da9958074a0ab57c90c7da4947d78">StringRef</a> (const char *Str)</td></tr>
<tr class="memdesc:aa17da9958074a0ab57c90c7da4947d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a cstring. <br /></td></tr>
<tr class="separator:aa17da9958074a0ab57c90c7da4947d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827abb79f73f1af66ae0e6ffb3722cd3"><td class="memItemLeft" align="right" valign="top"><a id="a827abb79f73f1af66ae0e6ffb3722cd3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a827abb79f73f1af66ae0e6ffb3722cd3">StringRef</a> (const char *<a class="el" href="classllvm_1_1_string_ref.html#ad04539d64efd58e70c5e828739cf718e">data</a>, size_t length, bool isNullTerminated=false)</td></tr>
<tr class="memdesc:a827abb79f73f1af66ae0e6ffb3722cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a pointer and length. <br /></td></tr>
<tr class="separator:a827abb79f73f1af66ae0e6ffb3722cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcb6e1997e871ac41f506eff6bdc051"><td class="memItemLeft" align="right" valign="top"><a id="aebcb6e1997e871ac41f506eff6bdc051"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#aebcb6e1997e871ac41f506eff6bdc051">StringRef</a> (const std::string &amp;Str)</td></tr>
<tr class="memdesc:aebcb6e1997e871ac41f506eff6bdc051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from an std::string. <br /></td></tr>
<tr class="separator:aebcb6e1997e871ac41f506eff6bdc051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a46f643f1eb1939362c7dd79361bcbd0e"><td class="memItemLeft" align="right" valign="top"><a id="a46f643f1eb1939362c7dd79361bcbd0e"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a46f643f1eb1939362c7dd79361bcbd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996c7ca3dd6843ba5d55a7c217770270"><td class="memItemLeft" align="right" valign="top"><a id="a996c7ca3dd6843ba5d55a7c217770270"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:a996c7ca3dd6843ba5d55a7c217770270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2525d271567a5959d40df218c4db918"><td class="memItemLeft" align="right" valign="top"><a id="ae2525d271567a5959d40df218c4db918"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_begin</b> () const</td></tr>
<tr class="separator:ae2525d271567a5959d40df218c4db918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b4e8901251fd4307b717144f590477"><td class="memItemLeft" align="right" valign="top"><a id="a76b4e8901251fd4307b717144f590477"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_end</b> () const</td></tr>
<tr class="separator:a76b4e8901251fd4307b717144f590477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f22c3553e341404b445430a3b075b"><td class="memItemLeft" align="right" valign="top"><a id="a5e8f22c3553e341404b445430a3b075b"></a>
<a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; const unsigned char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bytes</b> () const</td></tr>
<tr class="separator:a5e8f22c3553e341404b445430a3b075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Operations</div></td></tr>
<tr class="memitem:ad04539d64efd58e70c5e828739cf718e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ad04539d64efd58e70c5e828739cf718e">data</a> () const</td></tr>
<tr class="separator:ad04539d64efd58e70c5e828739cf718e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e698ced744f380762a17f64a7cbd0aa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a2e698ced744f380762a17f64a7cbd0aa">c_str</a> (<a class="el" href="classllvm_1_1_small_vector_impl.html">llvm::SmallVectorImpl</a>&lt; char &gt; &amp;buf) const</td></tr>
<tr class="separator:a2e698ced744f380762a17f64a7cbd0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab721c4973132a753879169eaa0b84a30"><td class="memItemLeft" align="right" valign="top"><a id="ab721c4973132a753879169eaa0b84a30"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ab721c4973132a753879169eaa0b84a30">empty</a> () const</td></tr>
<tr class="memdesc:ab721c4973132a753879169eaa0b84a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty - Check if the string is empty. <br /></td></tr>
<tr class="separator:ab721c4973132a753879169eaa0b84a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08551f168e2745a0b71e6442fc0fb0"><td class="memItemLeft" align="right" valign="top"><a id="aca08551f168e2745a0b71e6442fc0fb0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0">size</a> () const</td></tr>
<tr class="memdesc:aca08551f168e2745a0b71e6442fc0fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">size - Get the string size. <br /></td></tr>
<tr class="separator:aca08551f168e2745a0b71e6442fc0fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2235bc6bb79affe31c61601a1d65746"><td class="memItemLeft" align="right" valign="top"><a id="ae2235bc6bb79affe31c61601a1d65746"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ae2235bc6bb79affe31c61601a1d65746">is_null_terminated</a> () const</td></tr>
<tr class="memdesc:ae2235bc6bb79affe31c61601a1d65746"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_null_terminated - Get if the string is guaranteed null terminated <br /></td></tr>
<tr class="separator:ae2235bc6bb79affe31c61601a1d65746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61364ca3a5ff90fb2aa0d5a371fd43f7"><td class="memItemLeft" align="right" valign="top"><a id="a61364ca3a5ff90fb2aa0d5a371fd43f7"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a61364ca3a5ff90fb2aa0d5a371fd43f7">front</a> () const</td></tr>
<tr class="memdesc:a61364ca3a5ff90fb2aa0d5a371fd43f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">front - Get the first character in the string. <br /></td></tr>
<tr class="separator:a61364ca3a5ff90fb2aa0d5a371fd43f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6faabb08339ea1dd11e9d37a668634"><td class="memItemLeft" align="right" valign="top"><a id="a5b6faabb08339ea1dd11e9d37a668634"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a5b6faabb08339ea1dd11e9d37a668634">back</a> () const</td></tr>
<tr class="memdesc:a5b6faabb08339ea1dd11e9d37a668634"><td class="mdescLeft">&#160;</td><td class="mdescRight">back - Get the last character in the string. <br /></td></tr>
<tr class="separator:a5b6faabb08339ea1dd11e9d37a668634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66731b70af2ad5aded1ce13a20acb29"><td class="memTemplParams" colspan="2"><a id="ac66731b70af2ad5aded1ce13a20acb29"></a>
template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:ac66731b70af2ad5aded1ce13a20acb29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (Allocator &amp;A) const</td></tr>
<tr class="separator:ac66731b70af2ad5aded1ce13a20acb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3595f2a07a2268edcfbf41ffa40cabf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#aa3595f2a07a2268edcfbf41ffa40cabf">equals</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> RHS) const</td></tr>
<tr class="separator:aa3595f2a07a2268edcfbf41ffa40cabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7f7ac7706e677e7b9f4e0ca544b4b6"><td class="memItemLeft" align="right" valign="top"><a id="abf7f7ac7706e677e7b9f4e0ca544b4b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#abf7f7ac7706e677e7b9f4e0ca544b4b6">equals_lower</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> RHS) const</td></tr>
<tr class="memdesc:abf7f7ac7706e677e7b9f4e0ca544b4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals_lower - Check for string equality, ignoring case. <br /></td></tr>
<tr class="separator:abf7f7ac7706e677e7b9f4e0ca544b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c6424784f132b91eb387a3ee0b57c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ae0c6424784f132b91eb387a3ee0b57c9">compare</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> RHS) const</td></tr>
<tr class="separator:ae0c6424784f132b91eb387a3ee0b57c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114425e993e60497e1aa121b31aeafd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a8114425e993e60497e1aa121b31aeafd">compare_lower</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> RHS) const</td></tr>
<tr class="memdesc:a8114425e993e60497e1aa121b31aeafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_lower - Compare two strings, ignoring case.  <a href="#a8114425e993e60497e1aa121b31aeafd">More...</a><br /></td></tr>
<tr class="separator:a8114425e993e60497e1aa121b31aeafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3989cbad7cca2a86cb7d3a0627748b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a8a3989cbad7cca2a86cb7d3a0627748b">compare_numeric</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> RHS) const</td></tr>
<tr class="memdesc:a8a3989cbad7cca2a86cb7d3a0627748b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_numeric - Compare strings, handle embedded numbers.  <a href="#a8a3989cbad7cca2a86cb7d3a0627748b">More...</a><br /></td></tr>
<tr class="separator:a8a3989cbad7cca2a86cb7d3a0627748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223dd14e7d12bc5cea01889b972a98b2"><td class="memItemLeft" align="right" valign="top"><a id="a223dd14e7d12bc5cea01889b972a98b2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a223dd14e7d12bc5cea01889b972a98b2">str</a> () const</td></tr>
<tr class="memdesc:a223dd14e7d12bc5cea01889b972a98b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">str - Get the contents as an std::string. <br /></td></tr>
<tr class="separator:a223dd14e7d12bc5cea01889b972a98b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1344e353958db14e66ec7ab574001a"><td class="memItemLeft" align="right" valign="top"><a id="abb1344e353958db14e66ec7ab574001a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>lower</b> () const</td></tr>
<tr class="separator:abb1344e353958db14e66ec7ab574001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c884ed90d5d38e5d0546d61c4bebe3e"><td class="memItemLeft" align="right" valign="top"><a id="a4c884ed90d5d38e5d0546d61c4bebe3e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a4c884ed90d5d38e5d0546d61c4bebe3e">upper</a> () const</td></tr>
<tr class="memdesc:a4c884ed90d5d38e5d0546d61c4bebe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given ASCII string to uppercase. <br /></td></tr>
<tr class="separator:a4c884ed90d5d38e5d0546d61c4bebe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operator Overloads</div></td></tr>
<tr class="memitem:a3ae8d94051e57dabbf8ffabfcbc9063d"><td class="memItemLeft" align="right" valign="top"><a id="a3ae8d94051e57dabbf8ffabfcbc9063d"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t Index) const</td></tr>
<tr class="separator:a3ae8d94051e57dabbf8ffabfcbc9063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Type Conversions</div></td></tr>
<tr class="memitem:adc4b9c79e65d33f208bef9be4e9d2795"><td class="memItemLeft" align="right" valign="top"><a id="adc4b9c79e65d33f208bef9be4e9d2795"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator std::string</b> () const</td></tr>
<tr class="separator:adc4b9c79e65d33f208bef9be4e9d2795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Predicates</div></td></tr>
<tr class="memitem:a84cd09ccc918883d51a387f0e0f374f3"><td class="memItemLeft" align="right" valign="top"><a id="a84cd09ccc918883d51a387f0e0f374f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a84cd09ccc918883d51a387f0e0f374f3">startswith</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Prefix) const</td></tr>
<tr class="memdesc:a84cd09ccc918883d51a387f0e0f374f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>. <br /></td></tr>
<tr class="separator:a84cd09ccc918883d51a387f0e0f374f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6567d7b8eb7471172aac7fd209bc67"><td class="memItemLeft" align="right" valign="top"><a id="a9e6567d7b8eb7471172aac7fd209bc67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a9e6567d7b8eb7471172aac7fd209bc67">startswith_lower</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Prefix) const</td></tr>
<tr class="memdesc:a9e6567d7b8eb7471172aac7fd209bc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>, ignoring case. <br /></td></tr>
<tr class="separator:a9e6567d7b8eb7471172aac7fd209bc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60f343c367de177ccd2cbdeb7e464f7"><td class="memItemLeft" align="right" valign="top"><a id="ac60f343c367de177ccd2cbdeb7e464f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ac60f343c367de177ccd2cbdeb7e464f7">endswith</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Suffix) const</td></tr>
<tr class="memdesc:ac60f343c367de177ccd2cbdeb7e464f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>. <br /></td></tr>
<tr class="separator:ac60f343c367de177ccd2cbdeb7e464f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ffa2e51e9420779e996ec2452330a1"><td class="memItemLeft" align="right" valign="top"><a id="a17ffa2e51e9420779e996ec2452330a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a17ffa2e51e9420779e996ec2452330a1">endswith_lower</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Suffix) const</td></tr>
<tr class="memdesc:a17ffa2e51e9420779e996ec2452330a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>, ignoring case. <br /></td></tr>
<tr class="separator:a17ffa2e51e9420779e996ec2452330a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Searching</div></td></tr>
<tr class="memitem:aab312a8386488873bac2eddfc67c22be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#aab312a8386488873bac2eddfc67c22be">find</a> (char C, size_t From=0) const</td></tr>
<tr class="separator:aab312a8386488873bac2eddfc67c22be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82369bea2700347f68e1f43e30d2d47b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a82369bea2700347f68e1f43e30d2d47b">find</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Str, size_t From=0) const</td></tr>
<tr class="separator:a82369bea2700347f68e1f43e30d2d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d45ce069c1a09ca84672df63acf096"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a97d45ce069c1a09ca84672df63acf096">rfind</a> (char C, size_t From=npos) const</td></tr>
<tr class="separator:a97d45ce069c1a09ca84672df63acf096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e5d9d8d99f68f9d4616bd026b0eab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#af90e5d9d8d99f68f9d4616bd026b0eab">rfind</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Str) const</td></tr>
<tr class="separator:af90e5d9d8d99f68f9d4616bd026b0eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b15a8c0022febbe39d17ab933737a8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a93b15a8c0022febbe39d17ab933737a8">find_first_of</a> (char C, size_t From=0) const</td></tr>
<tr class="separator:a93b15a8c0022febbe39d17ab933737a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38cc29d28845d48d8423918d8910d12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#af38cc29d28845d48d8423918d8910d12">find_first_of</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Chars, size_t From=0) const</td></tr>
<tr class="separator:af38cc29d28845d48d8423918d8910d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae851887270f35d2a2670a79b9833d45b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ae851887270f35d2a2670a79b9833d45b">find_first_not_of</a> (char C, size_t From=0) const</td></tr>
<tr class="separator:ae851887270f35d2a2670a79b9833d45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18de63f444e95dfff81803a482ab6eec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a18de63f444e95dfff81803a482ab6eec">find_first_not_of</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Chars, size_t From=0) const</td></tr>
<tr class="separator:a18de63f444e95dfff81803a482ab6eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7c222449f3208a532168c90bfb654d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a7a7c222449f3208a532168c90bfb654d">find_last_of</a> (char C, size_t From=npos) const</td></tr>
<tr class="separator:a7a7c222449f3208a532168c90bfb654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1226ed87e22d9ca9bfd8d2876c87ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#aef1226ed87e22d9ca9bfd8d2876c87ff">find_last_of</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Chars, size_t From=npos) const</td></tr>
<tr class="separator:aef1226ed87e22d9ca9bfd8d2876c87ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035cf6768564ead852edfff8ca9c3b6e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a035cf6768564ead852edfff8ca9c3b6e">find_last_not_of</a> (char C, size_t From=npos) const</td></tr>
<tr class="separator:a035cf6768564ead852edfff8ca9c3b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819cd72313f82bda3742dc58f3862f20"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a819cd72313f82bda3742dc58f3862f20">find_last_not_of</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Chars, size_t From=npos) const</td></tr>
<tr class="separator:a819cd72313f82bda3742dc58f3862f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Helpful Algorithms</div></td></tr>
<tr class="memitem:ac2c31b7b3c778d12aa176f9253511f37"><td class="memItemLeft" align="right" valign="top"><a id="ac2c31b7b3c778d12aa176f9253511f37"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ac2c31b7b3c778d12aa176f9253511f37">count</a> (char C) const</td></tr>
<tr class="memdesc:ac2c31b7b3c778d12aa176f9253511f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of occurrences of <code>C</code> in the string. <br /></td></tr>
<tr class="separator:ac2c31b7b3c778d12aa176f9253511f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797db79c8d98dcd992d5fe9a71ffe68c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a797db79c8d98dcd992d5fe9a71ffe68c">count</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Str) const</td></tr>
<tr class="separator:a797db79c8d98dcd992d5fe9a71ffe68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e373829f3f1775d30eae9053067f8c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e373829f3f1775d30eae9053067f8c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a9e373829f3f1775d30eae9053067f8c3">getAsInteger</a> (unsigned Radix, T &amp;Result) const</td></tr>
<tr class="separator:a9e373829f3f1775d30eae9053067f8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d4f7006eef7cd9a192930dc5bce325"><td class="memTemplParams" colspan="2"><a id="a20d4f7006eef7cd9a192930dc5bce325"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20d4f7006eef7cd9a192930dc5bce325"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAsInteger</b> (unsigned Radix, T &amp;Result) const</td></tr>
<tr class="separator:a20d4f7006eef7cd9a192930dc5bce325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Substring Operations</div></td></tr>
<tr class="memitem:a420b337450c77a515757ae722ffde97b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a420b337450c77a515757ae722ffde97b">substr</a> (size_t Start, size_t N=npos) const</td></tr>
<tr class="separator:a420b337450c77a515757ae722ffde97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb2867a1e9fa36e135d9ee4dffb0167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a3fb2867a1e9fa36e135d9ee4dffb0167">drop_front</a> (size_t N=1) const</td></tr>
<tr class="separator:a3fb2867a1e9fa36e135d9ee4dffb0167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2705fd641fb3d1eefa2691b5117cf22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ae2705fd641fb3d1eefa2691b5117cf22">drop_back</a> (size_t N=1) const</td></tr>
<tr class="separator:ae2705fd641fb3d1eefa2691b5117cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4c961b9b6f1da17df74b4496ecb30e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a5d4c961b9b6f1da17df74b4496ecb30e">slice</a> (size_t Start, size_t End) const</td></tr>
<tr class="separator:a5d4c961b9b6f1da17df74b4496ecb30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6414735714bdbd5c8790f32a0fe99bd2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>, <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a6414735714bdbd5c8790f32a0fe99bd2">split</a> (char Separator) const</td></tr>
<tr class="separator:a6414735714bdbd5c8790f32a0fe99bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ab0c952179eedd3c24fa0578047b3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>, <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a2f4ab0c952179eedd3c24fa0578047b3">split</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Separator) const</td></tr>
<tr class="separator:a2f4ab0c952179eedd3c24fa0578047b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0284e4c41c0e09c0bc4767bc77a899d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#af0284e4c41c0e09c0bc4767bc77a899d">split</a> (<a class="el" href="classllvm_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> &gt; &amp;A, <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Separator, int MaxSplit=-1, bool KeepEmpty=true) const</td></tr>
<tr class="separator:af0284e4c41c0e09c0bc4767bc77a899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0138ddc186a7cb5cfd04dde671220e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a7b0138ddc186a7cb5cfd04dde671220e">split</a> (<a class="el" href="classllvm_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> &gt; &amp;A, char Separator, int MaxSplit=-1, bool KeepEmpty=true) const</td></tr>
<tr class="separator:a7b0138ddc186a7cb5cfd04dde671220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46cdcd0049e8a5bfa033bcd49f88d5a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>, <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ac46cdcd0049e8a5bfa033bcd49f88d5a">rsplit</a> (char Separator) const</td></tr>
<tr class="separator:ac46cdcd0049e8a5bfa033bcd49f88d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8265efd805e4ce0c9d3c18e78194324c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a8265efd805e4ce0c9d3c18e78194324c">ltrim</a> (char Char) const</td></tr>
<tr class="separator:a8265efd805e4ce0c9d3c18e78194324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a6497123f39421c59539b518afc0f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a95a6497123f39421c59539b518afc0f5">ltrim</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Chars=&quot; \\\) const</td></tr>
<tr class="separator:a95a6497123f39421c59539b518afc0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b52404a8d2877d3b32ebb5d1f5c72ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a9b52404a8d2877d3b32ebb5d1f5c72ff">rtrim</a> (char Char) const</td></tr>
<tr class="separator:a9b52404a8d2877d3b32ebb5d1f5c72ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03643b47b082272ce96be89b00fc2307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#a03643b47b082272ce96be89b00fc2307">rtrim</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Chars=&quot; \\\) const</td></tr>
<tr class="separator:a03643b47b082272ce96be89b00fc2307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9990397f97b40d5d8564e000d00174a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#ab9990397f97b40d5d8564e000d00174a">trim</a> (char Char) const</td></tr>
<tr class="separator:ab9990397f97b40d5d8564e000d00174a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7e99f47ae0d0573a3f0868ed293861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1_string_ref.html#aba7e99f47ae0d0573a3f0868ed293861">trim</a> (<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> Chars=&quot; \\\) const</td></tr>
<tr class="separator:aba7e99f47ae0d0573a3f0868ed293861"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7414af479a1a88b0631120a4fc681e20"><td class="memItemLeft" align="right" valign="top"><a id="a7414af479a1a88b0631120a4fc681e20"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>npos</b> = ~size_t(0)</td></tr>
<tr class="separator:a7414af479a1a88b0631120a4fc681e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> - Represent a constant reference to a string, i.e. a character array and a length, which need not be null terminated.</p>
<p>This class does not own the string data, it is expected to be used in situations where the character data resides in some other buffer, whose lifetime extends past that of the <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>. For this reason, it is not in general safe to store a <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e698ced744f380762a17f64a7cbd0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e698ced744f380762a17f64a7cbd0aa">&#9670;&nbsp;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * StringRef::c_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_small_vector_impl.html">llvm::SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>c_str - Get a null terminated pointer to the start of the string If string is not null terminated, use buffer to store new string </p>

</div>
</div>
<a id="ae0c6424784f132b91eb387a3ee0b57c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c6424784f132b91eb387a3ee0b57c9">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int llvm::StringRef::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compare - Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less than, equal to, or greater than the <code>RHS</code>. </p>

</div>
</div>
<a id="a8114425e993e60497e1aa121b31aeafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8114425e993e60497e1aa121b31aeafd">&#9670;&nbsp;</a></span>compare_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StringRef::compare_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare_lower - Compare two strings, ignoring case. </p>
<p>compare_lower - Compare strings, ignoring case. </p>

</div>
</div>
<a id="a8a3989cbad7cca2a86cb7d3a0627748b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3989cbad7cca2a86cb7d3a0627748b">&#9670;&nbsp;</a></span>compare_numeric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StringRef::compare_numeric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare_numeric - Compare strings, handle embedded numbers. </p>
<p>compare_numeric - Compare two strings, treating sequences of digits as numbers. </p>

</div>
</div>
<a id="a797db79c8d98dcd992d5fe9a71ffe68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797db79c8d98dcd992d5fe9a71ffe68c">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t StringRef::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of non-overlapped occurrences of <code>Str</code> in the string.</p>
<p>count - Return the number of non-overlapped occurrences of </p><ul>
<li>Str in the string. </li>
</ul>

</div>
</div>
<a id="ad04539d64efd58e70c5e828739cf718e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04539d64efd58e70c5e828739cf718e">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* llvm::StringRef::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>data - Get a pointer to the start of the string (which may not be null terminated). </p>

</div>
</div>
<a id="ae2705fd641fb3d1eefa2691b5117cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2705fd641fb3d1eefa2691b5117cf22">&#9670;&nbsp;</a></span>drop_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::drop_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> equal to 'this' but with the last <code>N</code> elements dropped. </p>

</div>
</div>
<a id="a3fb2867a1e9fa36e135d9ee4dffb0167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb2867a1e9fa36e135d9ee4dffb0167">&#9670;&nbsp;</a></span>drop_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::drop_front </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> equal to 'this' but with the first <code>N</code> elements dropped. </p>

</div>
</div>
<a id="aa3595f2a07a2268edcfbf41ffa40cabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3595f2a07a2268edcfbf41ffa40cabf">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llvm::StringRef::equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>equals - Check for string equality, this is more efficient than <a class="el" href="classllvm_1_1_string_ref.html#ae0c6424784f132b91eb387a3ee0b57c9">compare()</a> when the relative ordering of inequal strings isn't needed. </p>

</div>
</div>
<a id="aab312a8386488873bac2eddfc67c22be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab312a8386488873bac2eddfc67c22be">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the first character <code>C</code> in the string.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a82369bea2700347f68e1f43e30d2d47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82369bea2700347f68e1f43e30d2d47b">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t StringRef::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the first string <code>Str</code> in the string.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>Str</code>, or npos if not found.</dd></dl>
<p>find - Search for the first string </p><ul>
<li>Str in the string.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>- The index of the first occurrence of <ul>
<li>Str, or npos if not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae851887270f35d2a2670a79b9833d45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae851887270f35d2a2670a79b9833d45b">&#9670;&nbsp;</a></span>find_first_not_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first character in the string that is not <code>C</code> or npos if not found.</p>
<p>find_first_not_of - Find the first character in the string that is not </p><ul>
<li>C or npos if not found. </li>
</ul>

</div>
</div>
<a id="a18de63f444e95dfff81803a482ab6eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18de63f444e95dfff81803a482ab6eec">&#9670;&nbsp;</a></span>find_first_not_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first character in the string that is not in the string <code>Chars</code>, or npos if not found.</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<p>find_first_not_of - Find the first character in the string that is not in the string </p><ul>
<li>Chars, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="a93b15a8c0022febbe39d17ab933737a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b15a8c0022febbe39d17ab933737a8">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the first character in the string that is <code>C</code>, or npos if not found. Same as find. </p>

</div>
</div>
<a id="af38cc29d28845d48d8423918d8910d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38cc29d28845d48d8423918d8910d12">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the first character in the string that is in <code>Chars</code>, or npos if not found.</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<p>find_first_of - Find the first character in the string that is in </p><ul>
<li>Chars, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="a035cf6768564ead852edfff8ca9c3b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035cf6768564ead852edfff8ca9c3b6e">&#9670;&nbsp;</a></span>find_last_not_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the last character in the string that is not <code>C</code>, or npos if not found.</p>
<p>find_last_not_of - Find the last character in the string that is not </p><ul>
<li>C, or npos if not found. </li>
</ul>

</div>
</div>
<a id="a819cd72313f82bda3742dc58f3862f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819cd72313f82bda3742dc58f3862f20">&#9670;&nbsp;</a></span>find_last_not_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the last character in the string that is not in <code>Chars</code>, or npos if not found.</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<p>find_last_not_of - Find the last character in the string that is not in </p><ul>
<li>Chars, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="a7a7c222449f3208a532168c90bfb654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7c222449f3208a532168c90bfb654d">&#9670;&nbsp;</a></span>find_last_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the last character in the string that is <code>C</code>, or npos if not found. </p>

</div>
</div>
<a id="aef1226ed87e22d9ca9bfd8d2876c87ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1226ed87e22d9ca9bfd8d2876c87ff">&#9670;&nbsp;</a></span>find_last_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the last character in the string that is in <code>C</code>, or npos if not found.</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<p>find_last_of - Find the last character in the string that is in </p><ul>
<li>C, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1_string_ref.html#aca08551f168e2745a0b71e6442fc0fb0" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="a9e373829f3f1775d30eae9053067f8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e373829f3f1775d30eae9053067f8c3">&#9670;&nbsp;</a></span>getAsInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type llvm::StringRef::getAsInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the current string as an integer of the specified radix. If <code>Radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string is invalid or if only a subset of the string is valid, this returns true to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

</div>
</div>
<a id="a8265efd805e4ce0c9d3c18e78194324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8265efd805e4ce0c9d3c18e78194324c">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::ltrim </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return string with consecutive <code>Char</code> characters starting from the the left removed. </p>

</div>
</div>
<a id="a95a6497123f39421c59539b518afc0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a6497123f39421c59539b518afc0f5">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::ltrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return string with consecutive characters in <code>Chars</code> starting from the left removed. </p>

</div>
</div>
<a id="a97d45ce069c1a09ca84672df63acf096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d45ce069c1a09ca84672df63acf096">&#9670;&nbsp;</a></span>rfind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the last character <code>C</code> in the string.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="af90e5d9d8d99f68f9d4616bd026b0eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90e5d9d8d99f68f9d4616bd026b0eab">&#9670;&nbsp;</a></span>rfind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the last string <code>Str</code> in the string.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>Str</code>, or npos if not found.</dd></dl>
<p>rfind - Search for the last string </p><ul>
<li>Str in the string.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>- The index of the last occurrence of <ul>
<li>Str, or npos if not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac46cdcd0049e8a5bfa033bcd49f88d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46cdcd0049e8a5bfa033bcd49f88d5a">&#9670;&nbsp;</a></span>rsplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>, <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&gt; llvm::StringRef::rsplit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split into two substrings around the last occurrence of a separator character.</p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is minimal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

</div>
</div>
<a id="a9b52404a8d2877d3b32ebb5d1f5c72ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b52404a8d2877d3b32ebb5d1f5c72ff">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::rtrim </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return string with consecutive <code>Char</code> characters starting from the right removed. </p>

</div>
</div>
<a id="a03643b47b082272ce96be89b00fc2307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03643b47b082272ce96be89b00fc2307">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::rtrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return string with consecutive characters in <code>Chars</code> starting from the right removed. </p>

</div>
</div>
<a id="a5d4c961b9b6f1da17df74b4496ecb30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4c961b9b6f1da17df74b4496ecb30e">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>End</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the substring from [Start, End).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">End</td><td>The index following the last character to include in the substring. If this is npos or exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. If this is less than <code>Start</code>, an empty string will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6414735714bdbd5c8790f32a0fe99bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6414735714bdbd5c8790f32a0fe99bd2">&#9670;&nbsp;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>, <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&gt; llvm::StringRef::split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split into two substrings around the first occurrence of a separator character.</p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="a2f4ab0c952179eedd3c24fa0578047b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4ab0c952179eedd3c24fa0578047b3">&#9670;&nbsp;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>, <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&gt; llvm::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split into two substrings around the first occurrence of a separator string.</p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

</div>
</div>
<a id="af0284e4c41c0e09c0bc4767bc77a899d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0284e4c41c0e09c0bc4767bc77a899d">&#9670;&nbsp;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>KeepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split into substrings around the occurrences of a separator string.</p>
<p>Each substring is stored in <code>A</code>. If <code>MaxSplit</code> is &gt;= 0, at most <code>MaxSplit</code> splits are done and consequently &lt;= <code>MaxSplit</code> + 1 elements are added to A. If <code>KeepEmpty</code> is false, empty strings are not added to <code>A</code>. They still count when considering <code>MaxSplit</code> An useful invariant is that Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- Where to put the substrings. </td></tr>
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
    <tr><td class="paramname">MaxSplit</td><td>- The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">KeepEmpty</td><td>- True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b0138ddc186a7cb5cfd04dde671220e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0138ddc186a7cb5cfd04dde671220e">&#9670;&nbsp;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>KeepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split into substrings around the occurrences of a separator character.</p>
<p>Each substring is stored in <code>A</code>. If <code>MaxSplit</code> is &gt;= 0, at most <code>MaxSplit</code> splits are done and consequently &lt;= <code>MaxSplit</code> + 1 elements are added to A. If <code>KeepEmpty</code> is false, empty strings are not added to <code>A</code>. They still count when considering <code>MaxSplit</code> An useful invariant is that Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- Where to put the substrings. </td></tr>
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
    <tr><td class="paramname">MaxSplit</td><td>- The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">KeepEmpty</td><td>- True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a420b337450c77a515757ae722ffde97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420b337450c77a515757ae722ffde97b">&#9670;&nbsp;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the substring from [Start, Start + N).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">N</td><td>The number of characters to included in the substring. If N exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9990397f97b40d5d8564e000d00174a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9990397f97b40d5d8564e000d00174a">&#9670;&nbsp;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::trim </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return string with consecutive <code>Char</code> characters starting from the left and right removed. </p>

</div>
</div>
<a id="aba7e99f47ae0d0573a3f0868ed293861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7e99f47ae0d0573a3f0868ed293861">&#9670;&nbsp;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a> llvm::StringRef::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_string_ref.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return string with consecutive characters in <code>Chars</code> starting from the left and right removed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>third_party/wpiutil/src/main/native/include/llvm/<a class="el" href="_string_ref_8h_source.html">StringRef.h</a></li>
<li>third_party/wpiutil/src/main/native/cpp/llvm/StringRef.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
